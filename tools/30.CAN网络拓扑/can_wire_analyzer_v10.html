<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CANç½‘ç»œçº¿æŸåˆ†æå·¥å…· V10 - æ€§èƒ½ä¼˜åŒ–ç‰ˆ</title>
    <!-- SheetJSç”¨äºè¯»å–Excelæ–‡ä»¶ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <!-- ExcelJSç”¨äºå¯¼å‡ºå¸¦æ ·å¼çš„Excel -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <!-- FileSaverç”¨äºæ–‡ä»¶ä¸‹è½½ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- D3.jsç”¨äºæ‹“æ‰‘å›¾ç»˜åˆ¶ -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            margin: 0;
            overflow: hidden;
        }

        body {
            padding: 5px;
        }

        .container {
            width: 100%;
            max-width: 100%;
            margin: 0;
            background: white;
            border-radius: 10px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 10px);
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 20px;
            text-align: center;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 20px;
            margin-bottom: 3px;
        }

        .header p {
            font-size: 11px;
            opacity: 0.9;
        }

        .header .version-badge {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 10px;
            margin-left: 8px;
            font-weight: 600;
        }

        .upload-section {
            padding: 15px 20px;
            text-align: center;
            border-bottom: 1px solid #eee;
            flex-shrink: 0;
        }

        .upload-area {
            border: 2px dashed #667eea;
            border-radius: 8px;
            padding: 20px;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }

        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 36px;
            margin-bottom: 10px;
        }

        .upload-text {
            font-size: 14px;
            color: #333;
            margin-bottom: 5px;
        }

        .upload-hint {
            font-size: 11px;
            color: #999;
        }

        #fileInput, #inlineFileInput {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }

        .stats-section {
            padding: 10px 20px;
            background: #f8f9fa;
            border-bottom: 1px solid #eee;
            display: none;
            flex-shrink: 0;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
        }

        .stat-card {
            background: white;
            padding: 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            text-align: center;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 3px;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
        }

        .filter-section {
            padding: 10px 20px;
            background: white;
            border-bottom: 1px solid #eee;
            display: none;
            flex-shrink: 0;
        }

        .filter-section h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 14px;
        }

        .filter-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }

        .filter-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .filter-item label {
            font-size: 14px;
            color: #555;
        }

        .filter-item select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
            min-width: 150px;
        }

        .buttons {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 239, 125, 0.4);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-copy {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }

        .btn-copy:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(245, 87, 108, 0.4);
        }

        .btn-topo {
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
        }

        .btn-topo:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(79, 172, 254, 0.4);
        }

        .topology-section {
            padding: 10px 20px;
            display: none;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
            background: #f8f9fa;
            min-height: 500px;
        }

        .topology-container {
            display: flex;
            flex: 1;
            gap: 15px;
            overflow: hidden;
        }

        .topology-sidebar {
            width: 320px;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .topology-sidebar-section {
            margin-bottom: 15px;
        }

        .topology-sidebar-section h4 {
            font-size: 13px;
            color: #333;
            margin-bottom: 8px;
            padding-bottom: 5px;
            border-bottom: 1px solid #eee;
        }

        .topology-info-item {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            font-size: 11px;
        }

        .topology-info-label {
            color: #666;
        }

        .topology-info-value {
            color: #333;
            font-weight: 600;
        }

        .topology-type-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .topology-type-bus { background: #e3f2fd; color: #1976d2; }
        .topology-type-series { background: #fff3e0; color: #f57c00; }
        .topology-type-parallel { background: #e8f5e9; color: #388e3c; }
        .topology-type-mixed { background: #fce4ec; color: #c2185b; }

        .warning-item {
            padding: 8px 10px;
            background: #fff3e0;
            border-left: 3px solid #ff9800;
            border-radius: 4px;
            font-size: 11px;
            margin-bottom: 6px;
        }

        .warning-item.critical {
            background: #ffebee;
            border-left-color: #f44336;
        }

        .topology-item {
            padding: 10px;
            margin-bottom: 8px;
            background: #f8f9ff;
            border: 1px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .topology-item:hover {
            background: #e8ebff;
            border-color: #667eea;
        }

        .topology-item.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .topology-item-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 4px;
        }

        .topology-item-info {
            font-size: 11px;
            opacity: 0.8;
        }

        .topology-canvas-container {
            flex: 1;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        #topologyCanvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: move;
        }

        .topology-legend {
            position: absolute;
            top: 15px;
            right: 15px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.15);
            font-size: 12px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            gap: 8px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-ecu {
            width: 30px;
            height: 20px;
            background: #45b7d1;
            border: 2px solid #fff;
            border-radius: 4px;
        }

        .legend-splice {
            width: 16px;
            height: 16px;
            background: #ffa500;
            border: 2px solid #fff;
            border-radius: 50%;
        }

        .legend-inline {
            width: 20px;
            height: 30px;
            background: #4ecdc4;
            border: 2px solid #fff;
            border-radius: 4px;
        }

        .legend-resistor {
            width: 20px;
            height: 30px;
            background: #333333;
            border: 2px solid #000000;
            border-radius: 3px;
        }

        .legend-line-can-high {
            width: 30px;
            height: 3px;
            background: #667eea;
            border-radius: 2px;
        }

        .legend-line-can-low {
            width: 30px;
            height: 3px;
            background: #764ba2;
            border-radius: 2px;
        }

        /* WireListä¾§è¾¹æ æ ·å¼ */
        .topology-wirelist-sidebar {
            width: 220px;
            background: white;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
        }

        .wirelist-item {
            padding: 8px 10px;
            margin-bottom: 6px;
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .wirelist-item:hover {
            background: #e3f2fd;
            border-color: #667eea;
        }

        .wirelist-item.active {
            background: #667eea;
            color: white;
            border-color: #667eea;
        }

        .wirelist-item .wire-id {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 3px;
        }

        .wirelist-item .wire-route {
            font-size: 10px;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .wirelist-item.active .wire-route {
            color: rgba(255, 255, 255, 0.8);
        }

        .wirelist-item .wire-signal {
            display: inline-block;
            font-size: 9px;
            padding: 1px 4px;
            border-radius: 2px;
            margin-left: 5px;
        }

        .wirelist-item .wire-signal.ch {
            background: #667eea;
            color: white;
        }

        .wirelist-item .wire-signal.cl {
            background: #764ba2;
            color: white;
        }

        .results-section {
            padding: 10px 20px;
            display: none;
            flex: 1;
            overflow: hidden;
            flex-direction: column;
            min-height: 0;
            max-height: none;
        }

        .results-section h2 {
            margin-bottom: 8px;
            color: #333;
            font-size: 16px;
            flex-shrink: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            font-size: 11px;
        }

        thead {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #000000;
            position: sticky;
            top: 0;
            z-index: 10;
            will-change: transform;
        }

        th {
            padding: 8px 6px;
            text-align: left;
            font-weight: 600;
            white-space: nowrap;
            font-size: 11px;
            position: sticky;
            top: 0;
            color: #000000;
        }

        td {
            padding: 6px;
            border-bottom: 1px solid #eee;
            white-space: nowrap;
            font-size: 11px;
        }

        .table-container {
            overflow-y: scroll;
            overflow-x: auto;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            flex: 1;
            border: 1px solid #eee;
            min-height: 300px;
            max-height: none;
            position: relative;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior: contain;
            scrollbar-width: auto;
            scrollbar-color: #667eea #f1f1f1;
        }

        .table-container::-webkit-scrollbar {
            width: 14px;
            height: 14px;
        }

        .table-container::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 6px;
        }

        .table-container::-webkit-scrollbar-thumb {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 6px;
            border: 2px solid #f1f1f1;
        }

        .table-container::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .table-container::-webkit-scrollbar-corner {
            background: #f1f1f1;
        }

        tbody tr {
            will-change: transform;
        }

        tbody tr:hover {
            background: #f8f9ff;
        }

        .can-high {
            background: rgba(102, 126, 234, 0.1);
        }

        .can-low {
            background: rgba(118, 75, 162, 0.1);
        }

        table {
            transform: translateZ(0);
            -webkit-transform: translateZ(0);
        }

        .classification-badge {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .badge-high {
            background: #667eea;
            color: white;
        }

        .badge-low {
            background: #764ba2;
            color: white;
        }

        .pagination {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            margin-top: 8px;
            padding: 8px 20px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }

        .pagination button {
            padding: 5px 10px;
            margin: 0 2px;
            font-size: 12px;
        }

        .pagination button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .pagination-info {
            font-size: 12px;
            color: #666;
        }

        .page-size-selector {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-left: 10px;
        }

        .page-size-selector select {
            padding: 4px 6px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 15px;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            background: #f8d7da;
            color: #721c24;
            padding: 8px 20px;
            border-radius: 6px;
            margin: 10px 20px;
            display: none;
            border-left: 4px solid #dc3545;
            font-size: 13px;
        }

        .success-message {
            background: #d4edda;
            color: #155724;
            padding: 8px 20px;
            border-radius: 6px;
            margin: 10px 20px;
            display: none;
            border-left: 4px solid #28a745;
            font-size: 13px;
        }

        .progress-container {
            display: none;
            padding: 8px 20px;
            background: #f8f9fa;
            flex-shrink: 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 10px;
            font-weight: 600;
        }

        /* å…¨å±æ¨¡å¼æ ·å¼ */
        .topology-section.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 9998;
            background: white;
            padding: 0;
            margin: 0;
            display: flex !important;
            flex-direction: column;
        }

        .topology-section.fullscreen .header {
            display: none;
        }

        .topology-section.fullscreen .topology-container {
            flex: 1;
            height: 100%;
            margin: 0;
        }

        .topology-section.fullscreen .topology-canvas-container {
            height: 100%;
        }

        .topology-section.fullscreen .filter-section,
        .topology-section.fullscreen .stats-section {
            display: none !important;
        }

        .topology-section.fullscreen .topology-sidebar,
        .topology-section.fullscreen .topology-wirelist-sidebar {
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        /* æ‹“æ‰‘å·¥å…·æ æ ·å¼ */
        .topology-toolbar {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .topology-toolbar select {
            padding: 5px 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
        }

        .topology-toolbar label {
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CANç½‘ç»œçº¿æŸåˆ†æå·¥å…· <span class="version-badge">V10</span></h1>
            <p>CANæ€»çº¿æ‹“æ‰‘åˆ†æ Â· ç”µè·¯æ‹“æ‰‘è¯†åˆ«ä¸è¯Šæ–­ Â· æ€§èƒ½ä¼˜åŒ–ç‰ˆ</p>
        </div>

        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <input type="file" id="fileInput" accept=".xlsx,.xls,.csv" />
                <div class="upload-icon">ğŸ“</div>
                <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ çº¿æŸè¡¨æ–‡ä»¶</div>
                <div class="upload-hint">æ”¯æŒ .xlsx, .xls, .csv æ ¼å¼</div>
            </div>
        </div>

        <div class="upload-section" style="padding-top: 0;">
            <div class="upload-area" id="inlineUploadArea" style="border-color: #764ba2; background: #fdf0ff;">
                <input type="file" id="inlineFileInput" accept=".xlsx,.xls" />
                <div class="upload-icon">ğŸ“‹</div>
                <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½ä¸Šä¼ Inlineè¡¨æ–‡ä»¶</div>
                <div class="upload-hint">æ”¯æŒ .xlsx, .xls æ ¼å¼ï¼ˆå®šä¹‰èŠ‚ç‚¹é…å¯¹å…³ç³»ï¼‰</div>
            </div>
        </div>

        <div class="error-message" id="errorMessage"></div>
        <div class="success-message" id="successMessage"></div>

        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill">0%</div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <div>æ­£åœ¨å¤„ç†æ•°æ®...</div>
        </div>

        <div class="stats-section" id="statsSection">
            <h3 style="margin-bottom: 20px; color: #333;">æ•°æ®ç»Ÿè®¡</h3>
            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-number" id="totalWires">0</div>
                    <div class="stat-label">æ€»çº¿è·¯æ•°</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="canWires">0</div>
                    <div class="stat-label">CANçº¿è·¯æ•°</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="canTypes">0</div>
                    <div class="stat-label">CANç±»å‹æ•°</div>
                </div>
                <div class="stat-card">
                    <div class="stat-number" id="multicoreGroups">0</div>
                    <div class="stat-label">Multicoreç»„æ•°</div>
                </div>
            </div>
        </div>

        <div class="filter-section" id="filterSection">
            <h3>ç­›é€‰æ¡ä»¶</h3>
            <div class="filter-group">
                <div class="filter-item">
                    <label for="canTypeFilter">CANç±»å‹:</label>
                    <select id="canTypeFilter">
                        <option value="">å…¨éƒ¨</option>
                    </select>
                </div>
                <div class="filter-item">
                    <label for="signalFilter">ä¿¡å·ç±»å‹:</label>
                    <select id="signalFilter">
                        <option value="">å…¨éƒ¨</option>
                        <option value="CAN High">CAN High (CH)</option>
                        <option value="CAN Low">CAN Low (CL)</option>
                    </select>
                </div>
            </div>
            <div class="buttons">
                <button class="btn-primary" onclick="applyFilters()">åº”ç”¨ç­›é€‰</button>
                <button class="btn-secondary" onclick="resetFilters()">é‡ç½®</button>
                <button class="btn-success" onclick="exportToExcel()">å¯¼å‡ºExcel</button>
                <button class="btn-copy" onclick="copyTableToClipboard()" title="å¤åˆ¶ä¸ºHTMLæ ¼å¼">ğŸ“‹ å¤åˆ¶è¡¨æ ¼</button>
                <button class="btn-topo" onclick="showTopology()" title="æ˜¾ç¤ºCANç½‘ç»œæ‹“æ‰‘">ğŸ”— æ‹“æ‰‘å›¾</button>
            </div>
        </div>

        <div class="results-section" id="resultsSection">
            <h2>CANçº¿æŸåˆ†æç»“æœ</h2>
            <div class="table-container">
                <table id="resultsTable">
                    <thead>
                        <tr id="tableHeader"></tr>
                    </thead>
                    <tbody id="tableBody"></tbody>
                </table>
            </div>

            <div class="pagination" id="pagination"></div>
        </div>

        <!-- æ‹“æ‰‘å›¾åŒºåŸŸ -->
        <div class="topology-section" id="topologySection" style="display: none;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding: 0 20px;">
                <h2 style="color: #333; font-size: 16px; margin: 0;">CANç½‘ç»œæ‹“æ‰‘å›¾ V5</h2>
                <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                    <button class="btn-primary" onclick="switchTopologyView('bus')" id="busViewBtn" style="padding: 5px 15px;">
                        ğŸšŒ æ€»çº¿æ‹“æ‰‘
                    </button>
                    <button class="btn-secondary" onclick="switchTopologyView('circuit')" id="circuitViewBtn" style="padding: 5px 15px;">
                        ğŸ”— å›è·¯è¿æ¥
                    </button>
                    <button class="btn-primary" onclick="switchTopologyView('topology')" id="topologyViewBtn" style="padding: 5px 15px;">
                        ğŸ“Š æ‹“æ‰‘åˆ†æ
                    </button>
                    <button class="btn-success" onclick="exportOptimizationReport()" id="exportReportBtn" style="padding: 5px 15px;">
                        ğŸ“„ ä¼˜åŒ–æŠ¥å‘Š
                    </button>
                    <button class="btn-primary" onclick="toggleFullscreen()" id="fullscreenBtn" style="padding: 5px 15px;">
                        â›¶ å…¨å±
                    </button>
                    <button class="btn-secondary" onclick="closeTopology()" style="padding: 5px 15px;">å…³é—­</button>
                </div>
            </div>

            <!-- V5æ–°å¢ï¼šæ‹“æ‰‘å·¥å…·æ  -->
            <div id="topologyToolbar" style="display: flex; gap: 15px; padding: 8px 20px; background: #f0f2ff; border-bottom: 1px solid #ddd; margin-bottom: 10px; flex-wrap: wrap; align-items: center;">
                <div style="display: flex; gap: 8px; align-items: center;">
                    <label for="layoutSelect">å¸ƒå±€:</label>
                    <select id="layoutSelect" onchange="changeLayout(this.value)">
                        <option value="auto">è‡ªåŠ¨</option>
                        <option value="bus">æ€»çº¿å¸ƒå±€</option>
                        <option value="hierarchical">å±‚çº§å¸ƒå±€</option>
                        <option value="force">åŠ›å¯¼å‘å¸ƒå±€</option>
                    </select>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <label for="displaySelect">æ˜¾ç¤º:</label>
                    <select id="displaySelect" onchange="changeDisplay(this.value)">
                        <option value="all">å…¨éƒ¨</option>
                        <option value="high">ä»…CAN High</option>
                        <option value="low">ä»…CAN Low</option>
                    </select>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="checkbox" id="showWireLabels" checked onchange="toggleWireLabels()">
                    <label for="showWireLabels">æ˜¾ç¤ºçº¿å·</label>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="checkbox" id="showTerminalResistors" checked onchange="toggleTerminalResistors()">
                    <label for="showTerminalResistors">ç»ˆç«¯ç”µé˜»</label>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <input type="checkbox" id="mergeConnectors" onchange="toggleMergeConnectors()">
                    <label for="mergeConnectors">æ’ä»¶åˆå¹¶</label>
                </div>
                <div style="display: flex; gap: 8px; align-items: center;">
                    <label for="pinSpacing">PINé—´è·:</label>
                    <input type="number" id="pinSpacing" value="25" min="15" max="50" style="width: 50px;" onchange="updatePinSpacing()">
                </div>
            </div>

            <!-- å…¨å±æ—¶çš„æ§åˆ¶æ  -->
            <div id="fullscreenControls" style="display: none; position: fixed; top: 10px; right: 10px; z-index: 9999; background: rgba(255,255,255,0.95); padding: 10px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
                <div style="display: flex; gap: 8px; align-items: center;">
                    <span style="font-size: 12px; color: #666;">æ“ä½œæç¤º:</span>
                    <span style="font-size: 11px; color: #999;">æ»šè½®ç¼©æ”¾ | ä¸­é”®æ‹–æ‹½ç§»åŠ¨</span>
                    <div style="border-left: 1px solid #ddd; height: 20px; margin: 0 8px;"></div>
                    <button class="btn-secondary" onclick="toggleFullscreen()" style="padding: 5px 10px; font-size: 12px;">âœ• é€€å‡ºå…¨å±</button>
                </div>
            </div>

            <div class="topology-container">
                <div class="topology-sidebar" id="topologySidebar">
                    <div class="topology-sidebar-section">
                        <h4>æ‹“æ‰‘ä¿¡æ¯</h4>
                        <div class="topology-info-item">
                            <span class="topology-info-label">æ‹“æ‰‘ç±»å‹</span>
                            <span class="topology-info-value" id="topologyType">-</span>
                        </div>
                        <div class="topology-info-item">
                            <span class="topology-info-label">èŠ‚ç‚¹æ€»æ•°</span>
                            <span class="topology-info-value" id="totalNodes">-</span>
                        </div>
                        <div class="topology-info-item">
                            <span class="topology-info-label">ECUæ•°é‡</span>
                            <span class="topology-info-value" id="ecuCount">-</span>
                        </div>
                        <div class="topology-info-item">
                            <span class="topology-info-label">ç„Šç‚¹æ•°é‡</span>
                            <span class="topology-info-value" id="spliceCount">-</span>
                        </div>
                        <div class="topology-info-item">
                            <span class="topology-info-label">Inlineæ•°é‡</span>
                            <span class="topology-info-value" id="inlineCount">-</span>
                        </div>
                        <div class="topology-info-item">
                            <span class="topology-info-label">å¯¼çº¿æ•°é‡</span>
                            <span class="topology-info-value" id="wireCount">-</span>
                        </div>
                        <div class="topology-info-item">
                            <span class="topology-info-label">å¤æ‚åº¦</span>
                            <span class="topology-info-value" id="complexity">-</span>
                        </div>
                    </div>

                    <div class="topology-sidebar-section" id="warningsSection">
                        <h4>è¯Šæ–­è­¦å‘Š</h4>
                        <div id="warningsList">
                            <div style="color: #999; font-size: 11px;">æ— è­¦å‘Š</div>
                        </div>
                    </div>

                    <div class="topology-sidebar-section">
                        <h4>CANç±»å‹</h4>
                        <div id="topologyList"></div>
                    </div>

                    <div class="topology-sidebar-section">
                        <h4>å›è·¯è¯¦æƒ…</h4>
                        <div id="circuitDetailList" style="font-size: 11px; max-height: 200px; overflow-y: auto;"></div>
                    </div>
                </div>

                <div class="topology-canvas-container" style="position: relative;">
                    <svg id="topologyCanvas"></svg>
                    <div class="topology-legend">
                        <div class="legend-item">
                            <div class="legend-ecu"></div>
                            <span>ECUèŠ‚ç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-resistor"></div>
                            <span>ç»ˆç«¯ç”µé˜»120Î©</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-splice"></div>
                            <span>ç„Šç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-inline"></div>
                            <span>InlineèŠ‚ç‚¹</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line-can-high"></div>
                            <span>CAN High</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-line-can-low"></div>
                            <span>CAN Low</span>
                        </div>
                    </div>
                </div>

                <div class="topology-wirelist-sidebar">
                    <h4 style="font-size: 14px; margin-bottom: 10px; color: #333;">WireList</h4>
                    <div style="font-size: 11px; color: #666; margin-bottom: 10px;">
                        <span id="wirelistCanType">å½“å‰: -</span>
                    </div>
                    <label for="wirelistSearch" style="font-size: 12px; color: #666;">æœç´¢:</label>
                    <input type="text" id="wirelistSearch" placeholder="æœç´¢Wire ID..."
                           style="width: 100%; padding: 6px 10px; border: 1px solid #ddd; border-radius: 4px; margin-bottom: 10px; font-size: 12px;">
                    <div id="wirelistCount" style="font-size: 11px; color: #999; margin-bottom: 8px;"></div>
                    <div id="wirelistContainer" style="font-size: 11px; max-height: 500px; overflow-y: auto;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // è°ƒè¯•å¼€å…³ - ç”Ÿäº§ç¯å¢ƒè®¾ä¸ºfalseå¯æå‡æ€§èƒ½
        const DEBUG = false;

        // è°ƒè¯•æ—¥å¿—å‡½æ•°
        function debugLog(...args) {
            if (DEBUG) console.log(...args);
        }
        function debugError(...args) {
            if (DEBUG) console.error(...args);
        }

        // å…¨å±€å˜é‡
        let originalData = [];
        let filteredData = [];
        let inlineData = [];
        let headers = [];
        let canTypes = new Set();
        let currentPage = 1;
        let pageSize = 50;
        let totalPages = 1;
        let isProcessing = false;
        let inlinePairsMap = new Map(); // ä» inline.xlsx åŠ è½½çš„é…å¯¹å…³ç³»

        // å…¨å±æ¨¡å¼å˜é‡
        let isFullscreen = false;

        // æ‹“æ‰‘è§†å›¾ç±»å‹
        let currentTopologyView = 'bus';

        // æ‹“æ‰‘å›¾èŠ‚ç‚¹æ‹–æ‹½å˜é‡
        let topologyDragEnabled = true;
        let draggingTopologyNode = null;
        let nodeDragOffset = { x: 0, y: 0 };

        // å½“å‰æ¸²æŸ“çš„å¸ƒå±€å’Œæ‹“æ‰‘æ•°æ®ï¼Œç”¨äºæ‹–åŠ¨æ›´æ–°
        let activeLayout = null;
        let activeCanTypeGroup = null;
        let activeTopologyData = null;
        let activeDragNode = null;  // å½“å‰æ‹–åŠ¨çš„èŠ‚ç‚¹

        // å›è·¯è¿æ¥æ‹“æ‰‘æ‹–åŠ¨ç›¸å…³æ•°æ®
        let activeCircuitModules = null;      // å½“å‰å›è·¯çš„modules Map
        let activeCircuitPinPositions = null; // å½“å‰å›è·¯çš„pinPositions Map
        let activeCircuitInlinePairMap = null;// å½“å‰å›è·¯çš„inlineé…å¯¹Map
        let activeCircuitInlinePairs = null;  // å½“å‰å›è·¯çš„inlineå¯¹æ•°ç»„
        let activeCircuitInlinePairPins = null;// å½“å‰å›è·¯çš„inlineå¯¹PINä½ç½®Map
        let activeCircuitDragModule = null;   // å½“å‰æ‹–åŠ¨çš„æ¨¡å—
        let activeCircuitData = null;         // ä¿å­˜å½“å‰å›è·¯æ¸²æŸ“çš„æ•°æ®

        // V5æ–°å¢å˜é‡
        let topologyAnalysis = null;  // æ‹“æ‰‘åˆ†æç»“æœ
        let showWireLabelsEnabled = true;
        let showTerminalResistorsEnabled = true;
        let currentLayout = 'auto';
        let currentDisplay = 'all';

        // V6æ–°å¢å˜é‡
        let mergeConnectorsEnabled = false;  // æ’ä»¶åˆå¹¶åŠŸèƒ½
        let fixedPinSpacing = 25;  // å›ºå®šPINè„šé—´è·

        // ç¼“å­˜DOMå…ƒç´ 
        const domCache = {};

        // è·å–æ˜¾ç¤ºåˆ—
        function getDisplayHeaders() {
            if (!domCache.displayHeaders) {
                const displayHeaders = [...headers];
                const additionalColumns = ['æ˜¯å¦CANçº¿', 'CANç±»å‹', 'ä¿¡å·ç±»å‹', 'ç„Šç‚¹', 'åˆ†ç±»', 'å›è·¯ç±»å‹'];
                additionalColumns.forEach(col => {
                    if (!displayHeaders.includes(col)) {
                        displayHeaders.push(col);
                    }
                });
                domCache.displayHeaders = displayHeaders;
            }
            return domCache.displayHeaders;
        }

        // æ¸…é™¤ç¼“å­˜
        function clearCache() {
            domCache.displayHeaders = null;
        }

        // å®‰å…¨çš„DOMè·å–
        function $(id) {
            if (!domCache[id]) {
                domCache[id] = document.getElementById(id);
            }
            return domCache[id];
        }

        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFile(e.target.files[0]);
            }
        });

        // Inlineæ–‡ä»¶ä¸Šä¼ å¤„ç†
        const inlineUploadArea = document.getElementById('inlineUploadArea');
        const inlineFileInput = document.getElementById('inlineFileInput');

        inlineUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            inlineUploadArea.classList.add('dragover');
        });

        inlineUploadArea.addEventListener('dragleave', () => {
            inlineUploadArea.classList.remove('dragover');
        });

        inlineUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            inlineUploadArea.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleInlineFile(files[0]);
            }
        });

        inlineFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleInlineFile(e.target.files[0]);
            }
        });

        // å¤„ç†Inlineæ–‡ä»¶
        async function handleInlineFile(file) {
            if (isProcessing) {
                showMessage('æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...', 'error');
                return;
            }

            const validExtensions = ['.xlsx', '.xls'];
            const fileName = file.name.toLowerCase();
            const isValidFile = validExtensions.some(ext => fileName.endsWith(ext));

            if (!isValidFile) {
                showMessage('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œè¯·ä¸Šä¼  .xlsx æˆ– .xls æ–‡ä»¶');
                return;
            }

            isProcessing = true;
            const loading = $('loading');
            if (loading) loading.style.display = 'block';

            updateProgress(0);

            try {
                const data = await file.arrayBuffer();
                updateProgress(50);

                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                updateProgress(75);

                if (jsonData.length < 2) {
                    throw new Error('æ–‡ä»¶æ•°æ®ä¸è¶³ï¼Œè‡³å°‘éœ€è¦è¡¨å¤´å’Œä¸€è¡Œæ•°æ®');
                }

                const rows = jsonData.slice(1);
                inlinePairsMap.clear();

                rows.forEach(row => {
                    const inlineLeft = row[0] || '';
                    const inlineRight = row[1] || '';

                    if (inlineLeft && inlineRight) {
                        inlinePairsMap.set(inlineLeft, inlineRight);
                        inlinePairsMap.set(inlineRight, inlineLeft);
                    }
                });

                updateProgress(100);
                showMessage(`âœ… æˆåŠŸåŠ è½½ ${inlinePairsMap.size / 2} å¯¹inlineèŠ‚ç‚¹é…å¯¹`, 'success');
            } catch (error) {
                console.error('[Inlineæ–‡ä»¶å¤„ç†é”™è¯¯]', error);
                showMessage('âŒ Inlineæ–‡ä»¶è§£æå¤±è´¥: ' + error.message);
                updateProgress(0);
            } finally {
                if (loading) loading.style.display = 'none';
                isProcessing = false;
            }
        }

        function showMessage(message, type = 'error') {
            const errorEl = $('errorMessage');
            const successEl = $('successMessage');

            if (!errorEl || !successEl) return;

            errorEl.style.display = 'none';
            successEl.style.display = 'none';

            if (type === 'error') {
                errorEl.textContent = message;
                errorEl.style.display = 'block';
                console.error('[é”™è¯¯]', message);
            } else {
                successEl.textContent = message;
                successEl.style.display = 'block';
                debugLog('[æˆåŠŸ]', message);
            }

            setTimeout(() => {
                if (errorEl) errorEl.style.display = 'none';
                if (successEl) successEl.style.display = 'none';
            }, 5000);
        }

        function updateProgress(percent) {
            const progressContainer = $('progressContainer');
            const progressFill = $('progressFill');

            if (!progressContainer || !progressFill) return;

            progressContainer.style.display = 'block';
            progressFill.style.width = percent + '%';
            progressFill.textContent = Math.round(percent) + '%';

            if (percent >= 100) {
                setTimeout(() => {
                    if (progressContainer) progressContainer.style.display = 'none';
                }, 500);
            }
        }

        async function handleFile(file) {
            if (isProcessing) {
                showMessage('æ­£åœ¨å¤„ç†ä¸­ï¼Œè¯·ç¨å€™...', 'error');
                return;
            }

            const validExtensions = ['.xlsx', '.xls', '.csv'];
            const fileName = file.name.toLowerCase();
            const isValidFile = validExtensions.some(ext => fileName.endsWith(ext));

            if (!isValidFile) {
                showMessage('ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œè¯·ä¸Šä¼  .xlsx, .xls æˆ– .csv æ–‡ä»¶');
                return;
            }

            const maxSize = 50 * 1024 * 1024;
            if (file.size > maxSize) {
                showMessage('æ–‡ä»¶è¿‡å¤§ï¼Œè¯·ä¸Šä¼ å°äº50MBçš„æ–‡ä»¶');
                return;
            }

            isProcessing = true;
            const loading = $('loading');
            if (loading) loading.style.display = 'block';

            updateProgress(0);

            try {
                const data = await file.arrayBuffer();
                updateProgress(20);

                await new Promise(resolve => setTimeout(resolve, 50));

                const workbook = XLSX.read(data, { type: 'array' });
                const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                const jsonData = XLSX.utils.sheet_to_json(firstSheet, { header: 1 });
                updateProgress(40);

                if (jsonData.length < 2) {
                    throw new Error('æ–‡ä»¶æ•°æ®ä¸è¶³ï¼Œè‡³å°‘éœ€è¦è¡¨å¤´å’Œä¸€è¡Œæ•°æ®');
                }

                if (!jsonData[0] || jsonData[0].length === 0) {
                    throw new Error('æ–‡ä»¶æ ¼å¼é”™è¯¯ï¼šç¼ºå°‘è¡¨å¤´');
                }

                headers = jsonData[0];
                clearCache();

                const batchSize = 1000;
                const rows = jsonData.slice(1);
                originalData = [];

                for (let i = 0; i < rows.length; i += batchSize) {
                    const batch = rows.slice(i, i + batchSize);
                    const processedBatch = batch.map(row => {
                        const obj = {};
                        headers.forEach((header, index) => {
                            obj[header] = row[index] || '';
                        });
                        return obj;
                    }).filter(row => Object.values(row).some(val => val !== ''));

                    originalData.push(...processedBatch);
                    updateProgress(40 + (i / rows.length) * 20);

                    await new Promise(resolve => setTimeout(resolve, 0));
                }

                updateProgress(60);
                await processData();
                updateProgress(100);

                showMessage(`âœ… æˆåŠŸåŠ è½½ ${originalData.length} æ¡æ•°æ®ï¼Œè¯†åˆ«åˆ° ${filteredData.length} æ¡CANçº¿`, 'success');
            } catch (error) {
                console.error('[æ–‡ä»¶å¤„ç†é”™è¯¯]', error);
                showMessage('âŒ æ–‡ä»¶è§£æå¤±è´¥: ' + error.message);
                updateProgress(0);
            } finally {
                if (loading) loading.style.display = 'none';
                isProcessing = false;
            }
        }

        async function processData() {
            canTypes.clear();

            const batchSize = 500;
            const processedData = [];

            for (let i = 0; i < originalData.length; i += batchSize) {
                const batch = originalData.slice(i, i + batchSize);
                const processedBatch = batch.map(row => {
                    const newRow = { ...row };
                    const multicoreId = newRow['Multicore ID'] || '';
                    const wireId = newRow['Wire ID'] || '';
                    const isCanWire = multicoreId.toString().startsWith('T');

                    let canType = '';
                    let signalType = '';
                    let classification = '';

                    if (isCanWire && wireId.length >= 4) {
                        canType = wireId.substring(0, 2);
                        const signalCode = wireId.substring(2, 4).toUpperCase();

                        if (signalCode === 'CH') {
                            signalType = 'CAN High';
                            classification = `${canType} CAN High`;
                        } else if (signalCode === 'CL') {
                            signalType = 'CAN Low';
                            classification = `${canType} CAN Low`;
                        } else {
                            canType = '';
                            signalType = '';
                            classification = '';
                        }

                        if (canType && signalType) {
                            canTypes.add(canType);
                        }
                    }

                    const fromCode = newRow['From Code'] || '';
                    const fromPin = newRow['From Pin'] || '';
                    const toCode = newRow['To Code'] || '';
                    const toPin = newRow['To Pin'] || '';
                    let solderPoint = '';

                    const fromIsInline = inlinePairsMap.has(fromCode);
                    const toIsInline = inlinePairsMap.has(toCode);
                    const fromIsSolder = fromPin === 'X';
                    const toIsSolder = toPin === 'X';

                    const isBusCircuit = fromIsSolder || toIsSolder || fromIsInline || toIsInline;
                    const circuitType = isBusCircuit ? 'æ€»çº¿å›è·¯' : '';

                    if (fromPin === 'X') {
                        solderPoint = fromCode || '';
                    } else if (toPin === 'X') {
                        solderPoint = toCode || '';
                    }

                    newRow['æ˜¯å¦CANçº¿'] = (isCanWire && signalType !== '') ? 'æ˜¯' : 'å¦';
                    newRow['CANç±»å‹'] = canType || '';
                    newRow['ä¿¡å·ç±»å‹'] = signalType;
                    newRow['ç„Šç‚¹'] = solderPoint;
                    newRow['åˆ†ç±»'] = classification;
                    newRow['å›è·¯ç±»å‹'] = circuitType;

                    return newRow;
                }).filter(row => row['æ˜¯å¦CANçº¿'] === 'æ˜¯');

                processedData.push(...processedBatch);
                await new Promise(resolve => setTimeout(resolve, 0));
            }

            filteredData = processedData;

            filteredData.sort((a, b) => {
                const canTypeA = a['CANç±»å‹'] || '';
                const canTypeB = b['CANç±»å‹'] || '';
                const multicoreA = a['Multicore ID'] || '';
                const multicoreB = b['Multicore ID'] || '';

                const canTypeCompare = canTypeA.localeCompare(canTypeB);
                if (canTypeCompare !== 0) {
                    return canTypeCompare;
                }

                return multicoreA.localeCompare(multicoreB, undefined, { numeric: true });
            });

            updateStats();
            updateFilterOptions();
            displayResults();
        }

        function updateStats() {
            const totalWiresEl = $('totalWires');
            const canWiresEl = $('canWires');
            const canTypesEl = $('canTypes');
            const multicoreGroupsEl = $('multicoreGroups');

            if (totalWiresEl) totalWiresEl.textContent = originalData.length;
            if (canWiresEl) canWiresEl.textContent = filteredData.length;
            if (canTypesEl) canTypesEl.textContent = canTypes.size;

            const groups = new Set(filteredData.map(row => row['Multicore ID']));
            if (multicoreGroupsEl) multicoreGroupsEl.textContent = groups.size;

            const statsSection = $('statsSection');
            const filterSection = $('filterSection');
            if (statsSection) statsSection.style.display = 'block';
            if (filterSection) filterSection.style.display = 'block';
        }

        function updateFilterOptions() {
            const canTypeFilter = $('canTypeFilter');
            if (!canTypeFilter) return;

            canTypeFilter.innerHTML = '<option value="">å…¨éƒ¨</option>';

            Array.from(canTypes).sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = `${type} CAN`;
                canTypeFilter.appendChild(option);
            });
        }

        function displayResults() {
            const tableHeader = $('tableHeader');
            if (!tableHeader) return;

            const displayHeaders = getDisplayHeaders();
            tableHeader.innerHTML = displayHeaders.map(header =>
                `<th>${header}</th>`
            ).join('');

            totalPages = Math.ceil(filteredData.length / pageSize);
            if (currentPage > totalPages) currentPage = 1;

            renderTablePage();
            renderPagination();

            const resultsSection = $('resultsSection');
            if (resultsSection) {
                resultsSection.style.display = 'flex';
            }

            setTimeout(() => {
                const tableContainer = document.querySelector('.table-container');
                if (tableContainer) {
                    tableContainer.scrollTop = 0;
                    tableContainer.scrollLeft = 0;
                }
            }, 100);
        }

        function renderTablePage() {
            const tableBody = $('tableBody');
            if (!tableBody) return;

            const displayHeaders = getDisplayHeaders();
            const start = (currentPage - 1) * pageSize;
            const end = Math.min(start + pageSize, filteredData.length);
            const pageData = filteredData.slice(start, end);

            if (pageData.length === 0) {
                tableBody.innerHTML = '<tr><td colspan="' + displayHeaders.length + '" style="text-align:center; padding: 40px; color: #999;">æš‚æ— æ•°æ®</td></tr>';
                return;
            }

            const fragment = document.createDocumentFragment();
            const rowCount = pageData.length;
            const colCount = displayHeaders.length;

            for (let i = 0; i < rowCount; i++) {
                const row = pageData[i];
                const signalType = row['ä¿¡å·ç±»å‹'];

                const tr = document.createElement('tr');
                if (signalType === 'CAN High') {
                    tr.className = 'can-high';
                } else if (signalType === 'CAN Low') {
                    tr.className = 'can-low';
                }

                for (let j = 0; j < colCount; j++) {
                    const header = displayHeaders[j];
                    const td = document.createElement('td');

                    if (header === 'åˆ†ç±»') {
                        const value = row[header] || '';
                        if (value) {
                            const badgeClass = value.includes('High') ? 'badge-high' : 'badge-low';
                            const span = document.createElement('span');
                            span.className = `classification-badge ${badgeClass}`;
                            span.textContent = value;
                            td.appendChild(span);
                        }
                    } else if (header === 'å›è·¯ç±»å‹') {
                        const value = row[header] || '';
                        if (value) {
                            const badgeClass = value === 'æ€»çº¿å›è·¯' ? 'badge-high' : 'badge-low';
                            const span = document.createElement('span');
                            span.className = `classification-badge ${badgeClass}`;
                            span.textContent = value;
                            td.appendChild(span);
                        }
                    } else {
                        td.textContent = row[header] || '';
                    }

                    tr.appendChild(td);
                }

                fragment.appendChild(tr);
            }

            tableBody.innerHTML = '';
            tableBody.appendChild(fragment);
        }

        function renderPagination() {
            const pagination = $('pagination');
            if (!pagination) return;

            const startRecord = filteredData.length === 0 ? 0 : (currentPage - 1) * pageSize + 1;
            const endRecord = Math.min(currentPage * pageSize, filteredData.length);

            let html = `
                <div class="pagination-info">
                    æ˜¾ç¤º ${startRecord}-${endRecord} / å…± ${filteredData.length} æ¡è®°å½•
                </div>
                <button onclick="goToPage(1)" ${currentPage === 1 ? 'disabled' : ''}>é¦–é¡µ</button>
                <button onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>ä¸Šä¸€é¡µ</button>
            `;

            let startPage = Math.max(1, currentPage - 2);
            let endPage = Math.min(totalPages, startPage + 4);
            startPage = Math.max(1, endPage - 4);

            for (let i = startPage; i <= endPage; i++) {
                html += `<button onclick="goToPage(${i})" ${i === currentPage ? 'disabled' : ''}>${i}</button>`;
            }

            html += `
                <button onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>ä¸‹ä¸€é¡µ</button>
                <button onclick="goToPage(${totalPages})" ${currentPage === totalPages ? 'disabled' : ''}>æœ«é¡µ</button>
                <div class="page-size-selector">
                    <label for="pageSizeSelect">æ¯é¡µæ˜¾ç¤º:</label>
                    <select id="pageSizeSelect" onchange="changePageSize(this.value)">
                        <option value="50" ${pageSize === 50 ? 'selected' : ''}>50</option>
                        <option value="100" ${pageSize === 100 ? 'selected' : ''}>100</option>
                        <option value="200" ${pageSize === 200 ? 'selected' : ''}>200</option>
                        <option value="500" ${pageSize === 500 ? 'selected' : ''}>500</option>
                        <option value="1000" ${pageSize === 1000 ? 'selected' : ''}>1000</option>
                    </select>
                </div>
            `;

            pagination.innerHTML = html;
        }

        function goToPage(page) {
            if (page < 1 || page > totalPages) return;
            currentPage = page;
            renderTablePage();
            renderPagination();

            const tableContainer = document.querySelector('.table-container');
            if (tableContainer) {
                tableContainer.scrollTop = 0;
            }
        }

        function changePageSize(size) {
            pageSize = parseInt(size);
            currentPage = 1;
            displayResults();
        }

        function applyFilters() {
            const canTypeFilterEl = $('canTypeFilter');
            const signalFilterEl = $('signalFilter');

            if (!canTypeFilterEl || !signalFilterEl) return;

            const canTypeFilter = canTypeFilterEl.value;
            const signalFilter = signalFilterEl.value;

            filteredData = originalData.filter(row => {
                if (row['æ˜¯å¦CANçº¿'] !== 'æ˜¯') return false;
                if (canTypeFilter && row['CANç±»å‹'] !== canTypeFilter) return false;
                if (signalFilter && row['ä¿¡å·ç±»å‹'] !== signalFilter) return false;
                return true;
            });

            filteredData.sort((a, b) => {
                const canTypeA = a['CANç±»å‹'] || '';
                const canTypeB = b['CANç±»å‹'] || '';
                const multicoreA = a['Multicore ID'] || '';
                const multicoreB = b['Multicore ID'] || '';

                const canTypeCompare = canTypeA.localeCompare(canTypeB);
                if (canTypeCompare !== 0) {
                    return canTypeCompare;
                }

                return multicoreA.localeCompare(multicoreB, undefined, { numeric: true });
            });

            currentPage = 1;
            displayResults();
        }

        function resetFilters() {
            const canTypeFilterEl = $('canTypeFilter');
            const signalFilterEl = $('signalFilter');

            if (canTypeFilterEl) canTypeFilterEl.value = '';
            if (signalFilterEl) signalFilterEl.value = '';

            applyFilters();
        }

        async function exportToExcel() {
            if (filteredData.length === 0) {
                showMessage('âš ï¸ æ²¡æœ‰æ•°æ®å¯å¯¼å‡º');
                return;
            }

            if (typeof ExcelJS === 'undefined' || typeof saveAs === 'undefined') {
                showMessage('âŒ æ‰€éœ€åº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
                return;
            }

            try {
                const displayHeaders = getDisplayHeaders();
                const workbook = new ExcelJS.Workbook();
                const worksheet = workbook.addWorksheet('CANçº¿æŸåˆ†æ');

                worksheet.columns = displayHeaders.map(header => ({
                    header: header,
                    key: header,
                    width: header === 'åˆ†ç±»' || header === 'ä¿¡å·ç±»å‹' ? 20 : 15
                }));

                const headerStyle = {
                    font: { bold: true, size: 12, color: { argb: 'FF000000' } },
                    fill: {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFFF667EEA' }
                    },
                    alignment: { horizontal: 'center', vertical: 'middle' },
                    border: {
                        top: { style: 'thin' },
                        left: { style: 'thin' },
                        bottom: { style: 'thin' },
                        right: { style: 'thin' }
                    }
                };

                const canHighStyle = {
                    font: { bold: true, size: 11, color: { argb: 'FF667EEA' } },
                    fill: {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFDCE6FF' }
                    },
                    alignment: { horizontal: 'center', vertical: 'middle' },
                    border: {
                        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                    }
                };

                const canLowStyle = {
                    font: { bold: true, size: 11, color: { argb: 'FF764BA2' } },
                    fill: {
                        type: 'pattern',
                        pattern: 'solid',
                        fgColor: { argb: 'FFE6DCEF' }
                    },
                    alignment: { horizontal: 'center', vertical: 'middle' },
                    border: {
                        top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                        right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                    }
                };

                worksheet.getRow(1).eachCell((cell) => {
                    cell.style = headerStyle;
                });

                filteredData.forEach((row, rowIndex) => {
                    const signalType = row['ä¿¡å·ç±»å‹'] || '';
                    const rowNumber = rowIndex + 2;

                    displayHeaders.forEach((header, colIndex) => {
                        const value = row[header] || '';
                        const cell = worksheet.getCell(rowNumber, colIndex + 1);
                        cell.value = value;

                        if (signalType === 'CAN High') {
                            cell.style = canHighStyle;
                        } else if (signalType === 'CAN Low') {
                            cell.style = canLowStyle;
                        } else {
                            cell.style = {
                                font: { size: 11 },
                                alignment: { horizontal: 'left', vertical: 'middle' },
                                border: {
                                    top: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                                    left: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                                    bottom: { style: 'thin', color: { argb: 'FFCCCCCC' } },
                                    right: { style: 'thin', color: { argb: 'FFCCCCCC' } }
                                }
                            };
                        }
                    });
                });

                worksheet.views = [
                    { state: 'frozen', xSplit: 0, ySplit: 1 }
                ];

                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], {
                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                });
                const now = new Date();
                const dateStr = now.toISOString().slice(0, 10);
                const timeStr = now.toTimeString().slice(0, 8).replace(/:/g, '-');
                const fileName = `CANçº¿æŸåˆ†æ_V5_${dateStr}_${timeStr}.xlsx`;

                saveAs(blob, fileName);
                showMessage(`âœ… æˆåŠŸå¯¼å‡º ${filteredData.length} æ¡æ•°æ®`, 'success');
            } catch (error) {
                console.error('[å¯¼å‡ºå¤±è´¥]', error);
                showMessage('âŒ å¯¼å‡ºå¤±è´¥: ' + error.message);
            }
        }

        async function copyTableToClipboard() {
            if (filteredData.length === 0) {
                showMessage('âš ï¸ æ²¡æœ‰æ•°æ®å¯å¤åˆ¶');
                return;
            }

            try {
                const displayHeaders = getDisplayHeaders();
                let html = '<table border="1" style="border-collapse: collapse; font-size: 12px;">';

                html += '<thead><tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #000000; font-weight: bold;">';
                displayHeaders.forEach(header => {
                    html += `<th style="padding: 10px 8px; text-align: left; border: 1px solid #ddd; white-space: nowrap; color: #000000;">${header}</th>`;
                });
                html += '</tr></thead>';

                html += '<tbody>';
                filteredData.forEach(row => {
                    const signalType = row['ä¿¡å·ç±»å‹'] || '';
                    let rowStyle = '';

                    if (signalType === 'CAN High') {
                        rowStyle = 'background: #dce6ff; color: #667eea; font-weight: bold;';
                    } else if (signalType === 'CAN Low') {
                        rowStyle = 'background: #e6dcef; color: #764ba2; font-weight: bold;';
                    }

                    html += `<tr style="${rowStyle}">`;
                    displayHeaders.forEach(header => {
                        const value = row[header] || '';
                        html += `<td style="padding: 8px; border: 1px solid #ddd; white-space: nowrap;">${value}</td>`;
                    });
                    html += '</tr>';
                });
                html += '</tbody></table>';

                const blob = new Blob([html], { type: 'text/html' });
                const clipboardItem = new ClipboardItem({
                    'text/html': blob,
                    'text/plain': new Blob([filteredData.map(row =>
                        displayHeaders.map(h => row[h] || '').join('\t')
                    ).join('\n')], { type: 'text/plain' })
                });

                await navigator.clipboard.write([clipboardItem]);
                showMessage(`âœ… å·²å¤åˆ¶ ${filteredData.length} æ¡æ•°æ®åˆ°å‰ªè´´æ¿`, 'success');
            } catch (error) {
                console.error('[å¤åˆ¶å¤±è´¥]', error);
                showMessage('âŒ å¤åˆ¶å¤±è´¥: ' + error.message);
            }
        }

        // ========== å…¨å±åŠŸèƒ½ ==========
        function toggleFullscreen() {
            const topologySection = $('topologySection');
            const fullscreenControls = $('fullscreenControls');
            const fullscreenBtn = $('fullscreenBtn');

            if (!isFullscreen) {
                if (topologySection) topologySection.classList.add('fullscreen');
                if (fullscreenControls) fullscreenControls.style.display = 'flex';
                if (fullscreenBtn) fullscreenBtn.textContent = 'â›¶ é€€å‡ºå…¨å±';
                isFullscreen = true;

                setTimeout(() => {
                    if (d3Svg && topologySection) {
                        const width = topologySection.clientWidth - 540;
                        const height = topologySection.clientHeight - 60;
                        d3Svg.attr('width', width).attr('height', height);
                    }
                    requestTopologyRender();
                }, 100);
            } else {
                if (topologySection) topologySection.classList.remove('fullscreen');
                if (fullscreenControls) fullscreenControls.style.display = 'none';
                if (fullscreenBtn) fullscreenBtn.textContent = 'â›¶ å…¨å±';
                isFullscreen = false;

                setTimeout(() => {
                    if (d3Svg) {
                        const container = $('topologyCanvas').parentElement;
                        if (container) {
                            const width = container.clientWidth;
                            const height = container.clientHeight;
                            d3Svg.attr('width', width).attr('height', height);
                        }
                    }
                    requestTopologyRender();
                }, 100);
            }
        }

        // ========== æ‹“æ‰‘å›¾ç›¸å…³åŠŸèƒ½ ==========
        let topologyCanTypes = [];
        let currentCanType = null;
        let cachedLayout = null;
        let renderRequested = false;
        let topologyInitialized = false;

        // D3.js æ‹“æ‰‘å›¾å˜é‡
        let d3Svg = null;
        let d3Zoom = null;
        let d3G = null;

        // æ˜¾ç¤ºæ‹“æ‰‘å›¾ç•Œé¢
        function showTopology() {
            if (filteredData.length === 0) {
                showMessage('âš ï¸ æ²¡æœ‰æ•°æ®å¯æ˜¾ç¤º');
                return;
            }

            const resultsSection = $('resultsSection');
            const topologySection = $('topologySection');

            if (resultsSection) resultsSection.style.display = 'none';
            if (topologySection) topologySection.style.display = 'flex';

            setTimeout(() => {
                initTopologyData();
                renderTopologyList();

                if (!topologyInitialized) {
                    initCanvas();
                    topologyInitialized = true;
                }

                const svgElement = document.getElementById('topologyCanvas');
                const container = svgElement.parentElement;
                const width = container.clientWidth || 1000;
                const height = container.clientHeight || 1000;

                if (d3Svg) {
                    d3Svg.attr('width', width).attr('height', height);
                }

                cachedLayout = null;
                requestTopologyRender();
            }, 50);
        }

        // å…³é—­æ‹“æ‰‘å›¾
        function closeTopology() {
            const resultsSection = $('resultsSection');
            const topologySection = $('topologySection');

            if (resultsSection) resultsSection.style.display = 'flex';
            if (topologySection) topologySection.style.display = 'none';

            cachedLayout = null;
        }

        // åˆå§‹åŒ–æ‹“æ‰‘æ•°æ®
        function initTopologyData() {
            debugLog('[initTopologyData] å¼€å§‹åˆå§‹åŒ–æ‹“æ‰‘æ•°æ®');

            topologyCanTypes = [];

            const groups = {};
            filteredData.forEach(row => {
                const canType = row['CANç±»å‹'];
                if (!canType) return;

                if (!groups[canType]) {
                    groups[canType] = [];
                }
                groups[canType].push(row);
            });

            Object.keys(groups).sort().forEach(canType => {
                const wires = groups[canType];
                const connectors = new Map();
                const inlineNodes = new Map();
                const solders = new Map();
                const circuits = [];

                wires.forEach(wire => {
                    const wireId = wire['Wire ID'] || '';
                    const signalType = wire['ä¿¡å·ç±»å‹'];
                    const multicoreId = wire['Multicore ID'] || '';
                    const fromCode = wire['From Code'] || '';
                    const fromPin = wire['From Pin'] || '';
                    const toCode = wire['To Code'] || '';
                    const toPin = wire['To Pin'] || '';

                    const fromIsInline = inlinePairsMap.has(fromCode);
                    const toIsInline = inlinePairsMap.has(toCode);
                    const fromIsSolder = fromPin === 'X';
                    const toIsSolder = toPin === 'X';
                    const fromIsConnector = !fromIsInline && !fromIsSolder && fromCode;
                    const toIsConnector = !toIsInline && !toIsSolder && toCode;

                    if (fromIsInline) {
                        if (!inlineNodes.has(fromCode)) {
                            inlineNodes.set(fromCode, {
                                pair: inlinePairsMap.get(fromCode),
                                pins: new Map(),
                                position: null
                            });
                        }
                        if (!inlineNodes.get(fromCode).pins.has(signalType)) {
                            inlineNodes.get(fromCode).pins.set(signalType, []);
                        }
                        if (!inlineNodes.get(fromCode).pins.get(signalType).includes(fromPin)) {
                            inlineNodes.get(fromCode).pins.get(signalType).push(fromPin);
                        }
                    } else if (fromIsConnector) {
                        if (!connectors.has(fromCode)) {
                            connectors.set(fromCode, {
                                pins: new Map(),
                                position: null,
                                isInline: false
                            });
                        }
                        if (!connectors.get(fromCode).pins.has(signalType)) {
                            connectors.get(fromCode).pins.set(signalType, []);
                        }
                        if (!connectors.get(fromCode).pins.get(signalType).includes(fromPin)) {
                            connectors.get(fromCode).pins.get(signalType).push(fromPin);
                        }
                    }

                    if (toIsInline) {
                        if (!inlineNodes.has(toCode)) {
                            inlineNodes.set(toCode, {
                                pair: inlinePairsMap.get(toCode),
                                pins: new Map(),
                                position: null
                            });
                        }
                        if (!inlineNodes.get(toCode).pins.has(signalType)) {
                            inlineNodes.get(toCode).pins.set(signalType, []);
                        }
                        if (!inlineNodes.get(toCode).pins.get(signalType).includes(toPin)) {
                            inlineNodes.get(toCode).pins.get(signalType).push(toPin);
                        }
                    } else if (toIsConnector) {
                        if (!connectors.has(toCode)) {
                            connectors.set(toCode, {
                                pins: new Map(),
                                position: null,
                                isInline: false
                            });
                        }
                        if (!connectors.get(toCode).pins.has(signalType)) {
                            connectors.get(toCode).pins.set(signalType, []);
                        }
                        if (!connectors.get(toCode).pins.get(signalType).includes(toPin)) {
                            connectors.get(toCode).pins.get(signalType).push(toPin);
                        }
                    }

                    if (fromIsSolder && fromCode) {
                        if (!solders.has(fromCode)) {
                            solders.set(fromCode, { position: null, connections: [] });
                        }
                    }
                    if (toIsSolder && toCode) {
                        if (!solders.has(toCode)) {
                            solders.set(toCode, { position: null, connections: [] });
                        }
                    }

                    let circuitType = 'æ€»çº¿å›è·¯';

                    circuits.push({
                        wireId: wireId,
                        fromCode: fromCode,
                        fromPin: fromPin,
                        toCode: toCode,
                        toPin: toPin,
                        signalType: signalType,
                        multicoreId: multicoreId,
                        circuitType: circuitType,
                        isFromSolder: fromIsSolder,
                        isToSolder: toIsSolder,
                        isFromInline: fromIsInline,
                        isToInline: toIsInline,
                        isFromConnector: fromIsConnector,
                        isToConnector: toIsConnector
                    });
                });

                topologyCanTypes.push({
                    canType: canType,
                    connectors: connectors,
                    inlineNodes: inlineNodes,
                    solders: solders,
                    circuits: circuits,
                    wireCount: wires.length
                });

                debugLog(`[initTopologyData] ${canType} CAN - æ’ä»¶:${connectors.size}, ç„Šç‚¹:${solders.size}, Inline:${inlineNodes.size}, å›è·¯:${circuits.length}`);
            });

            if (topologyCanTypes.length > 0 && !currentCanType) {
                currentCanType = topologyCanTypes[0].canType;
            }
        }

        // æ¸²æŸ“æ‹“æ‰‘åˆ—è¡¨
        function renderTopologyList() {
            const listEl = $('topologyList');
            if (!listEl) return;

            listEl.innerHTML = topologyCanTypes.map(group => {
                const isActive = currentCanType === group.canType;
                const connectorCount = group.connectors ? group.connectors.size : 0;
                const solderCount = group.solders ? group.solders.size : 0;
                const inlineCount = group.inlineNodes ? group.inlineNodes.size / 2 : 0;
                const circuitCount = group.circuits ? group.circuits.length : 0;

                return `
                    <div class="topology-item ${isActive ? 'active' : ''}" onclick="selectCanType('${group.canType}')">
                        <div class="topology-item-name">${group.canType} CAN</div>
                        <div class="topology-item-info">
                            ${group.wireCount} æ¡çº¿ | ${connectorCount} æ’ä»¶ | ${inlineCount} Inline | ${solderCount} ç„Šç‚¹
                        </div>
                        <div class="topology-item-info">
                            ${circuitCount} ä¸ªå›è·¯è¿æ¥
                        </div>
                    </div>
                `;
            }).join('');

            renderCircuitDetails();
            renderWireList();
            updateTopologyAnalysis();
        }

        // V5æ–°å¢ï¼šæ‹“æ‰‘åˆ†æ
        function updateTopologyAnalysis() {
            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup) return;

            const connectors = Array.from(canTypeGroup.connectors.keys());
            const solders = Array.from(canTypeGroup.solders.keys());
            const inlines = Array.from(canTypeGroup.inlineNodes.keys());
            const circuits = canTypeGroup.circuits;

            // ç»Ÿè®¡èŠ‚ç‚¹æ•°é‡
            const ecuCount = connectors.length;
            const spliceCount = solders.length;
            const inlineCount = inlines.length / 2;
            const wireCount = circuits.length;
            const totalNodes = ecuCount + spliceCount + inlineCount;

            // æ›´æ–°UI
            const topologyTypeEl = $('topologyType');
            const totalNodesEl = $('totalNodes');
            const ecuCountEl = $('ecuCount');
            const spliceCountEl = $('spliceCount');
            const inlineCountEl = $('inlineCount');
            const wireCountEl = $('wireCount');
            const complexityEl = $('complexity');

            if (topologyTypeEl) {
                // åˆ†ææ‹“æ‰‘ç±»å‹
                const topologyType = analyzeTopologyType(canTypeGroup);
                topologyTypeEl.innerHTML = `<span class="topology-type-badge topology-type-${topologyType.type}">${topologyType.label}</span>`;
            }

            if (totalNodesEl) totalNodesEl.textContent = totalNodes;
            if (ecuCountEl) ecuCountEl.textContent = ecuCount;
            if (spliceCountEl) spliceCountEl.textContent = spliceCount;
            if (inlineCountEl) inlineCountEl.textContent = inlineCount;
            if (wireCountEl) wireCountEl.textContent = wireCount;

            if (complexityEl) {
                // è®¡ç®—å¤æ‚åº¦è¯„åˆ†
                const complexity = calculateComplexity(canTypeGroup);
                let complexityLabel = 'ä½';
                if (complexity > 0.7) complexityLabel = 'é«˜';
                else if (complexity > 0.4) complexityLabel = 'ä¸­';
                complexityEl.textContent = `${complexityLabel} (${(complexity * 100).toFixed(0)}%)`;
            }

            // ç”Ÿæˆè¯Šæ–­è­¦å‘Š
            updateWarnings(canTypeGroup);
        }

        // åˆ†ææ‹“æ‰‘ç±»å‹
        function analyzeTopologyType(canTypeGroup) {
            const circuits = canTypeGroup.circuits;
            const solders = canTypeGroup.solders;
            const inlines = canTypeGroup.inlineNodes;
            const connectors = canTypeGroup.connectors;

            // æ£€æŸ¥æ˜¯å¦æœ‰ç„Šç‚¹æˆ–InlineèŠ‚ç‚¹
            const hasSolders = solders.size > 0;
            const hasInlines = inlines.size > 0;
            const hasMultipleConnectors = connectors.size > 2;

            // æ£€æŸ¥å›è·¯ç±»å‹
            const solderToSolder = circuits.filter(c =>
                (c.isFromSolder && c.isToSolder) ||
                (c.isFromInline && c.isToInline) ||
                (c.isFromSolder && c.isToInline) ||
                (c.isFromInline && c.isToSolder)
            ).length;

            const connectorToBus = circuits.filter(c =>
                (c.isFromConnector && (c.isToSolder || c.isToInline)) ||
                (c.isToConnector && (c.isFromSolder || c.isFromInline))
            ).length;

            const connectorToConnector = circuits.filter(c =>
                c.isFromConnector && c.isToConnector
            ).length;

            // åˆ¤æ–­æ‹“æ‰‘ç±»å‹
            if (solderToSolder > 0 && hasMultipleConnectors) {
                return { type: 'mixed', label: 'æ··åˆæ‹“æ‰‘' };
            } else if (solderToSolder > 0 || hasInlines) {
                return { type: 'bus', label: 'æ€»çº¿æ‹“æ‰‘' };
            } else if (connectorToConnector > 0) {
                return { type: 'series', label: 'ä¸²è”æ‹“æ‰‘' };
            } else if (connectorToBus > 0 && connectors.size > 1) {
                return { type: 'bus', label: 'æ€»çº¿æ‹“æ‰‘' };
            }

            return { type: 'bus', label: 'æ€»çº¿æ‹“æ‰‘' };
        }

        // è®¡ç®—å¤æ‚åº¦
        function calculateComplexity(canTypeGroup) {
            const circuits = canTypeGroup.circuits;
            const connectors = canTypeGroup.connectors;
            const solders = canTypeGroup.solders;
            const inlines = canTypeGroup.inlineNodes;

            // å¤æ‚åº¦å› ç´ ï¼š
            // 1. èŠ‚ç‚¹æ•°é‡
            const nodeCount = connectors.size + solders.size + inlines.size;
            // 2. å›è·¯æ•°é‡
            const circuitCount = circuits.length;
            // 3. InlineèŠ‚ç‚¹æ¯”ä¾‹
            const inlineRatio = inlines.size / (nodeCount || 1);

            // ç»¼åˆè¯„åˆ†
            const score = Math.min(1,
                (nodeCount / 50) * 0.3 +
                (circuitCount / 100) * 0.4 +
                inlineRatio * 0.3
            );

            return score;
        }

        // æ›´æ–°è¯Šæ–­è­¦å‘Š
        function updateWarnings(canTypeGroup) {
            const warningsList = $('warningsList');
            if (!warningsList) return;

            const warnings = [];
            const circuits = canTypeGroup.circuits;
            const connectors = canTypeGroup.connectors;
            const solders = canTypeGroup.solders;

            // æ£€æŸ¥ç»ˆç«¯ç”µé˜»
            const hasTerminalResistor = Array.from(connectors.keys()).some(code => {
                return connectors.get(code).pins.has('CAN High') &&
                       connectors.get(code).pins.has('CAN Low');
            });

            if (!hasTerminalResistor && connectors.size > 0) {
                warnings.push({
                    type: 'warning',
                    message: 'æœªæ£€æµ‹åˆ°æ˜ç¡®çš„ç»ˆç«¯ç”µé˜»è¿æ¥'
                });
            }

            // æ£€æŸ¥ç„Šç‚¹è¿æ¥æ•°è¿‡å¤šçš„åˆ†æ”¯
            solders.forEach((data, code) => {
                const connectedCircuits = circuits.filter(c =>
                    (c.isFromSolder && c.fromCode === code) ||
                    (c.isToSolder && c.toCode === code)
                );

                if (connectedCircuits.length > 4) {
                    warnings.push({
                        type: 'warning',
                        message: `ç„Šç‚¹ ${code} æœ‰ ${connectedCircuits.length} ä¸ªè¿æ¥ï¼Œåˆ†æ”¯è¿‡å¤š`
                    });
                }
            });

            // æ£€æŸ¥CAN Highå’ŒCAN Lowæ˜¯å¦å¹³è¡¡
            const highCount = circuits.filter(c => c.signalType === 'CAN High').length;
            const lowCount = circuits.filter(c => c.signalType === 'CAN Low').length;

            if (Math.abs(highCount - lowCount) > highCount * 0.2) {
                warnings.push({
                    type: 'warning',
                    message: `CAN High/Lowä¿¡å·ä¸å¹³è¡¡: H=${highCount}, L=${lowCount}`
                });
            }

            // æ£€æŸ¥å­¤ç«‹èŠ‚ç‚¹
            const connectedNodes = new Set();
            circuits.forEach(c => {
                if (c.isFromConnector) connectedNodes.add(c.fromCode);
                if (c.isToConnector) connectedNodes.add(c.toCode);
                if (c.isFromSolder) connectedNodes.add(c.fromCode);
                if (c.isToSolder) connectedNodes.add(c.toCode);
            });

            connectors.forEach((_, code) => {
                if (!connectedNodes.has(code)) {
                    warnings.push({
                        type: 'critical',
                        message: `ECU ${code} æœªè¿æ¥åˆ°ä»»ä½•ç„Šç‚¹æˆ–Inline`
                    });
                }
            });

            // æ¸²æŸ“è­¦å‘Šåˆ—è¡¨
            if (warnings.length === 0) {
                warningsList.innerHTML = '<div style="color: #28a745; font-size: 11px;">âœ“ æ‹“æ‰‘ç»“æ„æ­£å¸¸</div>';
            } else {
                warningsList.innerHTML = warnings.map(w =>
                    `<div class="warning-item ${w.type}">${w.message}</div>`
                ).join('');
            }
        }

        // æ¸²æŸ“å›è·¯è¯¦æƒ…
        function renderCircuitDetails() {
            const detailEl = $('circuitDetailList');
            if (!detailEl) return;

            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup || !canTypeGroup.circuits) {
                detailEl.innerHTML = '<div style="color: #999;">æš‚æ— å›è·¯æ•°æ®</div>';
                return;
            }

            const sortedCircuits = [...canTypeGroup.circuits].sort((a, b) => {
                if (a.signalType !== b.signalType) {
                    return a.signalType === 'CAN High' ? -1 : 1;
                }
                return a.wireId.localeCompare(b.wireId, undefined, { numeric: true });
            });

            detailEl.innerHTML = sortedCircuits.map((circuit, index) => {
                const color = circuit.signalType === 'CAN High' ? '#667eea' : '#764ba2';
                const fromEnd = circuit.isFromConnector ? `${circuit.fromCode}(${circuit.fromPin})` :
                               circuit.isFromInline ? `${circuit.fromCode}(Inline)` :
                               circuit.isFromSolder ? `${circuit.fromCode}(ç„Šç‚¹)` : circuit.fromCode;
                const toEnd = circuit.isToConnector ? `${circuit.toCode}(${circuit.toPin})` :
                             circuit.isToInline ? `${circuit.toCode}(Inline)` :
                             circuit.isToSolder ? `${circuit.toCode}(ç„Šç‚¹)` : circuit.toCode;

                return `
                    <div style="padding: 6px; margin-bottom: 4px; background: #f8f9fa; border-left: 3px solid ${color}; border-radius: 3px;">
                        <div style="font-weight: bold; color: ${color}; margin-bottom: 3px;">
                            ${circuit.wireId} [${circuit.signalType === 'CAN High' ? 'CH' : 'CL'}]
                        </div>
                        <div style="color: #555;">
                            ${fromEnd} â†’ ${toEnd}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // æ¸²æŸ“WireList
        function renderWireList() {
            const container = $('wirelistContainer');
            const countEl = $('wirelistCount');
            const searchInput = $('wirelistSearch');
            const canTypeEl = $('wirelistCanType');

            if (!container || !countEl) return;

            if (canTypeEl) {
                canTypeEl.textContent = currentCanType ? `å½“å‰: ${currentCanType} CAN` : 'å½“å‰: -';
            }

            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup || !canTypeGroup.circuits) {
                container.innerHTML = '<div style="color: #999; padding: 10px;">æš‚æ— å›è·¯æ•°æ®</div>';
                countEl.textContent = '0 æ¡å›è·¯';
                return;
            }

            const searchTerm = searchInput ? searchInput.value.toLowerCase() : '';

            let circuits = [...canTypeGroup.circuits];

            // æ ¹æ®æ˜¾ç¤ºè®¾ç½®è¿‡æ»¤
            if (currentDisplay === 'high') {
                circuits = circuits.filter(c => c.signalType === 'CAN High');
            } else if (currentDisplay === 'low') {
                circuits = circuits.filter(c => c.signalType === 'CAN Low');
            }

            if (searchTerm) {
                circuits = circuits.filter(c =>
                    c.wireId.toLowerCase().includes(searchTerm) ||
                    c.fromCode.toLowerCase().includes(searchTerm) ||
                    c.toCode.toLowerCase().includes(searchTerm)
                );
            }

            circuits.sort((a, b) => {
                if (a.signalType !== b.signalType) {
                    return a.signalType === 'CAN High' ? -1 : 1;
                }
                return a.wireId.localeCompare(b.wireId, undefined, { numeric: true });
            });

            countEl.textContent = `${circuits.length} æ¡å›è·¯`;

            container.innerHTML = circuits.map((circuit, index) => {
                const signalType = circuit.signalType === 'CAN High' ? 'CH' : 'CL';
                const signalClass = circuit.signalType === 'CAN High' ? 'ch' : 'cl';

                const fromEnd = circuit.isFromConnector ? `${circuit.fromCode}(${circuit.fromPin})` :
                               circuit.isFromInline ? circuit.fromCode :
                               circuit.isFromSolder ? circuit.fromCode : circuit.fromCode;
                const toEnd = circuit.isToConnector ? `${circuit.toCode}(${circuit.toPin})` :
                             circuit.isToInline ? circuit.toCode :
                             circuit.isToSolder ? circuit.toCode : circuit.toCode;

                return `
                    <div class="wirelist-item" data-wireid="${circuit.wireId}" onclick="focusWire('${circuit.wireId}')">
                        <div class="wire-id">
                            ${circuit.wireId}
                            <span class="wire-signal ${signalClass}">${signalType}</span>
                        </div>
                        <div class="wire-route" title="${fromEnd} â†’ ${toEnd}">
                            ${fromEnd} â†’ ${toEnd}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // èšç„¦åˆ°æŒ‡å®šå›è·¯
        let currentFocusedWireId = null;

        function focusWire(wireId) {
            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup) return;

            const circuit = canTypeGroup.circuits.find(c => c.wireId === wireId);
            if (!circuit) return;

            currentFocusedWireId = wireId;

            document.querySelectorAll('.wirelist-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.wireid === wireId) {
                    item.classList.add('active');
                    item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            });

            // æ ¹æ®å½“å‰è§†å›¾ç±»å‹è¿›è¡Œé«˜äº®/å±…ä¸­
            if (currentTopologyView === 'circuit') {
                focusWireOnCircuit(circuit);
            } else {
                highlightWireInTopology(circuit);
            }
        }

        // åœ¨å›è·¯è¿æ¥è§†å›¾ä¸­èšç„¦å¹¶å±…ä¸­æ˜¾ç¤ºå¯¼çº¿
        function focusWireOnCircuit(circuit) {
            // æ¸…é™¤ä¹‹å‰çš„å¯¼çº¿é«˜äº®
            clearCircuitHighlights();

            // æ‰¾åˆ°å¹¶é«˜äº®å¯¼çº¿
            if (activeCircuitData && activeCircuitData.wires) {
                const wire = activeCircuitData.wires.find(w => w.wireId === circuit.wireId);
                if (wire) {
                    // é«˜äº®å¯¼çº¿
                    if (wire.wireElement) {
                        wire.wireElement
                            .attr('stroke-width', 4)
                            .attr('opacity', 1);
                    }
                    if (wire.labelElement) {
                        wire.labelElement
                            .attr('font-weight', 'bold')
                            .attr('font-size', '12px');
                    }

                    // è®¡ç®—å¯¼çº¿çš„ä¸­å¿ƒä½ç½®
                    const midX = (wire.fromX + wire.toX) / 2;
                    const midY = (wire.fromY + wire.toY) / 2;

                    // ä½¿ç”¨d3.zoomè¿›è¡Œå±…ä¸­
                    if (d3Svg && d3Zoom) {
                        const svgWidth = parseInt(d3Svg.attr('width')) || 1000;
                        const svgHeight = parseInt(d3Svg.attr('height')) || 1000;

                        // è®¡ç®—éœ€è¦å¹³ç§»çš„è·ç¦»ï¼Œä½¿å¯¼çº¿ä¸­å¿ƒä½äºè§†å›¾ä¸­å¿ƒ
                        const translateX = svgWidth / 2 - midX;
                        const translateY = svgHeight / 2 - midY;

                        // åº”ç”¨å˜æ¢
                        d3Svg.transition()
                            .duration(500)
                            .call(d3Zoom.transform, d3.zoomIdentity.translate(translateX, translateY).scale(1));
                    }

                    debugLog('[å›è·¯å±…ä¸­] å¯¼çº¿:', circuit.wireId, 'ä¸­å¿ƒ:', midX, midY);
                }
            }
        }

        // æ¸…é™¤å›è·¯è§†å›¾ä¸­çš„å¯¼çº¿é«˜äº®
        function clearCircuitHighlights() {
            if (activeCircuitData && activeCircuitData.wires) {
                activeCircuitData.wires.forEach(wire => {
                    if (wire.wireElement) {
                        wire.wireElement
                            .attr('stroke-width', 1.5)
                            .attr('opacity', 0.7);
                    }
                    if (wire.labelElement) {
                        wire.labelElement
                            .attr('font-weight', 'normal')
                            .attr('font-size', '9px');
                    }
                });
            }
        }

        function highlightWireInTopology(circuit) {
            const layout = cachedLayout;
            if (!layout) return;

            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup) return;

            const { wires } = prepareTopologyData(layout, canTypeGroup);
            const targetWire = wires.find(w => w.wireId === circuit.wireId);

            if (targetWire) {
                focusWireOnTopology(targetWire);
            }
        }

        // é€‰æ‹©CANç±»å‹
        function selectCanType(canType) {
            currentCanType = canType;
            renderTopologyList();
            cachedLayout = null;
            requestTopologyRender();
            renderCircuitDetails();
            renderWireList();
            clearHighlights();
        }

        // æ£€æŸ¥D3.jsæ˜¯å¦å·²åŠ è½½
        function checkD3Loaded() {
            if (typeof d3 === 'undefined') {
                console.error('D3.jsæœªåŠ è½½');
                showMessage('âŒ D3.jsåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
                return false;
            }
            return true;
        }

        // ä½¿ç”¨D3.jsåˆå§‹åŒ–SVG
        function initCanvas() {
            if (!checkD3Loaded()) return;

            const svgElement = document.getElementById('topologyCanvas');
            if (!svgElement) {
                console.error('SVGå…ƒç´ æœªæ‰¾åˆ°');
                return;
            }

            const container = svgElement.parentElement;
            const width = container.clientWidth || 1000;
            const height = container.clientHeight || 1000;

            d3.select(svgElement).selectAll('*').remove();

            d3Svg = d3.select(svgElement)
                .attr('width', width)
                .attr('height', height)
                .style('background', '#ffffff')
                .style('cursor', 'move');

            d3Zoom = d3.zoom()
                .scaleExtent([0.3, 3])
                .filter(event => {
                    return event.button === 1 || event.type === 'wheel';
                })
                .on('zoom', (event) => {
                    if (d3G) {
                        d3G.attr('transform', event.transform);
                    }
                });

            d3Svg.call(d3Zoom);

            d3G = d3Svg.append('g');

            d3Svg.on('mousedown', function(event) {
                if (event.button === 1) {
                    event.preventDefault();
                    d3Svg.style('cursor', 'grabbing');
                }
            });

            d3Svg.on('mouseup', function(event) {
                if (event.button === 1) {
                    d3Svg.style('cursor', 'move');
                }
            });

            window.addEventListener('resize', () => {
                // å¦‚æœæ­£åœ¨æ‹–åŠ¨æ¨¡å—ï¼Œä¸è§¦å‘é‡æ–°æ¸²æŸ“
                if (activeCircuitDragModule) {
                    console.log('[resize] æ‹–åŠ¨ä¸­ï¼Œè·³è¿‡é‡æ–°æ¸²æŸ“');
                    return;
                }
                const newWidth = container.clientWidth;
                const newHeight = container.clientHeight;
                d3Svg.attr('width', newWidth).attr('height', newHeight);
                cachedLayout = null;
                requestTopologyRender();
            });

            const searchInput = document.getElementById('wirelistSearch');
            if (searchInput) {
                searchInput.addEventListener('input', () => {
                    renderWireList();
                });
            }

            d3Svg.on('click', function(event) {
                if (event.target.tagName === 'svg') {
                    clearWireSelection();
                }
            });
        }

        // åˆ‡æ¢æ‹“æ‰‘å›¾è§†å›¾
        function switchTopologyView(viewType) {
            currentTopologyView = viewType;
            currentFocusedWireId = null;  // é‡ç½®èšç„¦çš„å¯¼çº¿

            const busBtn = $('busViewBtn');
            const circuitBtn = $('circuitViewBtn');
            const topologyBtn = $('topologyViewBtn');

            if (busBtn) busBtn.className = viewType === 'bus' ? 'btn-primary' : 'btn-secondary';
            if (circuitBtn) circuitBtn.className = viewType === 'circuit' ? 'btn-primary' : 'btn-secondary';
            if (topologyBtn) topologyBtn.className = viewType === 'topology' ? 'btn-primary' : 'btn-secondary';

            // æ¸…é™¤é«˜äº®
            clearCircuitHighlights();
            clearWireSelection();

            requestTopologyRender();
        }

        // åˆ‡æ¢å¸ƒå±€
        function changeLayout(layout) {
            currentLayout = layout;
            cachedLayout = null;
            requestTopologyRender();
        }

        // åˆ‡æ¢æ˜¾ç¤º
        function changeDisplay(display) {
            currentDisplay = display;
            cachedLayout = null;
            renderWireList();
            requestTopologyRender();
        }

        // åˆ‡æ¢çº¿å·æ˜¾ç¤º
        function toggleWireLabels() {
            showWireLabelsEnabled = $('showWireLabels').checked;
            requestTopologyRender();
        }

        // åˆ‡æ¢ç»ˆç«¯ç”µé˜»æ˜¾ç¤º
        function toggleTerminalResistors() {
            showTerminalResistorsEnabled = $('showTerminalResistors').checked;
            requestTopologyRender();
        }

        // åˆ‡æ¢æ’ä»¶åˆå¹¶
        function toggleMergeConnectors() {
            mergeConnectorsEnabled = $('mergeConnectors').checked;
            requestTopologyRender();
        }

        // æ›´æ–°PINè„šé—´è·
        function updatePinSpacing() {
            const input = $('pinSpacing');
            if (input) {
                fixedPinSpacing = Math.max(15, Math.min(50, parseInt(input.value) || 25));
                input.value = fixedPinSpacing;
                requestTopologyRender();
            }
        }

        // V6: åˆå¹¶ç›¸åŒåç§°çš„è¿æ¥å™¨ç”µè·¯
        function mergeConnectorCircuits(circuits) {
            debugLog('[V6æ’ä»¶åˆå¹¶] å¼€å§‹åˆå¹¶ç”µè·¯ï¼ŒåŸç”µè·¯æ•°:', circuits.length);

            // æŒ‰è¿æ¥å™¨åç§°åˆ†ç»„
            const connectorGroups = new Map(); // connectorName -> { from: [], to: [] }
            const mergedCircuits = [];
            const processedPairs = new Set(); // è®°å½•å·²å¤„ç†çš„ (fromCode, toCode, fromPin, toPin) ç»„åˆ

            // é¦–å…ˆï¼Œè¯†åˆ«æ‰€æœ‰è¿æ¥å™¨å¹¶æŒ‰åç§°åˆ†ç»„
            circuits.forEach(circuit => {
                // å¤„ç† fromCode
                if (circuit.isFromConnector && circuit.fromCode) {
                    const connectorName = extractConnectorName(circuit.fromCode);
                    if (!connectorGroups.has(connectorName)) {
                        connectorGroups.set(connectorName, { fromCodes: new Set(), toCodes: new Set() });
                    }
                    connectorGroups.get(connectorName).fromCodes.add(circuit.fromCode);
                }
                // å¤„ç† toCode
                if (circuit.isToConnector && circuit.toCode) {
                    const connectorName = extractConnectorName(circuit.toCode);
                    if (!connectorGroups.has(connectorName)) {
                        connectorGroups.set(connectorName, { fromCodes: new Set(), toCodes: new Set() });
                    }
                    connectorGroups.get(connectorName).toCodes.add(circuit.toCode);
                }
            });

            // æ‰¾å‡ºéœ€è¦åˆå¹¶çš„è¿æ¥å™¨ï¼ˆåŒä¸€ä¸ªåç§°å‡ºç°å¤šæ¬¡ï¼‰
            const mergeableConnectors = [];
            connectorGroups.forEach((codes, name) => {
                const totalCodes = codes.fromCodes.size + codes.toCodes.size;
                if (totalCodes > 1) {
                    mergeableConnectors.push(name);
                }
            });

            console.log('[V6æ’ä»¶åˆå¹¶] éœ€è¦åˆå¹¶çš„è¿æ¥å™¨:', mergeableConnectors);

            // éå†ç”µè·¯ï¼Œè¿›è¡Œåˆå¹¶
            circuits.forEach(circuit => {
                const fromConnectorName = circuit.isFromConnector ? extractConnectorName(circuit.fromCode) : null;
                const toConnectorName = circuit.isToConnector ? extractConnectorName(circuit.toCode) : null;

                const fromMerged = fromConnectorName && mergeableConnectors.includes(fromConnectorName);
                const toMerged = toConnectorName && mergeableConnectors.includes(toConnectorName);

                // åˆ›å»ºç”µè·¯çš„å”¯ä¸€æ ‡è¯†
                const pairKey = `${circuit.fromCode}_${circuit.toCode}_${circuit.fromPin}_${circuit.toPin}`;

                if (processedPairs.has(pairKey)) {
                    // ç”µè·¯å·²ç»å¤„ç†è¿‡ï¼Œè·³è¿‡
                    return;
                }
                processedPairs.add(pairKey);

                if (fromMerged || toMerged) {
                    // éœ€è¦åˆå¹¶çš„ç”µè·¯
                    const mergedCircuit = {
                        ...circuit,
                        // æ ‡è®°ä¸ºåˆå¹¶åçš„ç”µè·¯
                        isMerged: true,
                        // è®°å½•åŸå§‹çš„ from/to ä»£ç åˆ—è¡¨
                        originalFromCodes: fromMerged ? Array.from(circuit.isFromConnector ? connectorGroups.get(fromConnectorName).fromCodes : [circuit.fromCode]) : [circuit.fromCode],
                        originalToCodes: toMerged ? Array.from(circuit.isToConnector ? connectorGroups.get(toConnectorName).toCodes : [circuit.toCode]) : [circuit.toCode]
                    };

                    // å¦‚æœ from ç«¯éœ€è¦åˆå¹¶ï¼Œæ‰¾åˆ°æ‰€æœ‰ç›¸åŒè¿æ¥å™¨çš„ç›¸åŒ PIN è„šçš„ç”µè·¯
                    if (fromMerged) {
                        const allFromCodes = connectorGroups.get(fromConnectorName).fromCodes;
                        allFromCodes.forEach(code => {
                            const sameCodeCircuit = circuits.find(c =>
                                c.fromCode === code &&
                                c.fromPin === circuit.fromPin &&
                                c.toCode === circuit.toCode &&
                                c.toPin === circuit.toPin &&
                                c !== circuit
                            );
                            if (sameCodeCircuit && !processedPairs.has(`${code}_${circuit.toCode}_${circuit.fromPin}_${circuit.toPin}`)) {
                                processedPairs.add(`${code}_${circuit.toCode}_${circuit.fromPin}_${circuit.toPin}`);
                            }
                        });
                    }

                    // å¦‚æœ to ç«¯éœ€è¦åˆå¹¶ï¼Œæ‰¾åˆ°æ‰€æœ‰ç›¸åŒè¿æ¥å™¨çš„ç›¸åŒ PIN è„šçš„ç”µè·¯
                    if (toMerged) {
                        const allToCodes = connectorGroups.get(toConnectorName).toCodes;
                        allToCodes.forEach(code => {
                            const sameCodeCircuit = circuits.find(c =>
                                c.fromCode === circuit.fromCode &&
                                c.fromPin === circuit.fromPin &&
                                c.toCode === code &&
                                c.toPin === circuit.toPin &&
                                c !== circuit
                            );
                            if (sameCodeCircuit && !processedPairs.has(`${circuit.fromCode}_${code}_${circuit.fromPin}_${circuit.toPin}`)) {
                                processedPairs.add(`${circuit.fromCode}_${code}_${circuit.fromPin}_${circuit.toPin}`);
                            }
                        });
                    }

                    mergedCircuits.push(mergedCircuit);
                } else {
                    // ä¸éœ€è¦åˆå¹¶çš„ç”µè·¯ï¼Œç›´æ¥æ·»åŠ 
                    mergedCircuits.push(circuit);
                }
            });

            debugLog('[V6æ’ä»¶åˆå¹¶] åˆå¹¶åç”µè·¯æ•°:', mergedCircuits.length);
            return mergedCircuits;
        }

        // V6: ä»ä»£ç ä¸­æå–è¿æ¥å™¨åç§°ï¼ˆå»æ‰ç‚¹å·åçš„åç¼€ï¼‰
        function extractConnectorName(code) {
            if (!code) return code;
            // å¦‚æœä»£ç åŒ…å«ç‚¹å·ï¼ˆå¦‚ BDM-J2.1ï¼‰ï¼Œæå–åŸºç¡€åç§°
            const match = code.match(/^(.+?)(\.\d+)?$/);
            return match ? match[1] : code;
        }

        // æ¸²æŸ“æ‹“æ‰‘å›¾
        function renderD3Topology() {
            renderRequested = false;
            debugLog('[renderD3Topology] å¼€å§‹æ¸²æŸ“');

            if (!d3Svg || !d3G) {
                console.error('[renderD3Topology] D3 SVGæœªåˆå§‹åŒ–');
                return;
            }

            if (topologyCanTypes.length === 0) {
                initTopologyData();
                renderTopologyList();
            }

            if (!currentCanType && topologyCanTypes.length > 0) {
                currentCanType = topologyCanTypes[0].canType;
            }

            if (!currentCanType) return;

            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup) return;

            if (currentTopologyView === 'topology') {
                renderTopologyAnalysisView(canTypeGroup);
            } else if (currentTopologyView === 'circuit') {
                renderCircuitTopology(canTypeGroup);
            } else {
                renderBusTopology(canTypeGroup);
            }
        }

        // æ¸²æŸ“æ‹“æ‰‘åˆ†æè§†å›¾ï¼ˆV5æ–°å¢ï¼‰
        function renderTopologyAnalysisView(canTypeGroup) {
            // æ¸…ç©ºç”»å¸ƒ
            d3G.selectAll('*').remove();

            const svgWidth = parseInt(d3Svg.attr('width')) || 1000;
            const svgHeight = parseInt(d3Svg.attr('height')) || 1000;

            // åˆ›å»ºèŠ‚ç‚¹å’Œè¾¹çš„æ•°æ®
            const nodes = [];
            const edges = [];
            const layout = activeLayout; // ä½¿ç”¨å½“å‰å¸ƒå±€

            // æ·»åŠ ECUèŠ‚ç‚¹ï¼ˆä»å¸ƒå±€è·å–ä½ç½®ï¼‰
            canTypeGroup.connectors.forEach((data, code) => {
                const pos = layout?.nodePositions?.get(code);
                nodes.push({
                    id: code,
                    type: 'ecu',
                    label: code,
                    connections: data.pins.size,
                    x: pos?.x || null,
                    y: pos?.y || null
                });
            });

            // æ·»åŠ ç„Šç‚¹èŠ‚ç‚¹ï¼ˆå›ºå®šä½ç½®ï¼‰
            canTypeGroup.solders.forEach((_, code) => {
                const pos = layout?.nodePositions?.get(code);
                nodes.push({
                    id: code,
                    type: 'splice',
                    label: code,
                    connections: 0,
                    x: pos?.x || 0,
                    y: pos?.y || 0,
                    fx: pos?.x || null,  // å›ºå®šXä½ç½®
                    fy: pos?.y || null   // å›ºå®šYä½ç½®
                });
            });

            // æ·»åŠ InlineèŠ‚ç‚¹ï¼ˆä»å¸ƒå±€è·å–ä½ç½®ï¼‰
            canTypeGroup.inlineNodes.forEach((data, code) => {
                const pos = layout?.nodePositions?.get(code);
                nodes.push({
                    id: code,
                    type: 'inline',
                    label: code + '/' + data.pair,
                    connections: data.pins.size,
                    x: pos?.x || null,
                    y: pos?.y || null
                });
            });

            // æ·»åŠ è¾¹
            canTypeGroup.circuits.forEach(circuit => {
                edges.push({
                    source: circuit.fromCode,
                    target: circuit.toCode,
                    signalType: circuit.signalType,
                    wireId: circuit.wireId
                });
            });

            // åŠ›å¯¼å‘å¸ƒå±€
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(edges).id(d => d.id).distance(80))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(svgWidth / 2, svgHeight / 2))
                .force('collision', d3.forceCollide().radius(40));

            // ç»˜åˆ¶è¾¹
            const link = d3G.append('g')
                .selectAll('line')
                .data(edges)
                .enter().append('line')
                .attr('stroke', d => d.signalType === 'CAN High' ? '#667eea' : '#764ba2')
                .attr('stroke-width', 1.5)
                .attr('opacity', 0.6);

            // ç»˜åˆ¶èŠ‚ç‚¹
            const node = d3G.append('g')
                .selectAll('g')
                .data(nodes)
                .enter().append('g')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // èŠ‚ç‚¹å½¢çŠ¶
            node.append('circle')
                .attr('r', d => d.type === 'ecu' ? 20 : (d.type === 'splice' ? 15 : 18))
                .attr('fill', d => {
                    if (d.type === 'ecu') return '#45b7d1';
                    if (d.type === 'splice') return '#ffa500';
                    return '#4ecdc4';
                })
                .attr('stroke', '#fff')
                .attr('stroke-width', 2);

            // èŠ‚ç‚¹æ ‡ç­¾
            node.append('text')
                .text(d => d.label)
                .attr('text-anchor', 'middle')
                .attr('dy', d => d.type === 'ecu' ? 35 : (d.type === 'splice' ? 28 : 30))
                .attr('font-size', '10px')
                .attr('fill', '#333');

            // æ›´æ–°ä½ç½®
            simulation.on('tick', () => {
                link
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            // æ·»åŠ æ ‡é¢˜
            d3G.append('text')
                .attr('x', svgWidth / 2)
                .attr('y', 30)
                .attr('text-anchor', 'middle')
                .attr('font-size', '16px')
                .attr('font-weight', 'bold')
                .attr('fill', '#333')
                .text(`${currentCanType} CAN ç½‘ç»œæ‹“æ‰‘å›¾ (åŠ›å¯¼å‘å¸ƒå±€)`);
        }

        // æ¸²æŸ“æ€»çº¿æ‹“æ‰‘å›¾
        function renderBusTopology(canTypeGroup) {
            if (!cachedLayout) {
                cachedLayout = calculateBusLayout(canTypeGroup);
            }
            const layout = cachedLayout;

            const topologyData = prepareTopologyData(layout, canTypeGroup);

            // æ¸…ç©ºç”»å¸ƒ
            d3G.selectAll('*').remove();

            const busY = layout.busY;
            const marginX = 80;
            const svgWidth = parseInt(d3Svg.attr('width')) || 1000;

            // ä¿å­˜å½“å‰å¸ƒå±€å’ŒcanTypeGroupçš„å¼•ç”¨ï¼Œç”¨äºæ‹–åŠ¨æ—¶æ›´æ–°
            activeLayout = layout;
            activeCanTypeGroup = canTypeGroup;
            activeTopologyData = topologyData;

            // ç»˜åˆ¶CANæ€»çº¿å‚è€ƒçº¿
            d3G.append('line')
                .attr('class', 'bus-reference-line')
                .attr('x1', marginX)
                .attr('y1', busY - 15)
                .attr('x2', svgWidth - marginX)
                .attr('y2', busY - 15)
                .attr('stroke', '#E53935')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '6,4')
                .attr('opacity', 0.5);

            d3G.append('line')
                .attr('class', 'bus-reference-line')
                .attr('x1', marginX)
                .attr('y1', busY + 15)
                .attr('x2', svgWidth - marginX)
                .attr('y2', busY + 15)
                .attr('stroke', '#1E88E5')
                .attr('stroke-width', 1)
                .attr('stroke-dasharray', '6,4')
                .attr('opacity', 0.5);

            // ç»˜åˆ¶æ€»çº¿æ ‡ç­¾
            d3G.append('text')
                .attr('class', 'bus-label')
                .attr('x', marginX - 30)
                .attr('y', busY - 15)
                .attr('fill', '#E53935')
                .attr('font-size', '10px')
                .attr('font-weight', 'bold')
                .attr('text-anchor', 'end')
                .attr('dominant-baseline', 'middle')
                .text('CAN_H');

            d3G.append('text')
                .attr('class', 'bus-label')
                .attr('x', marginX - 30)
                .attr('y', busY + 15)
                .attr('fill', '#1E88E5')
                .attr('font-size', '10px')
                .attr('font-weight', 'bold')
                .attr('text-anchor', 'end')
                .attr('dominant-baseline', 'middle')
                .text('CAN_L');

            // ç»˜åˆ¶ç»ˆç«¯ç”µé˜»
            if (showTerminalResistorsEnabled) {
                drawD3TerminalResistor(d3G, marginX + 30, busY, 'left');
                drawD3TerminalResistor(d3G, svgWidth - marginX - 30, busY, 'right');
            }

            // V7: å…ˆç»˜åˆ¶èŠ‚ç‚¹å’ŒPINè„šï¼ˆåœ¨åº•å±‚ï¼‰
            drawD3Nodes(d3G, topologyData);

            // V7: å†ç»˜åˆ¶å¯¼çº¿è¿æ¥ï¼ˆåœ¨èŠ‚ç‚¹ä¸Šæ–¹ï¼‰
            drawD3Wires(d3G, topologyData);

            // V7: å¯¼çº¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚
            raiseTopologyWires();

            // ç»˜åˆ¶Wire IDæ ‡ç­¾
            if (showWireLabelsEnabled) {
                drawD3WireLabels(d3G, topologyData);
            }

            debugLog('[renderD3Topology] æ‹“æ‰‘å›¾æ¸²æŸ“å®Œæˆ');
        }

        // æ¸²æŸ“å›è·¯è¿æ¥å›¾
        function renderCircuitTopology(canTypeGroup) {
            debugLog('[renderCircuitTopology] å¼€å§‹æ¸²æŸ“');
            d3G.selectAll('*').remove();

            const svgWidth = parseInt(d3Svg.attr('width')) || 1000;
            const svgHeight = parseInt(d3Svg.attr('height')) || 1000;

            const marginX = 80;
            const marginY = 100;
            const moduleWidth = 160;   // æ¨¡å—å®½åº¦
            const moduleHeight = 50;   // æ¨¡å—é«˜åº¦
            const pinSize = 18;        // pinå¤§å°
            const pinSpacing = 30;     // piné—´è·
            const layerSpacing = 450;  // å·¦å³å±‚é—´è·
            const moduleSpacing = 90;  // æ¨¡å—å‚ç›´é—´è·

            // ä¿å­˜å›è·¯æ‹“æ‰‘æ‹–åŠ¨æ•°æ®åˆ°å…¨å±€å˜é‡
            const circuitModules = new Map(); // code -> module
            const circuitPins = []; // é’ˆè„šæ•°ç»„
            const circuitWires = []; // å¯¼çº¿æ•°ç»„
            activeCircuitModules = circuitModules;
            activeCircuitPinPositions = new Map();
            activeCircuitInlinePairMap = inlinePairsMap;
            activeCircuitDragModule = null;
            activeCircuitData = { modules: circuitModules, pins: circuitPins, wires: circuitWires };

            // æŒ‰ä¿¡å·ç±»å‹åˆ†ç»„
            const circuitsBySignal = { 'CAN High': [], 'CAN Low': [] };
            canTypeGroup.circuits.forEach(circuit => {
                if (circuit.signalType) {
                    circuitsBySignal[circuit.signalType].push(circuit);
                }
            });

            console.log('[renderCircuitTopology] CAN Highå›è·¯æ•°:', circuitsBySignal['CAN High'].length);
            console.log('[renderCircuitTopology] CAN Lowå›è·¯æ•°:', circuitsBySignal['CAN Low'].length);

            const signalColors = { 'CAN High': '#E53935', 'CAN Low': '#1E88E5' };
            let startY = marginY;

            // ä¸ºæ¯ä¸ªä¿¡å·ç±»å‹ç»˜åˆ¶
            ['CAN High', 'CAN Low'].forEach(signalType => {
                const circuits = circuitsBySignal[signalType];
                console.log('[renderCircuitTopology] å¤„ç†', signalType, 'å›è·¯æ•°:', circuits.length);
                if (circuits.length === 0) return;

                const color = signalColors[signalType];

                // æ·»åŠ ä¿¡å·ç±»å‹æ ‡é¢˜
                d3G.append('text')
                    .attr('class', 'signal-title')
                    .attr('x', marginX - 50)
                    .attr('y', startY)
                    .attr('fill', color)
                    .attr('font-size', '18px')
                    .attr('font-weight', 'bold')
                    .attr('text-anchor', 'end')
                    .text(signalType === 'CAN High' ? 'CAN_H' : 'CAN_L');

                // æ”¶é›†æ‰€æœ‰æ¨¡å—ï¼ˆæ’ä»¶å’ŒinlineèŠ‚ç‚¹ï¼‰
                const modules = new Map(); // code -> {code, type, pins: [], x, y}

                // V6: å¦‚æœå¯ç”¨äº†æ’ä»¶åˆå¹¶ï¼Œå…ˆé¢„å¤„ç†ç”µè·¯æ•°æ®
                let processedCircuits = circuits;
                if (mergeConnectorsEnabled) {
                    // åˆ›å»ºåˆå¹¶åçš„ç”µè·¯æ•°æ®
                    processedCircuits = mergeConnectorCircuits(circuits);
                }

                processedCircuits.forEach(circuit => {
                    // å¤„ç†fromèŠ‚ç‚¹ - inlineèŠ‚ç‚¹ä½œä¸ºç‹¬ç«‹æ¨¡å—å¤„ç†
                    const fromCode = circuit.fromCode;

                    if (!modules.has(fromCode)) {
                        modules.set(fromCode, {
                            code: fromCode,
                            type: circuit.isFromInline ? 'inline' : (circuit.isFromSolder ? 'solder' : 'connector'),
                            pins: new Map(),
                            layer: circuit.isFromConnector ? 0 : 1,
                            // V6: inlineSide å°†åœ¨é…å¯¹è¿‡ç¨‹ä¸­æ ¹æ®åç§°æ¨¡å¼è®¾ç½®
                            // V6: è®°å½•åŸå§‹ä»£ç åˆ—è¡¨ï¼ˆç”¨äºæ’ä»¶åˆå¹¶ï¼‰
                            originalCodes: circuit.originalFromCodes || [fromCode]
                        });
                    }

                    const fromModule = modules.get(fromCode);

                    if (!fromModule.pins.has(circuit.fromPin)) {
                        fromModule.pins.set(circuit.fromPin, []);
                    }
                    fromModule.pins.get(circuit.fromPin).push({
                        type: 'out',
                        circuit: circuit,
                        targetCode: circuit.toCode,
                        targetPin: circuit.toPin,
                        signalType: circuit.signalType
                    });

                    // å¤„ç†toèŠ‚ç‚¹ - inlineèŠ‚ç‚¹ä½œä¸ºç‹¬ç«‹æ¨¡å—å¤„ç†
                    const toCode = circuit.toCode;

                    if (!modules.has(toCode)) {
                        modules.set(toCode, {
                            code: toCode,
                            type: circuit.isToInline ? 'inline' : (circuit.isToSolder ? 'solder' : 'connector'),
                            pins: new Map(),
                            layer: circuit.isToConnector ? 0 : 1,
                            // V6: inlineSide å°†åœ¨é…å¯¹è¿‡ç¨‹ä¸­æ ¹æ®åç§°æ¨¡å¼è®¾ç½®
                            // V6: è®°å½•åŸå§‹ä»£ç åˆ—è¡¨ï¼ˆç”¨äºæ’ä»¶åˆå¹¶ï¼‰
                            originalCodes: circuit.originalToCodes || [toCode]
                        });
                    }

                    const toModule = modules.get(toCode);

                    if (!toModule.pins.has(circuit.toPin)) {
                        toModule.pins.set(circuit.toPin, []);
                    }
                    toModule.pins.get(circuit.toPin).push({
                        type: 'in',
                        circuit: circuit,
                        sourceCode: circuit.fromCode,
                        sourcePin: circuit.fromPin,
                        signalType: circuit.signalType
                    });
                });

                // V7: åŸºäº inline.xlsx çš„é…å¯¹å…³ç³»å’Œ PIN åŒ¹é…
                // åªæœ‰åŒä¸€å¯¹ä¸” PIN ç›¸åŒçš„ inline æ‰å¹¶æ’æ˜¾ç¤º
                const inlinePairs = new Map(); // pairKey -> {left: code, right: code, pin: string}
                const pairedInlineModules = new Set(); // è®°å½•å·²ç»é…å¯¹çš„æ¨¡å—ä»£ç 

                // V7: è°ƒè¯• - æŸ¥çœ‹æ‰€æœ‰ inline æ¨¡å—
                console.log('[å¸ƒå±€] æ‰€æœ‰ inline æ¨¡å—:', Array.from(modules.values())
                    .filter(m => m.type === 'inline')
                    .map(m => ({ code: m.code, type: m.type, layer: m.layer, pins: Array.from(m.pins.keys()) })));

                // V7: ä½¿ç”¨ inline.xlsx ä¸­çš„é…å¯¹å…³ç³»ï¼Œå¹¶æ£€æŸ¥ PIN æ˜¯å¦ç›¸åŒ
                const allInlineModules = Array.from(modules.values()).filter(m => m.type === 'inline');

                // é¦–å…ˆè·å–æ¯ä¸ª inline çš„ç¬¬ä¸€ä¸ª PIN è„šå·
                const inlinePinMap = new Map(); // code -> firstPin
                allInlineModules.forEach(module => {
                    const pins = Array.from(module.pins.keys());
                    inlinePinMap.set(module.code, pins[0] || '');
                });

                // æ ¹æ® inline.xlsx çš„é…å¯¹å…³ç³»é…å¯¹
                allInlineModules.forEach(module => {
                    if (pairedInlineModules.has(module.code)) return;

                    const pairedCode = inlinePairsMap.get(module.code); // ä» inline.xlsx è·å–é…å¯¹å…³ç³»
                    if (pairedCode && modules.has(pairedCode) && !pairedInlineModules.has(pairedCode)) {
                        const pairedModule = modules.get(pairedCode);

                        // V7: æ£€æŸ¥ PIN æ˜¯å¦ç›¸åŒï¼Œåªæœ‰ç›¸åŒæ‰å¹¶æ’æ˜¾ç¤º
                        const pin1 = inlinePinMap.get(module.code);
                        const pin2 = inlinePinMap.get(pairedCode);

                        if (pin1 && pin2 && pin1 === pin2) {
                            // PIN ç›¸åŒï¼Œé…å¯¹æˆåŠŸ
                            const pairKey = module.code + 'â†”' + pairedCode;
                            inlinePairs.set(pairKey, {
                                left: module.code,
                                right: pairedCode,
                                pin: pin1
                            });
                            pairedInlineModules.add(module.code);
                            pairedInlineModules.add(pairedCode);

                            debugLog('[å¸ƒå±€] PINç›¸åŒé…å¯¹æˆåŠŸ:', module.code, '(PIN:' + pin1 + ') <->', pairedCode, '(PIN:' + pin2 + ')');
                        } else {
                            // PIN ä¸åŒï¼Œä¸é…å¯¹ï¼Œå•ç‹¬æ˜¾ç¤º
                            console.log('[å¸ƒå±€] PINä¸åŒä¸é…å¯¹:', module.code, '(PIN:' + pin1 + ') vs', pairedCode, '(PIN:' + pin2 + ')');
                        }
                    }
                });

                // V7: å¤„ç†å‰©ä½™æœªé…å¯¹çš„ inlineï¼ˆä½¿ç”¨åŸæœ‰é€»è¾‘ä½œä¸ºå¤‡é€‰ï¼‰
                const unpairedInlines = allInlineModules.filter(m => !pairedInlineModules.has(m.code));
                console.log('[å¸ƒå±€] æœªé…å¯¹çš„ inline:', unpairedInlines.map(m => m.code));

                // åˆ†ç¦»å·¦å³å±‚çš„æ¨¡å—ï¼Œä½†ä¿ç•™inlineå¯¹çš„å…³è”
                // V6: é…å¯¹çš„ inline ä¸å†æŒ‰å±‚åˆ†ç¦»ï¼Œè€Œæ˜¯ä½œä¸ºæ•´ä½“æ”¾åœ¨ä¸­é—´
                const leftOnlyModules = Array.from(modules.values()).filter(m => m.layer === 0 && m.type !== 'inline');
                const rightOnlyModules = Array.from(modules.values()).filter(m => m.layer === 1 && m.type !== 'inline');
                const pairedInlines = []; // å­˜å‚¨é…å¯¹çš„ inline [{left, right, y}, ...]
                const singleInlines = []; // å­˜å‚¨å•ç‹¬çš„ inline [{code, side}, ...]

                // å¤„ç†é…å¯¹çš„ inline
                inlinePairs.forEach((pair, pairKey) => {
                    if (pair.left && pair.right) {
                        const leftModule = modules.get(pair.left);
                        const rightModule = modules.get(pair.right);
                        if (leftModule && rightModule) {
                            pairedInlines.push({
                                left: pair.left,
                                right: pair.right,
                                y: 0
                            });
                            pairedInlineModules.add(pair.left);
                            pairedInlineModules.add(pair.right);
                        }
                    } else if (pair.left || pair.right) {
                        // å¤„ç†å•ç‹¬çš„ inline
                        const code = pair.left || pair.right;
                        const side = pair.left ? 'left' : 'right';
                        singleInlines.push({ code, side });
                        pairedInlineModules.add(code);
                    }
                });

                // V7: è°ƒè¯• - æŸ¥çœ‹é…å¯¹ç»“æœ
                console.log('[å¸ƒå±€] inline é…å¯¹ç»“æœ:');
                console.log('  pairedInlines:', pairedInlines);
                console.log('  singleInlines:', singleInlines);
                console.log('  pairedInlineModules.size:', pairedInlineModules.size);

                // V7: æœªé…å¯¹çš„ inline å·²å­˜å‚¨åœ¨ unpairedInlines ä¸­
                const leftStandaloneModules = leftOnlyModules;
                const rightStandaloneModules = rightOnlyModules;

                // æ”¶é›†inlineå¯¹çš„ä¿¡æ¯ï¼ˆåŒ…å«é…å¯¹çš„ï¼‰
                const inlinePairMap = new Map(); // code -> pairedCode
                inlinePairs.forEach((pair, pairKey) => {
                    if (pair.left && pair.right) {
                        inlinePairMap.set(pair.left, pair.right);
                        inlinePairMap.set(pair.right, pair.left);
                    }
                });

                // V6: æ–¹æ¡ˆ3 - ä¸­å¿ƒå¯¹ç§°å¸ƒå±€è®¡ç®—ä½ç½®
                // æ‰€æœ‰æ¨¡å—ï¼ˆåŒ…æ‹¬ç‹¬ç«‹inlineï¼‰æŒ‰ç±»å‹åˆ†ç»„è®¡ç®—Yä½ç½®
                const allPositionedModules = new Map();

                // è®¡ç®—ç‹¬ç«‹æ¨¡å—çš„Yä½ç½®
                let leftYIndex = 0;
                let rightYIndex = 0;
                let inlineYIndex = 0;

                leftStandaloneModules.forEach((module, idx) => {
                    module.x = marginX;
                    module.y = startY + 50 + leftYIndex * (moduleHeight + moduleSpacing);
                    module.width = moduleWidth;
                    allPositionedModules.set(module.code, module);
                    leftYIndex++;
                });

                rightStandaloneModules.forEach((module, idx) => {
                    module.x = marginX + layerSpacing;
                    module.y = startY + 50 + rightYIndex * (moduleHeight + moduleSpacing);
                    module.width = moduleWidth;
                    allPositionedModules.set(module.code, module);
                    rightYIndex++;
                });

                // é…å¯¹çš„ inline ä½œä¸ºæ•´ä½“æ”¾åœ¨ä¸­é—´å±‚ï¼ŒæŒ‰ç´¢å¼•å‡åŒ€åˆ†å¸ƒ
                const inlineSpacing = moduleHeight + moduleSpacing;
                pairedInlines.forEach((pair, idx) => {
                    const y = startY + 50 + inlineYIndex * (inlineSpacing * 2); // é…å¯¹çš„ inline å æ›´å¤šç©ºé—´

                    // V6: æ–¹æ¡ˆ3 - ä¸­å¿ƒå¯¹ç§°å¸ƒå±€
                    // left åœ¨ä¸­é—´å±‚çš„å·¦ä¾§ (layer=1)ï¼ŒPIN è„šå‘å·¦å»¶ä¼¸
                    // right åœ¨ä¸­é—´å±‚çš„å³ä¾§ (layer=0)ï¼ŒPIN è„šå‘å³å»¶ä¼¸
                    // ä¸¤ä¸ªæ¨¡å—èƒŒé èƒŒç´§è´´

                    const leftModule = modules.get(pair.left);
                    const rightModule = modules.get(pair.right);

                    if (leftModule && rightModule) {
                        // è®¡ç®—ä¸­å¿ƒä½ç½®
                        const centerX = marginX + layerSpacing / 2;

                        // left åœ¨å·¦è¾¹ï¼ˆlayer=1ï¼‰ï¼Œç´§è´´ä¸­å¿ƒï¼ŒPIN å‘å·¦å»¶ä¼¸
                        leftModule.x = centerX - moduleWidth;
                        leftModule.y = y;
                        leftModule.width = moduleWidth;
                        leftModule.layer = 1; // å·¦ä¾§å±‚
                        leftModule.inlineSide = 'left';
                        allPositionedModules.set(pair.left, leftModule);

                        // right åœ¨å³è¾¹ï¼ˆlayer=0ï¼‰ï¼Œç´§è´´ä¸­å¿ƒï¼ŒPIN å‘å³å»¶ä¼¸
                        rightModule.x = centerX; // ç´§è´´å·¦è¾¹æ¨¡å—
                        rightModule.y = y;
                        rightModule.width = moduleWidth;
                        rightModule.layer = 0; // å³ä¾§å±‚
                        rightModule.inlineSide = 'right';
                        allPositionedModules.set(pair.right, rightModule);

                        debugLog('[å¸ƒå±€] inlineå¯¹:', pair.left, 'x:', leftModule.x, '|', pair.right, 'x:', rightModule.x, '| é—´è·:', rightModule.x - leftModule.x);
                    }

                    inlineYIndex++;
                });

                // å¤„ç†å•ç‹¬çš„ inline æ¨¡å—ï¼ˆæœªé…å¯¹çš„ left æˆ– rightï¼‰
                singleInlines.forEach((item, idx) => {
                    const module = modules.get(item.code);
                    if (module) {
                        // å•ç‹¬ inline æ”¾åœ¨é…å¯¹ inline ä¸‹æ–¹
                        const y = startY + 50 + inlineYIndex * (inlineSpacing * 2);
                        const centerX = marginX + layerSpacing / 2;

                        if (item.side === 'left') {
                            // left æ”¾åœ¨ä¸­å¿ƒå·¦ä¾§ï¼ŒPIN å‘å·¦
                            module.x = centerX - moduleWidth;
                            module.y = y;
                            module.width = moduleWidth;
                            module.layer = 1;
                            module.inlineSide = 'left';
                        } else {
                            // right æ”¾åœ¨ä¸­å¿ƒå³ä¾§ï¼Œç´§è´´å·¦è¾¹æ¨¡å—
                            module.x = centerX;
                            module.y = y;
                            module.width = moduleWidth;
                            module.layer = 0;
                            module.inlineSide = 'right';
                        }
                        allPositionedModules.set(item.code, module);
                    }
                    inlineYIndex++;
                });

                // åº”ç”¨ä½ç½®åˆ°æ‰€æœ‰æ¨¡å—
                modules.forEach((module, code) => {
                    if (allPositionedModules.has(code)) {
                        module.x = allPositionedModules.get(code).x;
                        module.y = allPositionedModules.get(code).y;
                        module.width = allPositionedModules.get(code).width;
                    } else {
                        // å®‰å…¨å›é€€ï¼šæœªå®šä½çš„æ¨¡å—ä½¿ç”¨é»˜è®¤ä½ç½®
                        module.x = marginX;
                        module.y = startY + 100;
                        module.width = moduleWidth;
                    }
                });

                // ä¿å­˜å›è·¯æ‹“æ‰‘æ•°æ®åˆ°å…¨å±€å˜é‡ï¼ˆç”¨äºæ‹–åŠ¨ï¼‰
                activeCircuitModules = modules;
                activeCircuitInlinePairMap = inlinePairsMap;
                activeCircuitInlinePairs = pairedInlines;

                // å…ˆè®¡ç®—å¹¶å­˜å‚¨æ‰€æœ‰PINçš„ä½ç½®
                // V6: inlineå¯¹ä½œä¸ºæ•´ä½“ï¼Œå·¦è¾¹PINè¿æ¥åˆ°å·¦ä¾§å›è·¯ï¼Œå³è¾¹PINè¿æ¥åˆ°å³ä¾§å›è·¯
                const pinPositions = new Map(); // (moduleCode, pin) -> {x, y}
                const inlinePairPins = new Map(); // pairKey -> {leftPin, rightPin, leftCode, rightCode, y}

                // ä¸ºinlineå¯¹åˆ›å»ºPINä½ç½®ä¿¡æ¯
                pairedInlines.forEach(pair => {
                    const leftModule = modules.get(pair.left);
                    const rightModule = modules.get(pair.right);
                    if (!leftModule || !rightModule) return;

                    const pairKey = pair.left + 'â†”' + pair.right;
                    const pinY = leftModule.y + moduleHeight / 2;

                    // è·å–PINè„šå·ï¼ˆä¸¤ä¸ªæ¨¡å—åº”è¯¥æœ‰ç›¸åŒçš„PINå·ï¼‰
                    const leftPins = Array.from(leftModule.pins.keys());
                    const rightPins = Array.from(rightModule.pins.keys());
                    const pinName = leftPins[0] || rightPins[0] || '13'; // é»˜è®¤ä¸º13

                    // å·¦PINï¼šåœ¨å·¦è¾¹æ¨¡å—çš„å·¦è¾¹ç¼˜ï¼Œå‘å·¦å»¶ä¼¸
                    const leftPinX = leftModule.x;
                    // å³PINï¼šåœ¨å³è¾¹æ¨¡å—çš„å³è¾¹ç¼˜ï¼Œå‘å³å»¶ä¼¸
                    const rightPinX = rightModule.x + moduleWidth;

                    inlinePairPins.set(pairKey, {
                        leftPin: pinName,
                        rightPin: pinName,
                        leftCode: pair.left,
                        rightCode: pair.right,
                        leftX: leftPinX,
                        rightX: rightPinX,
                        y: pinY,
                        x: leftModule.x + moduleWidth / 2, // ç»„åˆæ¨¡å—ä¸­å¿ƒX
                        yPos: leftModule.y  // ç»„åˆæ¨¡å—Yä½ç½®
                    });

                    // ä¿å­˜åˆ°å…¨å±€å˜é‡ç”¨äºæ‹–åŠ¨
                    activeCircuitInlinePairs = pairedInlines;
                });

                modules.forEach(module => {
                    if (module.type === 'connector') {
                        const rectHeight = Math.max(moduleHeight, module.pins.size * fixedPinSpacing + 30);
                        const pins = Array.from(module.pins.keys());
                        pins.forEach((pin, idx) => {
                            const pinX = module.x + (module.layer === 0 ? moduleWidth : 0);
                            const pinY = module.y + rectHeight / 2 + (idx - (pins.length - 1) / 2) * fixedPinSpacing;
                            pinPositions.set(`${module.code}_${pin}`, { x: pinX, y: pinY });
                        });
                    } else if (module.type === 'solder') {
                        const pointX = module.x + (module.layer === 0 ? moduleWidth : 0);
                        const pointY = module.y + moduleHeight / 2;
                        pinPositions.set(`${module.code}_solder`, { x: pointX, y: pointY });
                    } else if (module.type === 'inline') {
                        // V6: ä¸ºinlineæ¨¡å—æ·»åŠ PINä½ç½®ï¼ˆä½œä¸ºå›é€€ï¼‰
                        // å·¦inlineï¼šPINåœ¨å·¦è¾¹ï¼›å³inlineï¼šPINåœ¨å³è¾¹
                        let inlinePinX;
                        if (module.inlineSide === 'left') {
                            inlinePinX = module.x;
                        } else {
                            inlinePinX = module.x + moduleWidth;
                        }
                        const inlinePinY = module.y + moduleHeight / 2;
                        const pins = Array.from(module.pins.keys());
                        if (pins.length > 0) {
                            pinPositions.set(`${module.code}_${pins[0]}`, { x: inlinePinX, y: inlinePinY });
                        }
                    }
                });

                // ä¿å­˜pinPositionsåˆ°å…¨å±€å˜é‡
                activeCircuitPinPositions = pinPositions;
                activeCircuitInlinePairPins = inlinePairPins;
                activeCircuitData.pinPositions = pinPositions;
                activeCircuitData.circuits = processedCircuits;
                activeCircuitData.inlinePairPins = inlinePairPins;

                // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆä½¿ç”¨è´å¡å°”æ›²çº¿ï¼‰
                processedCircuits.forEach(circuit => {
                    const fromCode = circuit.fromCode;
                    const toCode = circuit.toCode;

                    const fromModule = modules.get(fromCode);
                    const toModule = modules.get(toCode);

                    if (fromModule && toModule) {
                        // è®¡ç®—è¿æ¥ç‚¹ä½ç½®
                        let fromPinX, fromPinY;
                        let toPinX, toPinY;

                        // fromèŠ‚ç‚¹è¿æ¥ç‚¹
                        if (fromModule.type === 'connector') {
                            const pinPos = pinPositions.get(`${fromCode}_${circuit.fromPin}`);
                            if (pinPos) {
                                fromPinX = pinPos.x;
                                fromPinY = pinPos.y;
                            }
                        } else if (fromModule.type === 'inline') {
                            // V6: inlineå¯¹ä½œä¸ºæ•´ä½“ï¼Œæ‰¾åˆ°å¯¹åº”çš„pairKey
                            let foundPairPin = false;
                            inlinePairPins.forEach((pairPin, pairKey) => {
                                if (pairPin.leftCode === fromCode) {
                                    // ä»å·¦è¾¹æ¨¡å—è¿æ¥ï¼Œä½¿ç”¨å·¦PIN
                                    fromPinX = pairPin.leftX;
                                    fromPinY = pairPin.y;
                                    foundPairPin = true;
                                } else if (pairPin.rightCode === fromCode) {
                                    // ä»å³è¾¹æ¨¡å—è¿æ¥ï¼Œä½¿ç”¨å³PIN
                                    fromPinX = pairPin.rightX;
                                    fromPinY = pairPin.y;
                                    foundPairPin = true;
                                }
                            });
                            if (!foundPairPin) {
                                // æœªé…å¯¹çš„inlineï¼Œå›é€€åˆ°åŸå§‹é€»è¾‘
                                const pinPos = pinPositions.get(`${fromCode}_${circuit.fromPin}`);
                                if (pinPos) {
                                    fromPinX = pinPos.x;
                                    fromPinY = pinPos.y;
                                }
                            }
                        } else if (fromModule.type === 'solder') {
                            const pinPos = pinPositions.get(`${fromCode}_solder`);
                            if (pinPos) {
                                fromPinX = pinPos.x;
                                fromPinY = pinPos.y;
                            }
                        }

                        // toèŠ‚ç‚¹è¿æ¥ç‚¹
                        if (toModule.type === 'connector') {
                            const pinPos = pinPositions.get(`${toCode}_${circuit.toPin}`);
                            if (pinPos) {
                                toPinX = pinPos.x;
                                toPinY = pinPos.y;
                            }
                        } else if (toModule.type === 'inline') {
                            // V6: inlineå¯¹ä½œä¸ºæ•´ä½“ï¼Œæ‰¾åˆ°å¯¹åº”çš„pairKey
                            let foundPairPin = false;
                            inlinePairPins.forEach((pairPin, pairKey) => {
                                if (pairPin.leftCode === toCode) {
                                    // è¿æ¥åˆ°å·¦è¾¹æ¨¡å—ï¼Œä½¿ç”¨å·¦PIN
                                    toPinX = pairPin.leftX;
                                    toPinY = pairPin.y;
                                    foundPairPin = true;
                                } else if (pairPin.rightCode === toCode) {
                                    // è¿æ¥åˆ°å³è¾¹æ¨¡å—ï¼Œä½¿ç”¨å³PIN
                                    toPinX = pairPin.rightX;
                                    toPinY = pairPin.y;
                                    foundPairPin = true;
                                }
                            });
                            if (!foundPairPin) {
                                // æœªé…å¯¹çš„inlineï¼Œå›é€€åˆ°åŸå§‹é€»è¾‘
                                const pinPos = pinPositions.get(`${toCode}_${circuit.toPin}`);
                                if (pinPos) {
                                    toPinX = pinPos.x;
                                    toPinY = pinPos.y;
                                }
                            }
                        } else if (toModule.type === 'solder') {
                            const pinPos = pinPositions.get(`${toCode}_solder`);
                            if (pinPos) {
                                toPinX = pinPos.x;
                                toPinY = pinPos.y;
                            }
                        }

                        if (fromPinX !== undefined && toPinX !== undefined && !isNaN(fromPinX) && !isNaN(toPinX)) {
                            // ä¿å­˜é’ˆè„šæ•°æ®
                            const fromPinId = `${fromCode}_${circuit.fromPin || 'solder'}`;
                            const toPinId = `${toCode}_${circuit.toPin || 'solder'}`;

                            // æ·»åŠ  from é’ˆè„šï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                            if (!circuitPins.find(p => p.id === fromPinId)) {
                                circuitPins.push({
                                    id: fromPinId,
                                    code: fromCode,
                                    pin: circuit.fromPin || 'solder',
                                    x: fromPinX,
                                    y: fromPinY,
                                    type: fromModule.type
                                });
                            }

                            // æ·»åŠ  to é’ˆè„šï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
                            if (!circuitPins.find(p => p.id === toPinId)) {
                                circuitPins.push({
                                    id: toPinId,
                                    code: toCode,
                                    pin: circuit.toPin || 'solder',
                                    x: toPinX,
                                    y: toPinY,
                                    type: toModule.type
                                });
                            }

                            // ç»˜åˆ¶è´å¡å°”æ›²çº¿
                            const path = d3.path();
                            const cp1x = fromPinX + (toPinX - fromPinX) * 0.5;
                            const cp1y = fromPinY;
                            const cp2x = fromPinX + (toPinX - fromPinX) * 0.5;
                            const cp2y = toPinY;

                            path.moveTo(fromPinX, fromPinY);
                            path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toPinX, toPinY);

                            const wireElement = d3G.append('path')
                                .attr('class', 'circuit-wire')
                                .attr('data-from-code', fromCode)
                                .attr('data-to-code', toCode)
                                .attr('data-from-pin', circuit.fromPin || 'solder')
                                .attr('data-to-pin', circuit.toPin || 'solder')
                                .attr('data-signal-type', circuit.signalType)
                                .attr('d', path.toString())
                                .attr('fill', 'none')
                                .attr('stroke', color)
                                .attr('stroke-width', 1.5)
                                .attr('opacity', 0.7);

                            // ç»˜åˆ¶wire IDæ ‡ç­¾ï¼ˆåœ¨ä¸­ç‚¹ä½ç½®ï¼‰
                            const midX = (fromPinX + toPinX) / 2;
                            const midY = (fromPinY + toPinY) / 2;

                            const wireLabelElement = d3G.append('text')
                                .attr('class', 'wire-label')
                                .attr('data-from-code', fromCode)
                                .attr('data-to-code', toCode)
                                .attr('x', midX)
                                .attr('y', midY - 3)
                                .attr('fill', color)
                                .attr('font-size', '9px')
                                .attr('text-anchor', 'middle')
                                .attr('opacity', 0.8)
                                .text(circuit.wireId);

                            // ä¿å­˜å¯¼çº¿æ•°æ®
                            circuitWires.push({
                                wireId: circuit.wireId,
                                fromCode: fromCode,
                                toCode: toCode,
                                fromPin: circuit.fromPin || 'solder',
                                toPin: circuit.toPin || 'solder',
                                fromX: fromPinX,
                                fromY: fromPinY,
                                toX: toPinX,
                                toY: toPinY,
                                signalType: circuit.signalType,
                                wireElement: wireElement,
                                labelElement: wireLabelElement
                            });
                        }
                    }
                });

                // V6: æ”¶é›†é…å¯¹çš„inlineæ¨¡å—ä»£ç ï¼Œç”¨äºç»„åˆæ˜¾ç¤º
                const pairedInlineCodes = new Set();
                pairedInlines.forEach(pair => {
                    pairedInlineCodes.add(pair.left);
                    pairedInlineCodes.add(pair.right);
                });

                // V6: å…ˆç»˜åˆ¶ç»„åˆçš„inlineå¯¹æ¨¡å—ï¼ˆä½œä¸ºæ•´ä½“ï¼‰
                pairedInlines.forEach(pair => {
                    const leftModule = modules.get(pair.left);
                    const rightModule = modules.get(pair.right);
                    if (!leftModule || !rightModule) return;

                    // ä¿å­˜æ¨¡å—åˆ°å…¨å±€æ•°æ®
                    circuitModules.set(leftModule.code, {
                        code: leftModule.code,
                        type: 'inline',
                        x: leftModule.x,
                        y: leftModule.y,
                        layer: leftModule.layer,
                        inlineSide: 'left',
                        pairCode: rightModule.code
                    });
                    circuitModules.set(rightModule.code, {
                        code: rightModule.code,
                        type: 'inline',
                        x: rightModule.x,
                        y: rightModule.y,
                        layer: rightModule.layer,
                        inlineSide: 'right',
                        pairCode: leftModule.code
                    });

                    // V6: åˆ›å»ºç»„åˆçš„inlineå¯¹ç»„ï¼ˆèƒŒé èƒŒå¸é™„ï¼Œå¹¶æ’ç´§è´´ï¼‰
                    const inlineHeight = 50;

                    // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿æ¨¡å—ä½ç½®æœ‰æ•ˆ
                    const leftX = isFinite(leftModule.x) ? leftModule.x : 0;
                    const leftY = isFinite(leftModule.y) ? leftModule.y : 0;

                    // åˆ›å»ºå¯æ‹–åŠ¨çš„ç»„ï¼ˆä»¥å·¦è¾¹æ¨¡å—ä½ç½®ä¸ºåŸºå‡†ï¼‰
                    const inlinePairGroup = d3G.append('g')
                        .attr('class', 'circuit-module inline-pair-module')
                        .attr('data-left-code', leftModule.code)
                        .attr('data-right-code', rightModule.code)
                        .attr('data-module-type', 'inline-pair')
                        .attr('transform', `translate(${leftX}, ${leftY})`)
                        .style('cursor', 'grab');

                    // ç»˜åˆ¶èƒŒé èƒŒçŸ©å½¢æ¡†ï¼ˆä¸¤ä¸ªæ¡†å¹¶æ’ç´§è´´ï¼‰
                    // å·¦è¾¹æ¨¡å—æ¡†ï¼ˆçº¢è‰²ï¼‰
                    inlinePairGroup.append('rect')
                        .attr('class', 'inline-left-rect')
                        .attr('x', 0)
                        .attr('y', 0)
                        .attr('width', moduleWidth)
                        .attr('height', inlineHeight)
                        .attr('fill', '#FFEBEE')
                        .attr('stroke', '#E53935')
                        .attr('stroke-width', 2)
                        .attr('rx', 4);

                    // å³è¾¹æ¨¡å—æ¡†ï¼ˆè“è‰²ï¼Œç´§è´´å·¦è¾¹æ¡†ï¼‰
                    inlinePairGroup.append('rect')
                        .attr('class', 'inline-right-rect')
                        .attr('x', moduleWidth)
                        .attr('y', 0)
                        .attr('width', moduleWidth)
                        .attr('height', inlineHeight)
                        .attr('fill', '#E3F2FD')
                        .attr('stroke', '#1E88E5')
                        .attr('stroke-width', 2)
                        .attr('rx', 4);

                    // ä¸­é—´åˆ†éš”çº¿ï¼ˆè™šçº¿ï¼‰
                    inlinePairGroup.append('line')
                        .attr('class', 'inline-separator')
                        .attr('x1', moduleWidth)
                        .attr('y1', 0)
                        .attr('x2', moduleWidth)
                        .attr('y2', inlineHeight)
                        .attr('stroke', '#999')
                        .attr('stroke-width', 1)
                        .attr('stroke-dasharray', '4,2');

                    // æ˜¾ç¤ºå·¦è¾¹æ¨¡å—ä»£å·ï¼ˆåœ¨å·¦è¾¹æ¡†å†…ï¼‰
                    inlinePairGroup.append('text')
                        .attr('class', 'inline-left-name')
                        .attr('x', moduleWidth / 2)
                        .attr('y', inlineHeight / 2 - 6)
                        .attr('fill', '#E53935')
                        .attr('font-size', '11px')
                        .attr('font-weight', 'bold')
                        .attr('text-anchor', 'middle')
                        .text(leftModule.code);

                    // æ˜¾ç¤ºå³è¾¹æ¨¡å—ä»£å·ï¼ˆåœ¨å³è¾¹æ¡†å†…ï¼‰
                    inlinePairGroup.append('text')
                        .attr('class', 'inline-right-name')
                        .attr('x', moduleWidth * 1.5)
                        .attr('y', inlineHeight / 2 - 6)
                        .attr('fill', '#1E88E5')
                        .attr('font-size', '11px')
                        .attr('font-weight', 'bold')
                        .attr('text-anchor', 'middle')
                        .text(rightModule.code);

                    // æ˜¾ç¤ºPINè„šå·ï¼ˆåœ¨ä¸­é—´åˆ†éš”çº¿ä¸‹æ–¹ï¼‰
                    const pins = Array.from(leftModule.pins.keys());
                    const pinName = pins[0] || '13';
                    inlinePairGroup.append('text')
                        .attr('class', 'inline-pin-name')
                        .attr('x', moduleWidth)
                        .attr('y', inlineHeight / 2 + 14)
                        .attr('fill', '#666')
                        .attr('font-size', '10px')
                        .attr('text-anchor', 'middle')
                        .text(pinName);

                    // å·¦PINï¼ˆå‘å·¦å»¶ä¼¸ï¼Œåœ¨å·¦è¾¹æ¡†å·¦è¾¹ç¼˜ï¼‰
                    const leftPinX = 0;
                    const leftPinY = inlineHeight / 2;
                    inlinePairGroup.append('circle')
                        .attr('class', 'inline-left-pin')
                        .attr('cx', leftPinX)
                        .attr('cy', leftPinY)
                        .attr('r', 5)
                        .attr('fill', '#fff')
                        .attr('stroke', '#E53935')
                        .attr('stroke-width', 2);

                    // å³PINï¼ˆå‘å³å»¶ä¼¸ï¼Œåœ¨å³è¾¹æ¡†å³è¾¹ç¼˜ï¼‰
                    const rightPinX = moduleWidth * 2;
                    const rightPinY = inlineHeight / 2;
                    inlinePairGroup.append('circle')
                        .attr('class', 'inline-right-pin')
                        .attr('cx', rightPinX)
                        .attr('cy', rightPinY)
                        .attr('r', 5)
                        .attr('fill', '#fff')
                        .attr('stroke', '#1E88E5')
                        .attr('stroke-width', 2);

                    // æ·»åŠ æ‹–åŠ¨åŠŸèƒ½ï¼ˆæ•´ä¸ªç»„åˆä¸€èµ·ç§»åŠ¨ï¼‰
                    inlinePairGroup.call(d3.drag()
                        .on('start', function(event) {
                            activeCircuitDragModule = { type: 'inline-pair', leftModule, rightModule };
                            d3.select(this).style('cursor', 'grabbing');
                            d3Svg.interrupt(d3Zoom);
                            debugLog('[æ‹–åŠ¨] å¼€å§‹æ‹–åŠ¨ inlineå¯¹:', leftModule.code, '<->', rightModule.code,
                                'left.x:', leftModule.x, 'right.x:', rightModule.x);
                        })
                        .on('drag', function(event) {
                            if (!activeCircuitDragModule || activeCircuitDragModule.type !== 'inline-pair') return;

                            const dx = event.dx;
                            const dy = event.dy;

                            // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿å½“å‰ä½ç½®æœ‰æ•ˆ
                            const leftX = isFinite(leftModule.x) ? leftModule.x : marginX;
                            const leftY = isFinite(leftModule.y) ? leftModule.y : startY;
                            const rightX = isFinite(rightModule.x) ? rightModule.x : marginX + moduleWidth;
                            const rightY = isFinite(rightModule.y) ? rightModule.y : startY;

                            // æ›´æ–°ä¸¤ä¸ªæ¨¡å—ä½ç½®
                            leftModule.x = leftX + dx;
                            leftModule.y = leftY + dy;
                            rightModule.x = rightX + dx;
                            rightModule.y = rightY + dy;

                            console.log('[æ‹–åŠ¨] inlineå¯¹ç§»åŠ¨:', 'dx:', dx, 'left.x:', leftModule.x, 'right.x:', rightModule.x);

                            // æ›´æ–°è§†è§‰ä½ç½®ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                            d3.select(this).attr('transform', `translate(${isFinite(leftModule.x) ? leftModule.x : 0}, ${isFinite(leftModule.y) ? leftModule.y : 0})`);

                            // æ›´æ–°å…¨å±€æ¨¡å—æ•°æ®
                            const leftCircuitModule = circuitModules.get(leftModule.code);
                            const rightCircuitModule = circuitModules.get(rightModule.code);
                            if (leftCircuitModule) {
                                leftCircuitModule.x = leftModule.x;
                                leftCircuitModule.y = leftModule.y;
                            }
                            if (rightCircuitModule) {
                                rightCircuitModule.x = rightModule.x;
                                rightCircuitModule.y = rightModule.y;
                            }

                            // è®¡ç®—æ–°çš„PINä½ç½®
                            const newLeftPinX = leftModule.x;
                            const newRightPinX = rightModule.x + moduleWidth;
                            const newPinY = leftModule.y + inlineHeight / 2;
                            const pinName = pins[0] || '13';

                            // æ›´æ–°å¯¼çº¿ä½ç½®
                            circuitWires.forEach(wire => {
                                if (wire.fromCode === leftModule.code && wire.fromPin === pinName) {
                                    wire.fromX = newLeftPinX;
                                    wire.fromY = newPinY;
                                    wire.wireElement.attr('d', calculateWirePath(wire));
                                }
                                if (wire.toCode === leftModule.code && wire.toPin === pinName) {
                                    wire.toX = newLeftPinX;
                                    wire.toY = newPinY;
                                    wire.wireElement.attr('d', calculateWirePath(wire));
                                }
                                if (wire.fromCode === rightModule.code && wire.fromPin === pinName) {
                                    wire.fromX = newRightPinX;
                                    wire.fromY = newPinY;
                                    wire.wireElement.attr('d', calculateWirePath(wire));
                                }
                                if (wire.toCode === rightModule.code && wire.toPin === pinName) {
                                    wire.toX = newRightPinX;
                                    wire.toY = newPinY;
                                    wire.wireElement.attr('d', calculateWirePath(wire));
                                }
                            });

                            // æ›´æ–°æ ‡ç­¾ä½ç½®
                            updateCircuitLabels();
                            raiseCircuitWires();
                        })
                        .on('end', function() {
                            activeCircuitDragModule = null;
                            d3.select(this).style('cursor', 'grab');
                        })
                    );
                });

                // ç»˜åˆ¶å…¶ä»–æ¨¡å—ï¼ˆç„Šç‚¹å’Œè¿æ¥å™¨ï¼‰
                modules.forEach(module => {
                    // è·³è¿‡é…å¯¹çš„inlineæ¨¡å—ï¼ˆå·²ä½œä¸ºç»„åˆæ¸²æŸ“ï¼‰
                    if (module.type === 'inline' && pairedInlineCodes.has(module.code)) {
                        return;
                    }

                    // ä¿å­˜æ¨¡å—åˆ°å…¨å±€æ•°æ®
                    circuitModules.set(module.code, {
                        code: module.code,
                        type: module.type,
                        x: module.x,
                        y: module.y,
                        layer: module.layer,
                        inlineSide: module.inlineSide
                    });

                    if (module.type === 'solder') {
                        // ç„Šç‚¹ç”¨åœ†ç‚¹è¡¨ç¤º
                        const pointY = module.y + moduleHeight / 2;
                        const pointX = module.x + (module.layer === 0 ? moduleWidth : 0);

                        // åˆ›å»ºå¯æ‹–åŠ¨çš„ç»„
                        const solderGroup = d3G.append('g')
                            .attr('class', 'circuit-module solder-module')
                            .attr('data-code', module.code)
                            .attr('data-module-type', 'solder')
                            .attr('transform', `translate(${module.x}, ${module.y})`)
                            .style('cursor', 'grab');

                        // è®¡ç®—ç»„å†…ç›¸å¯¹ä½ç½®
                        const solderRelX = (module.layer === 0 ? moduleWidth : 0);
                        const solderRelY = moduleHeight / 2;

                        // ç„Šç‚¹åœ†åœˆï¼ˆç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        solderGroup.append('circle')
                            .attr('class', 'splice-point')
                            .attr('cx', solderRelX)
                            .attr('cy', solderRelY)
                            .attr('r', 8)
                            .attr('fill', '#F3E5F5')
                            .attr('stroke', color)
                            .attr('stroke-width', 2);

                        // ç„Šç‚¹åç§°ï¼ˆç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        solderGroup.append('text')
                            .attr('class', 'splice-label')
                            .attr('x', module.layer === 0 ? moduleWidth - 15 : 15)
                            .attr('y', solderRelY + 4)
                            .attr('fill', '#333')
                            .attr('font-size', '11px')
                            .attr('font-weight', 'bold')
                            .attr('text-anchor', module.layer === 0 ? 'end' : 'start')
                            .text(module.code);

                        // æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
                        solderGroup.call(d3.drag()
                            .on('start', function(event) {
                                activeCircuitDragModule = module;
                                d3.select(this).style('cursor', 'grabbing');
                                d3Svg.interrupt(d3Zoom);
                                debugLog('[æ‹–åŠ¨] å¼€å§‹æ‹–åŠ¨ solder:', module.code);
                            })
                            .on('drag', function(event) {
                                if (!activeCircuitDragModule || activeCircuitDragModule !== module) return;

                                // è®¡ç®—ä½ç§»
                                const dx = event.dx;
                                const dy = event.dy;

                                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿å½“å‰ä½ç½®æœ‰æ•ˆ
                                const currentX = isFinite(module.x) ? module.x : marginX;
                                const currentY = isFinite(module.y) ? module.y : startY;

                                // æ›´æ–°æ¨¡å—ä½ç½®
                                module.x = currentX + dx;
                                module.y = currentY + dy;

                                // æ›´æ–°å…¨å±€æ¨¡å—æ•°æ®
                                const circuitModule = circuitModules.get(module.code);
                                if (circuitModule) {
                                    circuitModule.x = module.x;
                                    circuitModule.y = module.y;
                                }

                                // æ›´æ–°è§†è§‰ä½ç½®ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                                d3.select(this).attr('transform', `translate(${isFinite(module.x) ? module.x : 0}, ${isFinite(module.y) ? module.y : 0})`);

                                // æ›´æ–°é’ˆè„šä½ç½®
                                const pinKey = `${module.code}_solder`;
                                const newPinX = module.x + (module.layer === 0 ? moduleWidth : 0);
                                const newPinY = module.y + moduleHeight / 2;

                                // æ›´æ–°é’ˆè„šæ•°æ®
                                const circuitPin = circuitPins.find(p => p.id === pinKey);
                                if (circuitPin) {
                                    circuitPin.x = newPinX;
                                    circuitPin.y = newPinY;
                                }

                                // æ›´æ–°å¯¼çº¿ä½ç½®
                                circuitWires.forEach(wire => {
                                    if (wire.fromCode === module.code) {
                                        wire.fromX = newPinX;
                                        wire.fromY = newPinY;
                                        wire.wireElement.attr('d', calculateWirePath(wire));
                                    }
                                    if (wire.toCode === module.code) {
                                        wire.toX = newPinX;
                                        wire.toY = newPinY;
                                        wire.wireElement.attr('d', calculateWirePath(wire));
                                    }
                                });

                                // æ›´æ–°æ ‡ç­¾ä½ç½®
                                updateCircuitLabels();

                                // ç¡®ä¿å¯¼çº¿å’Œæ ‡ç­¾åœ¨æœ€ä¸Šå±‚
                                raiseCircuitWires();
                            })
                            .on('end', function() {
                                activeCircuitDragModule = null;
                                d3.select(this).style('cursor', 'grab');
                            })
                        );

                    } else if (module.type === 'inline') {
                        // V6: åªæ¸²æŸ“æœªé…å¯¹çš„inlineæ¨¡å—ï¼ˆé…å¯¹çš„inlineå·²åœ¨ç»„åˆä¸­æ¸²æŸ“ï¼‰
                        if (pairedInlineCodes.has(module.code)) {
                            return;
                        }
                        // æœªé…å¯¹çš„inlineä½œä¸ºç‹¬ç«‹æ’ä»¶æ˜¾ç¤º
                        const inlineHeight = 50;

                        // æ ¹æ®inlineä¾§è¾¹é€‰æ‹©é¢œè‰²ï¼ˆleftçº¢è‰²ï¼Œrightè“è‰²ï¼‰
                        const inlineColor = module.inlineSide === 'left' ? '#E53935' : '#1E88E5';

                        // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿æ¨¡å—ä½ç½®æœ‰æ•ˆ
                        const modX = isFinite(module.x) ? module.x : 0;
                        const modY = isFinite(module.y) ? module.y : 0;

                        // åˆ›å»ºå¯æ‹–åŠ¨çš„ç»„
                        const inlineGroup = d3G.append('g')
                            .attr('class', 'circuit-module inline-module')
                            .attr('data-code', module.code)
                            .attr('data-module-type', 'inline')
                            .attr('transform', `translate(${modX}, ${modY})`)
                            .style('cursor', 'grab');

                        // ç»˜åˆ¶inlineçŸ©å½¢æ¡†ï¼ˆç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        inlineGroup.append('rect')
                            .attr('class', 'inline-rect')
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', moduleWidth)
                            .attr('height', inlineHeight)
                            .attr('fill', module.inlineSide === 'left' ? '#FFEBEE' : '#E3F2FD')
                            .attr('stroke', inlineColor)
                            .attr('stroke-width', 2)
                            .attr('rx', 4);

                        // æ˜¾ç¤ºinlineèŠ‚ç‚¹ä»£å·ï¼ˆç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        inlineGroup.append('text')
                            .attr('class', 'inline-name')
                            .attr('x', moduleWidth / 2)
                            .attr('y', inlineHeight / 2 - 6)
                            .attr('fill', inlineColor)
                            .attr('font-size', '11px')
                            .attr('font-weight', 'bold')
                            .attr('text-anchor', 'middle')
                            .text(module.code);

                        // æ˜¾ç¤ºä¾§è¾¹æ ‡ç­¾ï¼ˆleft/rightï¼‰ï¼ˆç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        inlineGroup.append('text')
                            .attr('class', 'inline-type-label')
                            .attr('x', moduleWidth / 2)
                            .attr('y', inlineHeight / 2 + 12)
                            .attr('fill', inlineColor)
                            .attr('font-size', '9px')
                            .attr('text-anchor', 'middle')
                            .text(module.inlineSide || '');

                        // ç»˜åˆ¶PINè„šï¼ˆè¿æ¥ç‚¹ï¼Œç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        const pinRelX = (module.layer === 0 ? moduleWidth : 0);
                        const pinRelY = inlineHeight / 2;
                        inlineGroup.append('circle')
                            .attr('class', 'inline-pin')
                            .attr('cx', pinRelX)
                            .attr('cy', pinRelY)
                            .attr('r', 5)
                            .attr('fill', '#fff')
                            .attr('stroke', inlineColor)
                            .attr('stroke-width', 2);

                        // æ˜¾ç¤ºpinè„šä½å·ï¼ˆç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        const pins = Array.from(module.pins.keys());
                        if (pins.length > 0) {
                            const pinLabel = pins[0];
                            inlineGroup.append('text')
                                .attr('class', 'inline-pin-label')
                                .attr('x', pinRelX)
                                .attr('y', pinRelY + 16)
                                .attr('fill', inlineColor)
                                .attr('font-size', '9px')
                                .attr('font-weight', 'bold')
                                .attr('text-anchor', 'middle')
                                .text(pinLabel);
                        }

                        // æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
                        inlineGroup.call(d3.drag()
                            .on('start', function(event) {
                                activeCircuitDragModule = module;
                                d3.select(this).style('cursor', 'grabbing');
                                d3Svg.interrupt(d3Zoom);
                                debugLog('[æ‹–åŠ¨] å¼€å§‹æ‹–åŠ¨ inline:', module.code);
                            })
                            .on('drag', function(event) {
                                if (!activeCircuitDragModule || activeCircuitDragModule !== module) return;

                                // è®¡ç®—ä½ç§»
                                const dx = event.dx;
                                const dy = event.dy;

                                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿å½“å‰ä½ç½®æœ‰æ•ˆ
                                const currentX = isFinite(module.x) ? module.x : marginX;
                                const currentY = isFinite(module.y) ? module.y : startY;

                                // æ›´æ–°æ¨¡å—ä½ç½®
                                module.x = currentX + dx;
                                module.y = currentY + dy;

                                // æ›´æ–°å…¨å±€æ¨¡å—æ•°æ®
                                const circuitModule = circuitModules.get(module.code);
                                if (circuitModule) {
                                    circuitModule.x = module.x;
                                    circuitModule.y = module.y;
                                }

                                // æ›´æ–°å½“å‰æ¨¡å—çš„è§†è§‰ä½ç½®ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                                d3.select(this).attr('transform', `translate(${isFinite(module.x) ? module.x : 0}, ${isFinite(module.y) ? module.y : 0})`);

                                // æ›´æ–°å½“å‰æ¨¡å—çš„é’ˆè„šå’Œå¯¼çº¿ä½ç½®
                                const inlineHeight = 50;
                                const modulePins = Array.from(module.pins.keys());
                                const pinName = modulePins[0] || '13';

                                // V6: æ›´æ–°inlineå¯¹çš„å·¦/å³PINä½ç½®
                                // æ‰¾åˆ°å½“å‰æ¨¡å—æ‰€å±çš„pair
                                let currentPair = null;
                                let isLeftModule = false;
                                activeCircuitInlinePairs.forEach(pair => {
                                    if (pair.left === module.code) {
                                        currentPair = pair;
                                        isLeftModule = true;
                                    } else if (pair.right === module.code) {
                                        currentPair = pair;
                                        isLeftModule = false;
                                    }
                                });

                                if (currentPair) {
                                    // é…å¯¹çš„inlineä¸€èµ·ç§»åŠ¨
                                    const pairedCode = isLeftModule ? currentPair.right : currentPair.left;
                                    const pairedModule = circuitModules.get(pairedCode);

                                    if (pairedModule) {
                                        // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿é…å¯¹æ¨¡å—ä½ç½®æœ‰æ•ˆ
                                        const pairedX = isFinite(pairedModule.x) ? pairedModule.x : marginX + moduleWidth;
                                        const pairedY = isFinite(pairedModule.y) ? pairedModule.y : startY;

                                        // ç§»åŠ¨é…å¯¹æ¨¡å—
                                        pairedModule.x = pairedX + dx;
                                        pairedModule.y = pairedY + dy;

                                        // æ›´æ–°é…å¯¹æ¨¡å—çš„è§†è§‰ä½ç½®ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                                        const pairedGroup = d3G.select(`.inline-module[data-code="${pairedCode}"]`);
                                        if (!pairedGroup.empty()) {
                                            pairedGroup.attr('transform', `translate(${isFinite(pairedModule.x) ? pairedModule.x : 0}, ${isFinite(pairedModule.y) ? pairedModule.y : 0})`);
                                        }

                                        // æ›´æ–°å…¨å±€æ•°æ®
                                        const circuitPairedModule = circuitModules.get(pairedCode);
                                        if (circuitPairedModule) {
                                            circuitPairedModule.x = pairedModule.x;
                                            circuitPairedModule.y = pairedModule.y;
                                        }
                                    }

                                    // è®¡ç®—æ–°çš„PINä½ç½®ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                                    const newLeftX = Math.min(isFinite(module.x) ? module.x : marginX, isFinite(pairedModule?.x) ? pairedModule.x : marginX);
                                    const newRightX = Math.max(isFinite(module.x) ? module.x : marginX, isFinite(pairedModule?.x) ? pairedModule.x : marginX) + moduleWidth;
                                    const newPinY = Math.min(isFinite(module.y) ? module.y : startY, isFinite(pairedModule?.y) ? pairedModule.y : startY) + inlineHeight / 2;

                                    // æ›´æ–°å·¦PINå¯¼çº¿çš„ä½ç½®
                                    circuitWires.forEach(wire => {
                                        // ä»å·¦è¾¹æ¨¡å—å‡ºå»çš„çº¿
                                        if (wire.fromCode === currentPair.left && wire.fromPin === pinName) {
                                            wire.fromX = newLeftX;
                                            wire.fromY = newPinY;
                                            wire.wireElement.attr('d', calculateWirePath(wire));
                                        }
                                        // è¿åˆ°å·¦è¾¹æ¨¡å—çš„çº¿
                                        if (wire.toCode === currentPair.left && wire.toPin === pinName) {
                                            wire.toX = newLeftX;
                                            wire.toY = newPinY;
                                            wire.wireElement.attr('d', calculateWirePath(wire));
                                        }
                                        // ä»å³è¾¹æ¨¡å—å‡ºå»çš„çº¿
                                        if (wire.fromCode === currentPair.right && wire.fromPin === pinName) {
                                            wire.fromX = newRightX;
                                            wire.fromY = newPinY;
                                            wire.wireElement.attr('d', calculateWirePath(wire));
                                        }
                                        // è¿åˆ°å³è¾¹æ¨¡å—çš„çº¿
                                        if (wire.toCode === currentPair.right && wire.toPin === pinName) {
                                            wire.toX = newRightX;
                                            wire.toY = newPinY;
                                            wire.wireElement.attr('d', calculateWirePath(wire));
                                        }
                                    });
                                } else {
                                    // æœªé…å¯¹çš„inlineï¼Œä½¿ç”¨åŸå§‹é€»è¾‘
                                    modulePins.forEach((pin, idx) => {
                                        const newPinY = module.y + inlineHeight / 2;
                                        const newPinX = module.inlineSide === 'left' ? module.x : module.x + moduleWidth;
                                        const pinKey = `${module.code}_${pin}`;

                                        const circuitPin = circuitPins.find(p => p.id === pinKey);
                                        if (circuitPin) {
                                            circuitPin.x = newPinX;
                                            circuitPin.y = newPinY;
                                        }

                                        circuitWires.forEach(wire => {
                                            if (wire.fromCode === module.code && wire.fromPin === pin) {
                                                wire.fromX = newPinX;
                                                wire.fromY = newPinY;
                                                wire.wireElement.attr('d', calculateWirePath(wire));
                                            }
                                            if (wire.toCode === module.code && wire.toPin === pin) {
                                                wire.toX = newPinX;
                                                wire.toY = newPinY;
                                                wire.wireElement.attr('d', calculateWirePath(wire));
                                            }
                                        });
                                    });
                                }

                                // æ›´æ–°æ ‡ç­¾ä½ç½®
                                updateCircuitLabels();

                                // ç¡®ä¿å¯¼çº¿å’Œæ ‡ç­¾åœ¨æœ€ä¸Šå±‚
                                raiseCircuitWires();
                            })
                            .on('end', function() {
                                activeCircuitDragModule = null;
                                d3.select(this).style('cursor', 'grab');
                            })
                        );

                    } else {
                        // æ’ä»¶ç”¨çŸ©å½¢æ˜¾ç¤º
                        const rectHeight = Math.max(moduleHeight, module.pins.size * fixedPinSpacing + 30);

                        // åˆ›å»ºå¯æ‹–åŠ¨çš„ç»„
                        const connectorGroup = d3G.append('g')
                            .attr('class', 'circuit-module connector-module')
                            .attr('data-code', module.code)
                            .attr('data-module-type', 'connector')
                            .attr('transform', `translate(${module.x}, ${module.y})`)
                            .style('cursor', 'grab');

                        connectorGroup.append('rect')
                            .attr('class', 'module-rect')
                            .attr('x', 0)
                            .attr('y', 0)
                            .attr('width', moduleWidth)
                            .attr('height', rectHeight)
                            .attr('fill', '#FFF9E6')
                            .attr('stroke', color)
                            .attr('stroke-width', 2)
                            .attr('rx', 6);

                        // ç»˜åˆ¶æ¨¡å—åç§°ï¼ˆæå–ä¸»è¦éƒ¨åˆ†ï¼Œç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        // V6: å¦‚æœæ˜¯åˆå¹¶çš„è¿æ¥å™¨ï¼Œæ˜¾ç¤ºåˆå¹¶çš„åŸå§‹ä»£ç 
                        let displayName;
                        if (module.originalCodes && module.originalCodes.length > 1) {
                            // æ˜¾ç¤ºåˆå¹¶çš„ä»£ç ï¼Œå¦‚ "BDM-J2 x3"
                            displayName = `${module.originalCodes[0]} x${module.originalCodes.length}`;
                        } else {
                            const nameParts = module.code.split('-');
                            displayName = nameParts[0] || module.code;
                        }

                        connectorGroup.append('text')
                            .attr('class', 'module-name')
                            .attr('x', moduleWidth / 2)
                            .attr('y', 20)
                            .attr('fill', '#333')
                            .attr('font-size', '14px')
                            .attr('font-weight', 'bold')
                            .attr('text-anchor', 'middle')
                            .text(displayName);

                        // V6: å¦‚æœæ˜¯åˆå¹¶çš„è¿æ¥å™¨ï¼Œåœ¨åº•éƒ¨æ˜¾ç¤ºåŸå§‹ä»£ç åˆ—è¡¨
                        if (module.originalCodes && module.originalCodes.length > 1) {
                            const codesList = module.originalCodes.join(', ');
                            connectorGroup.append('text')
                                .attr('class', 'module-original-codes')
                                .attr('x', moduleWidth / 2)
                                .attr('y', rectHeight - 8)
                                .attr('fill', '#666')
                                .attr('font-size', '10px')
                                .attr('text-anchor', 'middle')
                                .text(`[${codesList}]`);
                        } else if (module.code.includes('-')) {
                            // éåˆå¹¶çš„æ˜¾ç¤ºåŸæ¥çš„suffix
                            const nameParts = module.code.split('-');
                            const suffix = nameParts.length > 1 ? nameParts[1] : '';
                            if (suffix) {
                                connectorGroup.append('text')
                                    .attr('class', 'module-suffix')
                                    .attr('x', moduleWidth / 2)
                                    .attr('y', rectHeight - 10)
                                    .attr('fill', '#666')
                                    .attr('font-size', '12px')
                                    .attr('text-anchor', 'middle')
                                    .text(`(${suffix})`);
                            }
                        }

                        // ç»˜åˆ¶pinå’Œæ ‡ç­¾ï¼ˆç»„å†…ç›¸å¯¹åæ ‡ï¼‰
                        const pins = Array.from(module.pins.keys());
                        pins.forEach((pin, idx) => {
                            const pinRelY = rectHeight / 2 + (idx - (pins.length - 1) / 2) * fixedPinSpacing;

                            // pinåœ†åœˆ
                            connectorGroup.append('circle')
                                .attr('class', 'module-pin')
                                .attr('data-pin', pin)
                                .attr('cx', (module.layer === 0 ? moduleWidth : 0))
                                .attr('cy', pinRelY)
                                .attr('r', 6)
                                .attr('fill', '#fff')
                                .attr('stroke', color)
                                .attr('stroke-width', 2);

                            // pinæ ‡ç­¾
                            connectorGroup.append('text')
                                .attr('class', 'pin-label')
                                .attr('x', (module.layer === 0 ? moduleWidth - 15 : 15))
                                .attr('y', pinRelY + 4)
                                .attr('fill', color)
                                .attr('font-size', '11px')
                                .attr('font-weight', 'bold')
                                .attr('text-anchor', module.layer === 0 ? 'end' : 'start')
                                .text(pin);
                        });

                        // æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
                        connectorGroup.call(d3.drag()
                            .on('start', function(event) {
                                activeCircuitDragModule = module;
                                d3.select(this).style('cursor', 'grabbing');
                                d3Svg.interrupt(d3Zoom);
                                debugLog('[æ‹–åŠ¨] å¼€å§‹æ‹–åŠ¨ connector:', module.code);
                                console.log('[æ‹–åŠ¨] module.pins:', module.pins);
                            })
                            .on('drag', function(event) {
                                if (!activeCircuitDragModule || activeCircuitDragModule !== module) return;

                                // è®¡ç®—ä½ç§»
                                const dx = event.dx;
                                const dy = event.dy;

                                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿å½“å‰ä½ç½®æœ‰æ•ˆ
                                const currentX = isFinite(module.x) ? module.x : marginX;
                                const currentY = isFinite(module.y) ? module.y : startY;

                                // æ›´æ–°æ¨¡å—ä½ç½®
                                module.x = currentX + dx;
                                module.y = currentY + dy;

                                // æ›´æ–°å…¨å±€æ¨¡å—æ•°æ®
                                const circuitModule = circuitModules.get(module.code);
                                if (circuitModule) {
                                    circuitModule.x = module.x;
                                    circuitModule.y = module.y;
                                }

                                // æ›´æ–°è§†è§‰ä½ç½®ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                                d3.select(this).attr('transform', `translate(${isFinite(module.x) ? module.x : 0}, ${isFinite(module.y) ? module.y : 0})`);

                                // æ›´æ–°æ‰€æœ‰é’ˆè„šå’Œå¯¼çº¿ä½ç½®
                                const modulePins = Array.from(module.pins.keys());
                                console.log('[æ‹–åŠ¨] connector pins:', modulePins);

                                const newRectHeight = Math.max(moduleHeight, module.pins.size * fixedPinSpacing + 30);
                                modulePins.forEach((pin, idx) => {
                                    const newPinY = module.y + newRectHeight / 2 + (idx - (modulePins.length - 1) / 2) * fixedPinSpacing;
                                    const newPinX = module.x + (module.layer === 0 ? moduleWidth : 0);
                                    const pinKey = `${module.code}_${pin}`;

                                    console.log('[æ‹–åŠ¨] æ›´æ–° pin:', pinKey, '->', newPinX, newPinY);

                                    // æ›´æ–°é’ˆè„šæ•°æ®
                                    const circuitPin = circuitPins.find(p => p.id === pinKey);
                                    if (circuitPin) {
                                        circuitPin.x = newPinX;
                                        circuitPin.y = newPinY;
                                        console.log('[æ‹–åŠ¨] æ›´æ–°é’ˆè„šæ•°æ®æˆåŠŸ');
                                    } else {
                                        console.log('[æ‹–åŠ¨] æœªæ‰¾åˆ°é’ˆè„šæ•°æ®:', pinKey);
                                    }

                                    // æ›´æ–°å¯¼çº¿ä½ç½®
                                    let wireUpdated = false;
                                    circuitWires.forEach(wire => {
                                        if (wire.fromCode === module.code && wire.fromPin === pin) {
                                            wire.fromX = newPinX;
                                            wire.fromY = newPinY;
                                            wire.wireElement.attr('d', calculateWirePath(wire));
                                            wireUpdated = true;
                                            console.log('[æ‹–åŠ¨] æ›´æ–°å¯¼çº¿ from:', wire.wireId);
                                        }
                                        if (wire.toCode === module.code && wire.toPin === pin) {
                                            wire.toX = newPinX;
                                            wire.toY = newPinY;
                                            wire.wireElement.attr('d', calculateWirePath(wire));
                                            wireUpdated = true;
                                            console.log('[æ‹–åŠ¨] æ›´æ–°å¯¼çº¿ to:', wire.wireId);
                                        }
                                    });
                                    if (!wireUpdated) {
                                        console.log('[æ‹–åŠ¨] æœªæ‰¾åˆ°åŒ¹é…çš„å¯¼çº¿ for:', pinKey);
                                    }
                                });

                                // æ›´æ–°æ ‡ç­¾ä½ç½®
                                updateCircuitLabels();

                                // ç¡®ä¿å¯¼çº¿å’Œæ ‡ç­¾åœ¨æœ€ä¸Šå±‚
                                raiseCircuitWires();
                            })
                            .on('end', function() {
                                activeCircuitDragModule = null;
                                d3.select(this).style('cursor', 'grab');
                            })
                        );
                    }
                });

                // æ›´æ–°ä¸‹ä¸€ä¸ªä¿¡å·ç±»å‹çš„èµ·å§‹Yä½ç½®
                const maxModules = modules.size;
                startY += maxModules * (moduleHeight + moduleSpacing) + 120;
            });

            // V6: å°†å¯¼çº¿å’Œæ ‡ç­¾å…ƒç´ æå‡åˆ°æœ€ä¸Šå±‚ï¼Œç¡®ä¿æ˜¾ç¤ºåœ¨æ¨¡å—ä¸Šæ–¹
            d3G.selectAll('.circuit-wire').raise();
            d3G.selectAll('.wire-label').raise();

            debugLog('[renderCircuitTopology] å›è·¯è¿æ¥å›¾æ¸²æŸ“å®Œæˆ');
        }

        // è®¡ç®—å›è·¯å¯¼çº¿çš„è´å¡å°”æ›²çº¿è·¯å¾„
        function calculateWirePath(wire) {
            const path = d3.path();
            const cp1x = wire.fromX + (wire.toX - wire.fromX) * 0.5;
            const cp1y = wire.fromY;
            const cp2x = wire.fromX + (wire.toX - wire.fromX) * 0.5;
            const cp2y = wire.toY;
            path.moveTo(wire.fromX, wire.fromY);
            path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, wire.toX, wire.toY);
            return path.toString();
        }

        // V6: å°†å›è·¯ä¸­çš„å¯¼çº¿å’Œæ ‡ç­¾æå‡åˆ°æœ€ä¸Šå±‚
        function raiseCircuitWires() {
            if (d3G) {
                d3G.selectAll('.circuit-wire').raise();
                d3G.selectAll('.wire-label').raise();
            }
        }

        // æ›´æ–°å›è·¯æ‹“æ‰‘çš„è¿æ¥çº¿
        function updateCircuitWires() {
            // è°ƒè¯•ï¼šæ£€æŸ¥ d3G æ˜¯å¦å­˜åœ¨
            if (!d3G) {
                console.error('[updateCircuitWires] d3G ä¸å­˜åœ¨');
                return;
            }

            // è°ƒè¯•ï¼šæ£€æŸ¥å¯¼çº¿æ˜¯å¦å­˜åœ¨
            const allWiresBefore = d3G.selectAll('.circuit-wire');
            console.log('[updateCircuitWires] æ‹–åŠ¨å‰å¯¼çº¿æ•°é‡:', allWiresBefore.size());

            if (!activeCircuitData || !activeCircuitData.circuits) {
                console.log('[updateCircuitWires] æ— ç”µè·¯æ•°æ®ï¼Œè·³è¿‡æ›´æ–°');
                return;
            }
            if (!activeCircuitPinPositions) {
                console.log('[updateCircuitWires] æ— é’ˆè„šä½ç½®æ•°æ®ï¼Œè·³è¿‡æ›´æ–°');
                return;
            }

            const circuits = activeCircuitData.circuits;
            const pinPositions = activeCircuitPinPositions;
            const moduleWidth = 160;
            const moduleHeight = 50;

            // è°ƒè¯•æ—¥å¿—
            console.log('[updateCircuitWires] å¼€å§‹æ›´æ–°è¿æ¥çº¿ï¼Œç”µè·¯æ•°é‡:', circuits.length);

            // æ›´æ–°æ¯æ¡è¿æ¥çº¿
            circuits.forEach((circuit, idx) => {
                try {
                    const selector = `.circuit-wire[data-from-code="${circuit.fromCode}"][data-to-code="${circuit.toCode}"]`;
                    const wirePath = d3G.select(selector);

                    console.log('[updateCircuitWires] æŸ¥æ‰¾å¯¼çº¿, selector:', selector, 'found:', !wirePath.empty());

                    if (wirePath.empty()) {
                        // å°è¯•æŸ¥æ‰¾æ‰€æœ‰å¯¼çº¿ï¼Œçœ‹æ˜¯å¦å­˜åœ¨
                        const allWires = d3G.selectAll('.circuit-wire');
                        console.log('[updateCircuitWires] æ‰€æœ‰å¯¼çº¿æ•°é‡:', allWires.size());
                        if (allWires.size() > 0) {
                            allWires.each(function() {
                                console.log('[updateCircuitWirls] ç°æœ‰å¯¼çº¿:', this.getAttribute('data-from-code'), '->', this.getAttribute('data-to-code'));
                            });
                        }
                        return;
                    }

                const fromCode = circuit.fromCode;
                const toCode = circuit.toCode;
                const color = circuit.signalType === 'CAN High' ? '#E53935' : '#1E88E5';

                // è·å–æ–°çš„è¿æ¥ç‚¹ä½ç½®
                let fromPinX, fromPinY, toPinX, toPinY;

                // fromèŠ‚ç‚¹è¿æ¥ç‚¹
                const fromPinKey = circuit.fromPin ? `${fromCode}_${circuit.fromPin}` : `${fromCode}_solder`;
                const fromPinPos = pinPositions.get(fromPinKey);
                if (fromPinPos) {
                    fromPinX = fromPinPos.x;
                    fromPinY = fromPinPos.y;
                } else {
                    // è°ƒè¯•ï¼šæ˜¾ç¤ºå¯ç”¨çš„ key
                    const availableKeys = Array.from(pinPositions.keys()).filter(k => k.startsWith(fromCode));
                    console.log('[updateCircuitWires] æœªæ‰¾åˆ° fromPinKey:', fromPinKey, 'å¯ç”¨:', availableKeys);
                }

                // toèŠ‚ç‚¹è¿æ¥ç‚¹
                const toPinKey = circuit.toPin ? `${toCode}_${circuit.toPin}` : `${toCode}_solder`;
                const toPinPos = pinPositions.get(toPinKey);
                if (toPinPos) {
                    toPinX = toPinPos.x;
                    toPinY = toPinPos.y;
                } else {
                    // è°ƒè¯•ï¼šæ˜¾ç¤ºå¯ç”¨çš„ key
                    const availableKeys = Array.from(pinPositions.keys()).filter(k => k.startsWith(toCode));
                    console.log('[updateCircuitWires] æœªæ‰¾åˆ° toPinKey:', toPinKey, 'å¯ç”¨:', availableKeys);
                }

                if (fromPinX !== undefined && toPinX !== undefined) {
                    // é‡æ–°è®¡ç®—è´å¡å°”æ›²çº¿
                    const path = d3.path();
                    const cp1x = fromPinX + (toPinX - fromPinX) * 0.5;
                    const cp1y = fromPinY;
                    const cp2x = fromPinX + (toPinX - fromPinX) * 0.5;
                    const cp2y = toPinY;

                    path.moveTo(fromPinX, fromPinY);
                    path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, toPinX, toPinY);

                    wirePath.attr('d', path.toString());
                    console.log('[updateCircuitWires] æ›´æ–°å¯¼çº¿:', fromCode, '->', toCode, 'fromPin:', fromPinKey, 'toPin:', toPinKey);
                } else {
                    console.log('[updateCircuitWires] è·³è¿‡å¯¼çº¿ (ä½ç½®æœªæ‰¾åˆ°):', fromCode, '->', toCode, 'fromPinX:', fromPinX, 'toPinX:', toPinX);
                }
                } catch (e) {
                    console.error('[updateCircuitWires] æ›´æ–°è¿æ¥çº¿æ—¶å‡ºé”™:', e);
                }
            });
        }

        // æ›´æ–°å›è·¯æ‹“æ‰‘çš„æ ‡ç­¾ä½ç½®
        function updateCircuitLabels() {
            if (!activeCircuitData || !activeCircuitData.wires) return;

            const wires = activeCircuitData.wires;

            // æ›´æ–°æ¯ä¸ªwireæ ‡ç­¾
            wires.forEach((wire) => {
                // è®¡ç®—ä¸­ç‚¹ä½ç½®
                const midX = (wire.fromX + wire.toX) / 2;
                const midY = (wire.fromY + wire.toY) / 2;

                // ç›´æ¥æ›´æ–°ä¿å­˜çš„å…ƒç´ å¼•ç”¨
                if (wire.labelElement) {
                    wire.labelElement.attr('x', midX).attr('y', midY - 3);
                }
            });
        }

        // ç»˜åˆ¶D3ç»ˆç«¯ç”µé˜»
        function drawD3TerminalResistor(g, x, busY, position) {
            const resistorGroup = g.append('g')
                .attr('transform', `translate(${x}, ${busY})`);

            resistorGroup.append('rect')
                .attr('x', -15)
                .attr('y', -28)
                .attr('width', 30)
                .attr('height', 56)
                .attr('fill', '#FFFFFF')
                .attr('stroke', '#000000')
                .attr('stroke-width', 1.5)
                .attr('rx', 2);

            resistorGroup.append('text')
                .attr('x', 0)
                .attr('y', 0)
                .attr('fill', '#000000')
                .attr('font-size', '11px')
                .attr('font-weight', 'bold')
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .text('120Î©');

            resistorGroup.append('text')
                .attr('x', 0)
                .attr('y', 38)
                .attr('fill', '#000000')
                .attr('font-size', '14px')
                .attr('text-anchor', 'middle')
                .text('âš');
        }

        // ç»˜åˆ¶D3å¯¼çº¿è¿æ¥
        function drawD3Wires(g, data) {
            const wireGroups = new Map();
            data.wires.forEach((wire, index) => {
                const key = `${wire.fromId}_${wire.toId}_${wire.signalType}`;
                if (!wireGroups.has(key)) {
                    wireGroups.set(key, []);
                }
                wireGroups.get(key).push({ ...wire, originalIndex: index });
            });

            const wireOffsets = new Map();
            wireGroups.forEach((wires, key) => {
                wires.forEach((wire, i) => {
                    const total = wires.length;
                    const offset = i - (total - 1) / 2;
                    wireOffsets.set(wire.originalIndex, { offset, total });
                });
            });

            data.wires.forEach((wire, index) => {
                const color = wire.signalType === 'CAN High' ? '#E53935' : '#1E88E5';
                const offsetInfo = wireOffsets.get(index) || { offset: 0, total: 1 };
                const offsetPx = 6;

                let fromX = wire.fromX;
                let fromY = wire.fromY;
                let toX = wire.toX;
                let toY = wire.toY;

                const fromIsPin = wire.fromType === 'pin' || wire.fromType === 'inline-pin';
                const toIsPin = wire.toType === 'pin' || wire.toType === 'inline-pin';

                if ((fromIsPin && toIsPin) ||
                    (wire.fromType === 'splice' && wire.toType === 'splice')) {
                    const yOffset = offsetInfo.offset * offsetPx;
                    fromY += yOffset;
                    toY += yOffset;
                } else if (fromIsPin || toIsPin) {
                    const xOffset = offsetInfo.offset * offsetPx;
                    if (fromIsPin) fromX += xOffset;
                    if (toIsPin) toX += xOffset;
                }

                g.append('line')
                    .attr('class', 'topology-wire')
                    .attr('data-wire-id', wire.wireId)
                    .attr('data-from-code', wire.fromCode || '')
                    .attr('data-to-code', wire.toCode || '')
                    .attr('data-from-id', wire.fromId)
                    .attr('data-to-id', wire.toId)
                    .attr('data-signal-type', wire.signalType)
                    .attr('x1', fromX)
                    .attr('y1', fromY)
                    .attr('x2', toX)
                    .attr('y2', toY)
                    .attr('stroke', color)
                    .attr('stroke-width', 1.5)
                    .attr('opacity', 1);
            });
        }

        // V7: å°†æ‰€æœ‰å¯¼çº¿å…ƒç´ ç§»åˆ°æœ€ä¸Šå±‚
        function raiseTopologyWires() {
            d3G.selectAll('.topology-wire').raise();
        }

        // æ›´æ–°æ‹“æ‰‘å›¾ä¸­çš„å¯¼çº¿ä½ç½®
        function updateTopologyWires(g, data, movedNode) {
            const nodeCode = movedNode.code || movedNode.id;
            const nodeX = movedNode.x;
            const nodeY = movedNode.y;

            // æ›´æ–°è¿æ¥åˆ°è¯¥èŠ‚ç‚¹çš„æ‰€æœ‰å¯¼çº¿
            g.selectAll('.topology-wire').each(function() {
                const wireEl = d3.select(this);
                const fromCode = wireEl.attr('data-from-code');
                const toCode = wireEl.attr('data-to-code');

                // åˆ¤æ–­è¯¥å¯¼çº¿æ˜¯å¦è¿æ¥åˆ°ç§»åŠ¨çš„èŠ‚ç‚¹
                const isFromNode = fromCode === nodeCode;
                const isToNode = toCode === nodeCode;

                if (isFromNode || isToNode) {
                    // æ ¹æ®æ˜¯fromè¿˜æ˜¯toèŠ‚ç‚¹æ›´æ–°å¯¹åº”çš„åæ ‡
                    if (isFromNode) {
                        wireEl.attr('x1', nodeX).attr('y1', nodeY);
                    }
                    if (isToNode) {
                        wireEl.attr('x2', nodeX).attr('y2', nodeY);
                    }
                }
            });
        }

        // ç»˜åˆ¶D3èŠ‚ç‚¹
        function drawD3Nodes(g, data) {
            // æ„å»ºç„Šç‚¹é…å¯¹æ˜ å°„
            const solderPairMap = new Map(); // code -> pairedCode
            if (data.solderPairs) {
                data.solderPairs.forEach(pair => {
                    if (pair.ch && pair.cl) {
                        solderPairMap.set(pair.ch, pair.cl);
                        solderPairMap.set(pair.cl, pair.ch);
                    }
                });
            }

            // V10: æ„å»ºInlineé…å¯¹æ˜ å°„ï¼ˆåŸºäºinline.xlsxï¼‰
            const inlinePairMap = new Map(); // code -> pairedCode
            data.nodes.filter(n => n.type === 'inline' || n.inlineNode === true).forEach(node => {
                const code = node.code || node.id;
                if (inlinePairsMap.has(code)) {
                    const pairedCode = inlinePairsMap.get(code);
                    inlinePairMap.set(code, pairedCode);
                    inlinePairMap.set(pairedCode, code);
                }
            });

            // è·Ÿè¸ªå·²æ¸²æŸ“çš„é…å¯¹inline
            const renderedInlinePairs = new Set();

            // æ„å»ºèŠ‚ç‚¹codeåˆ°nodeå¯¹è±¡çš„æ˜ å°„
            const nodeMap = new Map();
            data.nodes.forEach(node => {
                nodeMap.set(node.id || node.code, node);
            });

            data.nodes.forEach(node => {
                let nodeElement;

                if (node.type === 'splice') {
                    const spliceCircle = g.append('circle')
                        .attr('class', 'topology-node splice-node')
                        .attr('data-node-id', node.id)
                        .attr('data-node-code', node.code)
                        .attr('data-node-type', 'splice')
                        .attr('cx', node.x)
                        .attr('cy', node.y)
                        .attr('r', 10)
                        .attr('fill', '#FFFFFF')
                        .attr('stroke', '#000000')
                        .attr('stroke-width', 1.5)
                        .style('cursor', topologyDragEnabled ? 'grab' : 'default');

                    nodeElement = spliceCircle;

                    g.append('text')
                        .attr('class', 'node-label')
                        .attr('data-node-id', node.id)
                        .attr('x', node.x)
                        .attr('y', node.y + 3)
                        .attr('fill', '#000000')
                        .attr('font-size', '8px')
                        .attr('font-weight', 'bold')
                        .attr('text-anchor', 'middle')
                        .attr('dominant-baseline', 'middle')
                        .text(node.label);

                    // V6: ä¸ºç„Šç‚¹æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
                    if (topologyDragEnabled) {
                        const drag = d3.drag()
                            .on('start', function(event) {
                                d3.select(this).style('cursor', 'grabbing');
                                d3Svg.interrupt(d3Zoom);
                                activeDragNode = {
                                    node: node,
                                    element: d3.select(this),
                                    pairedCode: solderPairMap.get(node.code)
                                };
                            })
                            .on('drag', function(event) {
                                if (!activeDragNode || activeDragNode.node !== node) return;

                                const dx = event.dx;
                                const dy = event.dy;

                                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿å½“å‰ä½ç½®æœ‰æ•ˆ
                                const currentX = isFinite(node.x) ? node.x : 0;
                                const currentY = isFinite(node.y) ? node.y : 0;

                                // æ›´æ–°å½“å‰èŠ‚ç‚¹ä½ç½®
                                node.x = currentX + dx;
                                node.y = currentY + dy;

                                // æ›´æ–°å¯è§†å…ƒç´ ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                                d3.select(this).attr('cx', isFinite(node.x) ? node.x : 0).attr('cy', isFinite(node.y) ? node.y : 0);

                                // æ›´æ–°æ ‡ç­¾ä½ç½®
                                const label = g.select(`.node-label[data-node-id="${node.id}"]`);
                                if (!label.empty()) {
                                    label.attr('x', isFinite(node.x) ? node.x : 0).attr('y', (isFinite(node.y) ? node.y : 0) + 3);
                                }

                                // æŸ¥æ‰¾å¹¶æ›´æ–°é…å¯¹çš„ç„Šç‚¹
                                if (activeDragNode.pairedCode) {
                                    const pairedNode = nodeMap.get(activeDragNode.pairedCode);
                                    if (pairedNode) {
                                        // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿é…å¯¹èŠ‚ç‚¹ä½ç½®æœ‰æ•ˆ
                                        const pairedX = isFinite(pairedNode.x) ? pairedNode.x : 0;
                                        const pairedY = isFinite(pairedNode.y) ? pairedNode.y : 0;

                                        pairedNode.x = pairedX + dx;
                                        pairedNode.y = pairedY + dy;

                                        // æ›´æ–°é…å¯¹èŠ‚ç‚¹çš„å¯è§†å…ƒç´ ï¼ˆä½¿ç”¨å®‰å…¨å€¼ï¼‰
                                        const pairedElement = g.select(`.splice-node[data-node-code="${activeDragNode.pairedCode}"]`);
                                        if (!pairedElement.empty()) {
                                            pairedElement.attr('cx', isFinite(pairedNode.x) ? pairedNode.x : 0).attr('cy', isFinite(pairedNode.y) ? pairedNode.y : 0);
                                        }

                                        // æ›´æ–°é…å¯¹èŠ‚ç‚¹çš„æ ‡ç­¾
                                        const pairedLabel = g.select(`.node-label[data-node-code="${activeDragNode.pairedCode}"]`);
                                        if (!pairedLabel.empty()) {
                                            pairedLabel.attr('x', isFinite(pairedNode.x) ? pairedNode.x : 0).attr('y', (isFinite(pairedNode.y) ? pairedNode.y : 0) + 3);
                                        }
                                    }
                                }

                                // æ›´æ–°è¿æ¥åˆ°è¯¥èŠ‚ç‚¹çš„å¯¼çº¿
                                updateTopologyWires(g, data, node);
                                // V7: æ‹–åŠ¨æ—¶ä¿æŒå¯¼çº¿åœ¨æœ€ä¸Šå±‚
                                raiseTopologyWires();
                            })
                            .on('end', function() {
                                d3.select(this).style('cursor', 'grab');
                                activeDragNode = null;
                            });

                        spliceCircle.call(drag);
                    }

                } else if (node.type === 'inline' || node.inlineNode === true) {
                    const code = node.code || node.id;
                    const pairedCode = inlinePairMap.get(code);
                    let renderedAsPair = false;

                    // æ£€æŸ¥æ˜¯å¦åº”è¯¥ä½œä¸ºé…å¯¹ç»„æ¸²æŸ“
                    if (pairedCode && !renderedInlinePairs.has(code) && !renderedInlinePairs.has(pairedCode)) {
                        // æ‰¾åˆ°é…å¯¹çš„èŠ‚ç‚¹
                        const pairedNode = nodeMap.get(pairedCode);
                        if (pairedNode) {
                            // æ ‡è®°ä¸ºå·²æ¸²æŸ“
                            renderedInlinePairs.add(code);
                            renderedInlinePairs.add(pairedCode);
                            renderedAsPair = true;

                            const w = 50;  // å•ä¸ªinlineå®½åº¦
                            const h = 28;  // inlineé«˜åº¦

                            // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿èŠ‚ç‚¹ä½ç½®æœ‰æ•ˆ
                            const nodeX = isFinite(node.x) ? node.x : 0;
                            const nodeY = isFinite(node.y) ? node.y : 0;
                            const pairedX = isFinite(pairedNode.x) ? pairedNode.x : nodeX;
                            const pairedY = isFinite(pairedNode.y) ? pairedNode.y : nodeY;

                            // è®¡ç®—ä¸­å¿ƒä½ç½®ï¼ˆä¸¤ä¸ªinlineä½œä¸ºä¸€ä¸ªæ•´ä½“ï¼‰
                            const centerX = (nodeX + pairedX) / 2;
                            const centerY = (nodeY + pairedY) / 2;

                            // è·Ÿè¸ªé…å¯¹ç»„çš„å½“å‰ä½ç½®
                            let pairCenterX = centerX;
                            let pairCenterY = centerY;

                            // åˆ›å»ºé…å¯¹ç»„
                            const inlinePairGroup = g.append('g')
                                .attr('class', 'inline-pair-group')
                                .attr('data-left-code', code)
                                .attr('data-right-code', pairedCode)
                                .attr('transform', `translate(${centerX}, ${centerY})`)
                                .style('cursor', topologyDragEnabled ? 'grab' : 'default');

                            // å·¦è¾¹inlineï¼ˆçº¢è‰²è¾¹æ¡†ï¼‰- ç´§è´´ä¸­å¿ƒçº¿
                            inlinePairGroup.append('rect')
                                .attr('class', 'topology-node inline-node inline-left')
                                .attr('data-node-id', node.id)
                                .attr('data-node-code', code)
                                .attr('data-node-type', 'inline')
                                .attr('data-pair-code', pairedCode)
                                .attr('x', -w)
                                .attr('y', -h/2)
                                .attr('width', w)
                                .attr('height', h)
                                .attr('fill', '#FFEBEE')
                                .attr('stroke', '#E53935')
                                .attr('stroke-width', 2)
                                .attr('rx', 2);

                            // å³è¾¹inlineï¼ˆè“è‰²è¾¹æ¡†ï¼‰- ç´§è´´å·¦è¾¹
                            inlinePairGroup.append('rect')
                                .attr('class', 'topology-node inline-node inline-right')
                                .attr('data-node-id', pairedNode.id)
                                .attr('data-node-code', pairedCode)
                                .attr('data-node-type', 'inline')
                                .attr('data-pair-code', code)
                                .attr('x', 0)
                                .attr('y', -h/2)
                                .attr('width', w)
                                .attr('height', h)
                                .attr('fill', '#E3F2FD')
                                .attr('stroke', '#1E88E5')
                                .attr('stroke-width', 2)
                                .attr('rx', 2);

                            // ä¸­é—´åˆ†éš”çº¿ï¼ˆä¸¤ä¸ªinlineä¹‹é—´çš„è¾¹ç•Œï¼‰
                            inlinePairGroup.append('line')
                                .attr('class', 'inline-pair-separator')
                                .attr('x1', 0)
                                .attr('y1', -h/2)
                                .attr('x2', 0)
                                .attr('y2', h/2)
                                .attr('stroke', '#999')
                                .attr('stroke-width', 1)
                                .attr('stroke-dasharray', '3,2');

                            // å·¦è¾¹æ ‡ç­¾
                            inlinePairGroup.append('text')
                                .attr('class', 'node-label inline-pair-left-label')
                                .attr('data-node-id', node.id)
                                .attr('x', -w/2)
                                .attr('y', 3)
                                .attr('fill', '#E53935')
                                .attr('font-size', '9px')
                                .attr('font-weight', 'bold')
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .text(node.label);

                            // å³è¾¹æ ‡ç­¾
                            inlinePairGroup.append('text')
                                .attr('class', 'node-label inline-pair-right-label')
                                .attr('data-node-id', pairedNode.id)
                                .attr('x', w/2)
                                .attr('y', 3)
                                .attr('fill', '#1E88E5')
                                .attr('font-size', '9px')
                                .attr('font-weight', 'bold')
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .text(pairedNode.label);

                            // è·å–å·¦è¾¹inlineçš„PINï¼ˆä»data.pinsä¸­æŸ¥æ‰¾ï¼‰
                            const leftPins = data.pins?.filter(p => p.inlineCode === code) || [];
                            const leftPin = leftPins[0]?.pin || '';
                            // è·å–å³è¾¹inlineçš„PINï¼ˆä»data.pinsä¸­æŸ¥æ‰¾ï¼‰
                            const rightPins = data.pins?.filter(p => p.inlineCode === pairedCode) || [];
                            const rightPin = rightPins[0]?.pin || '';

                            // å·¦è¾¹PINæ ‡ç­¾ï¼ˆåœ¨å·¦è¾¹inlineçš„å·¦è¾¹ï¼‰
                            if (leftPin) {
                                inlinePairGroup.append('text')
                                    .attr('class', 'inline-pin-label inline-pin-left')
                                    .attr('x', -w - 10)
                                    .attr('y', 3)
                                    .attr('fill', '#E53935')
                                    .attr('font-size', '10px')
                                    .attr('font-weight', 'bold')
                                    .attr('text-anchor', 'end')
                                    .attr('dominant-baseline', 'middle')
                                    .text(leftPin);
                            }

                            // å³è¾¹PINæ ‡ç­¾ï¼ˆåœ¨å³è¾¹inlineçš„å³è¾¹ï¼‰
                            if (rightPin) {
                                inlinePairGroup.append('text')
                                    .attr('class', 'inline-pin-label inline-pin-right')
                                    .attr('x', w + 10)
                                    .attr('y', 3)
                                    .attr('fill', '#1E88E5')
                                    .attr('font-size', '10px')
                                    .attr('font-weight', 'bold')
                                    .attr('text-anchor', 'start')
                                    .attr('dominant-baseline', 'middle')
                                    .text(rightPin);
                            }

                            // ä¸ºé…å¯¹ç»„æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
                            if (topologyDragEnabled) {
                                let startCenterX = centerX;
                                let startCenterY = centerY;

                                inlinePairGroup.call(d3.drag()
                                    .on('start', function(event) {
                                        draggingTopologyNode = { type: 'inline-pair', code: code, pairedCode: pairedCode };
                                        startCenterX = pairCenterX;
                                        startCenterY = pairCenterY;
                                        d3.select(this).style('cursor', 'grabbing');
                                    })
                                    .on('drag', function(event) {
                                        if (!draggingTopologyNode || draggingTopologyNode.type !== 'inline-pair') return;

                                        // è®¡ç®—æ–°çš„ä¸­å¿ƒä½ç½®
                                        const newCenterX = event.x;
                                        const newCenterY = event.y;

                                        // ç¡®ä¿å€¼æœ‰æ•ˆ
                                        if (!isFinite(newCenterX) || !isFinite(newCenterY)) return;

                                        // è®¡ç®—ä½ç§»
                                        const dx = newCenterX - startCenterX;
                                        const dy = newCenterY - startCenterY;

                                        // æ›´æ–°ä¸¤ä¸ªèŠ‚ç‚¹çš„ä½ç½®ï¼ˆä¿æŒç›¸å¯¹è·ç¦»ä¸å˜ï¼‰
                                        node.x += dx;
                                        node.y += dy;
                                        pairedNode.x += dx;
                                        pairedNode.y += dy;

                                        // æ›´æ–°ç»„ä½ç½®
                                        pairCenterX = newCenterX;
                                        pairCenterY = newCenterY;
                                        d3.select(this).attr('transform', `translate(${pairCenterX}, ${pairCenterY})`);

                                        // æ›´æ–°å¯¼çº¿ä½ç½®
                                        updateTopologyWires(g, data, node);
                                        updateTopologyWires(g, data, pairedNode);
                                        raiseTopologyWires();
                                    })
                                    .on('end', function() {
                                        d3.select(this).style('cursor', 'grab');
                                        draggingTopologyNode = null;
                                    })
                                );
                            }
                        }
                    }

                    // æœªé…å¯¹çš„inlineå•ç‹¬æ¸²æŸ“
                    if (!renderedAsPair) {
                        const w = 50;
                        const h = 28;

                        const inlineRect = g.append('rect')
                            .attr('class', 'topology-node inline-node')
                            .attr('data-node-id', node.id)
                            .attr('data-node-code', code)
                            .attr('data-node-type', 'inline')
                            .attr('x', node.x - w/2)
                            .attr('y', node.y - h/2)
                            .attr('width', w)
                            .attr('height', h)
                            .attr('fill', '#FFFFFF')
                            .attr('stroke', '#000000')
                            .attr('stroke-width', 1.5)
                            .attr('rx', 2)
                            .style('cursor', topologyDragEnabled ? 'grab' : 'default');

                        nodeElement = inlineRect;

                        g.append('text')
                            .attr('class', 'node-label')
                            .attr('data-node-id', node.id)
                            .attr('x', node.x)
                            .attr('y', node.y + 3)
                            .attr('fill', '#000000')
                            .attr('font-size', '9px')
                            .attr('font-weight', 'bold')
                            .attr('text-anchor', 'middle')
                            .attr('dominant-baseline', 'middle')
                            .text(node.label);
                    }
                } else if (node.type === 'ecu') {
                    const boxWidth = 110;
                    const boxHeight = 45;

                    const ecuRect = g.append('rect')
                        .attr('class', 'topology-node ecu-node')
                        .attr('data-node-id', node.id)
                        .attr('data-node-code', node.code)
                        .attr('data-node-type', 'ecu')
                        .attr('x', node.x - boxWidth/2)
                        .attr('y', node.y - boxHeight/2)
                        .attr('width', boxWidth)
                        .attr('height', boxHeight)
                        .attr('fill', '#FFFFFF')
                        .attr('stroke', '#000000')
                        .attr('stroke-width', 1.5)
                        .attr('rx', 2)
                        .style('cursor', topologyDragEnabled ? 'grab' : 'default');

                    nodeElement = ecuRect;

                    g.append('text')
                        .attr('class', 'node-label ecu-label')
                        .attr('data-node-id', node.id)
                        .attr('x', node.x)
                        .attr('y', node.y - 10)
                        .attr('fill', '#000000')
                        .attr('font-size', '12px')
                        .attr('font-weight', 'bold')
                        .attr('text-anchor', 'middle')
                        .text(node.label);

                    const connectorInfo = node.connector || 'A';
                    const pinInfo = node.pins || 'PIN 1, 2';
                    g.append('text')
                        .attr('class', 'node-label ecu-pin-info')
                        .attr('data-node-id', node.id)
                        .attr('x', node.x)
                        .attr('y', node.y + 6)
                        .attr('fill', '#333333')
                        .attr('font-size', '9px')
                        .attr('text-anchor', 'middle')
                        .text(`${connectorInfo} ${pinInfo}`);
                }

                // ä¸ºECUèŠ‚ç‚¹å’ŒinlineèŠ‚ç‚¹æ·»åŠ æ‹–åŠ¨åŠŸèƒ½
                if (nodeElement && (node.type === 'ecu' || (node.type === 'splice' && node.inlineNode))) {
                    nodeElement.call(d3.drag()
                        .on('start', function(event, d) {
                            if (!topologyDragEnabled) return;
                            draggingTopologyNode = node;
                            d3.select(this).style('cursor', 'grabbing');
                            debugLog('[æ‹–åŠ¨] å¼€å§‹æ‹–åŠ¨èŠ‚ç‚¹:', node.id);
                        })
                        .on('drag', function(event, d) {
                            if (!topologyDragEnabled || !draggingTopologyNode) return;

                            // è®¡ç®—ä½ç§»å¢é‡
                            const dx = event.x - draggingTopologyNode.x;
                            const dy = event.y - draggingTopologyNode.y;

                            // æ›´æ–°èŠ‚ç‚¹ä½ç½®
                            draggingTopologyNode.x = event.x;
                            draggingTopologyNode.y = event.y;

                            // æ›´æ–°ç¼“å­˜çš„layoutä½ç½®
                            if (activeLayout) {
                                if (node.type === 'ecu') {
                                    const pos = activeLayout.connectorPositions.get(node.id);
                                    if (pos) {
                                        pos.x = event.x;
                                        pos.y = event.y;
                                    }
                                } else if (node.inlineNode) {
                                    // inlineèŠ‚ç‚¹éœ€è¦æ›´æ–°nodePositions
                                    const pos = activeLayout.nodePositions?.get(node.id);
                                    if (pos) {
                                        pos.x = event.x;
                                        pos.y = event.y;
                                    }

                                    // å¦‚æœè¿™æ˜¯inlineå¯¹ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œéœ€è¦åŒæ—¶æ›´æ–°å¦ä¸€ä¸ªèŠ‚ç‚¹ï¼Œä¿æŒå·¦å³é—´è·
                                    let pairedCode = null;
                                    let isLeftNode = false;
                                    activeLayout.inlinePositions?.forEach((inlinePos) => {
                                        if (inlinePos.leftCode === node.id && inlinePos.rightCode && inlinePos.rightCode !== node.id) {
                                            pairedCode = inlinePos.rightCode;
                                            isLeftNode = true;
                                        } else if (inlinePos.rightCode === node.id && inlinePos.leftCode && inlinePos.leftCode !== node.id) {
                                            pairedCode = inlinePos.leftCode;
                                            isLeftNode = false;
                                        }
                                    });

                                    if (pairedCode) {
                                        const pairedPos = activeLayout.nodePositions?.get(pairedCode);
                                        if (pairedPos) {
                                            // é…å¯¹èŠ‚ç‚¹ä¹Ÿç§»åŠ¨ç›¸åŒçš„è·ç¦»ï¼Œä¿æŒå·¦å³é—´è·
                                            pairedPos.x += dx;
                                            pairedPos.y += dy;
                                        }

                                        // æ›´æ–°é…å¯¹èŠ‚ç‚¹çš„è§†è§‰ä½ç½®
                                        const pairedNode = activeTopologyData?.nodes.find(n => n.id === pairedCode);
                                        if (pairedNode) {
                                            pairedNode.x += dx;
                                            pairedNode.y += dy;
                                            updateNodePosition(pairedNode);
                                        }

                                        // æ›´æ–°inlinePositionsä¸­çš„ä¸­å¿ƒä½ç½®
                                        activeLayout.inlinePositions?.forEach((inlinePos) => {
                                            if (inlinePos.leftCode === node.id || inlinePos.rightCode === node.id) {
                                                inlinePos.x += dx;
                                                inlinePos.y += dy;
                                            }
                                        });
                                    }
                                }
                            }

                            // æ›´æ–°èŠ‚ç‚¹è§†è§‰ä½ç½®
                            updateNodePosition(draggingTopologyNode);

                            // æ›´æ–°ç›¸å…³çš„PINè„šä½ç½®
                            updateRelatedPins(draggingTopologyNode, dx, dy);

                            // æ›´æ–°ç›¸å…³çš„å¯¼çº¿ä½ç½®
                            updateRelatedWires(draggingTopologyNode);
                        })
                        .on('end', function(event, d) {
                            if (!topologyDragEnabled) return;
                            d3.select(this).style('cursor', 'grab');
                            debugLog('[æ‹–åŠ¨] ç»“æŸæ‹–åŠ¨èŠ‚ç‚¹:', node.id, 'æ–°ä½ç½®:', event.x, event.y);
                            draggingTopologyNode = null;
                        }));
                }
            });

            // ç»˜åˆ¶PINè„š
            data.pins.forEach(pin => {
                const color = pin.signalType === 'CAN High' ? '#E53935' : '#1E88E5';
                const isInlinePin = pin.type === 'inline-pin';
                const pinRadius = isInlinePin ? 4 : 5;

                g.append('circle')
                    .attr('class', 'topology-pin')
                    .attr('data-pin-id', pin.id)
                    .attr('data-pin-node-code', pin.connectorCode || '')
                    .attr('data-pin-inline-code', pin.inlineCode || '')
                    .attr('data-pin-signal-type', pin.signalType)
                    .attr('cx', pin.x)
                    .attr('cy', pin.y)
                    .attr('r', pinRadius)
                    .attr('fill', isInlinePin ? '#ffffff' : color)
                    .attr('stroke', color)
                    .attr('stroke-width', isInlinePin ? 2 : 1);

                g.append('text')
                    .attr('class', 'pin-label')
                    .attr('data-pin-id', pin.id)
                    .attr('data-pin-node-code', pin.connectorCode || '')
                    .attr('data-pin-inline-code', pin.inlineCode || '')
                    .attr('x', pin.x)
                    .attr('y', pin.y - 8)
                    .attr('fill', color)
                    .attr('font-size', isInlinePin ? '7px' : '8px')
                    .attr('font-weight', isInlinePin ? 'normal' : 'bold')
                    .attr('text-anchor', 'middle')
                    .text(pin.pin);
            });
        }

        // æ›´æ–°èŠ‚ç‚¹ä½ç½®çš„è¾…åŠ©å‡½æ•°
        function updateNodePosition(node) {
            // æ›´æ–°èŠ‚ç‚¹å…ƒç´ ä½ç½®
            if (node.type === 'ecu') {
                const boxWidth = 110;
                const boxHeight = 45;

                d3G.select(`.ecu-node[data-node-id="${node.id}"]`)
                    .attr('x', node.x - boxWidth/2)
                    .attr('y', node.y - boxHeight/2);

                d3G.selectAll(`.ecu-label[data-node-id="${node.id}"]`)
                    .attr('x', node.x)
                    .attr('y', node.y - 10);

                d3G.selectAll(`.ecu-pin-info[data-node-id="${node.id}"]`)
                    .attr('x', node.x)
                    .attr('y', node.y + 6);

            } else if (node.type === 'splice' && node.inlineNode) {
                d3G.select(`.splice-node[data-node-id="${node.id}"]`)
                    .attr('cx', node.x)
                    .attr('cy', node.y);

                d3G.selectAll(`.node-label[data-node-id="${node.id}"]`)
                    .attr('x', node.x)
                    .attr('y', node.y + 3);
            }
        }

        // æ›´æ–°ç›¸å…³PINè„šä½ç½®
        function updateRelatedPins(node, dx, dy) {
            if (!activeTopologyData) return;

            // æ‰¾åˆ°å±äºè¿™ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰PINè„š
            activeTopologyData.pins.forEach(pin => {
                let shouldUpdate = false;

                if (node.type === 'ecu' && pin.connectorCode === node.id) {
                    shouldUpdate = true;
                } else if (node.inlineNode && pin.inlineCode === node.id) {
                    shouldUpdate = true;
                }

                if (shouldUpdate) {
                    // æ›´æ–°PINè„šä½ç½®
                    pin.x += dx;
                    pin.y += dy;

                    // æ›´æ–°è§†è§‰ä½ç½®
                    d3G.select(`.topology-pin[data-pin-id="${pin.id}"]`)
                        .attr('cx', pin.x)
                        .attr('cy', pin.y);

                    d3G.select(`.pin-label[data-pin-id="${pin.id}"]`)
                        .attr('x', pin.x)
                        .attr('y', pin.y - 8);
                }
            });
        }

        // æ›´æ–°ç›¸å…³å¯¼çº¿ä½ç½®
        function updateRelatedWires(node) {
            if (!activeTopologyData) return;

            activeTopologyData.wires.forEach(wire => {
                let needsUpdate = false;

                // æ£€æŸ¥å¯¼çº¿æ˜¯å¦è¿æ¥åˆ°è¢«æ‹–åŠ¨çš„èŠ‚ç‚¹
                if (wire.fromCode === node.id || wire.toCode === node.id) {
                    needsUpdate = true;
                }

                if (needsUpdate) {
                    // æ›´æ–°å¯¼çº¿ä½ç½®
                    if (wire.fromCode === node.id) {
                        // æŸ¥æ‰¾ç›¸å…³çš„PINè„šä½ç½®
                        const pin = activeTopologyData.pins.find(p =>
                            (p.connectorCode === node.id && wire.fromId === p.id) ||
                            (p.inlineCode === node.id && wire.fromId === p.id)
                        );

                        if (pin) {
                            wire.fromX = pin.x;
                            wire.fromY = pin.y;
                        }
                    }

                    if (wire.toCode === node.id) {
                        // æŸ¥æ‰¾ç›¸å…³çš„PINè„šä½ç½®
                        const pin = activeTopologyData.pins.find(p =>
                            (p.connectorCode === node.id && wire.toId === p.id) ||
                            (p.inlineCode === node.id && wire.toId === p.id)
                        );

                        if (pin) {
                            wire.toX = pin.x;
                            wire.toY = pin.y;
                        }
                    }

                    // æ›´æ–°è§†è§‰ä½ç½®
                    d3G.select(`.topology-wire[data-from-id="${wire.fromId}"][data-to-id="${wire.toId}"][data-signal-type="${wire.signalType}"]`)
                        .attr('x1', wire.fromX)
                        .attr('y1', wire.fromY)
                        .attr('x2', wire.toX)
                        .attr('y2', wire.toY);
                }
            });
        }

        // ç»˜åˆ¶D3 Wire IDæ ‡ç­¾
        function drawD3WireLabels(g, data) {
            const labelGroups = new Map();
            data.wires.forEach((wire, index) => {
                const gridSize = 80;
                const gridX = Math.floor(wire.labelX / gridSize);
                const gridY = Math.floor(wire.labelY / gridSize);
                const key = `${gridX}_${gridY}`;

                if (!labelGroups.has(key)) {
                    labelGroups.set(key, wire);
                }
            });

            labelGroups.forEach(wire => {
                const color = wire.signalType === 'CAN High' ? '#E53935' : '#1E88E5';
                const wireIdText = wire.wireId || '';
                const multicoreText = wire.multicoreId || '';
                const labelText = `${wireIdText} ${multicoreText}`.trim();

                const labelGroup = g.append('g')
                    .attr('class', 'wire-label')
                    .attr('data-wire-id', wire.wireId)
                    .style('cursor', 'pointer')
                    .on('click', function(event) {
                        event.stopPropagation();
                        focusWireOnTopology(wire);
                    });

                labelGroup.append('text')
                    .attr('x', wire.labelX)
                    .attr('y', wire.labelY - 5)
                    .attr('fill', color)
                    .attr('font-size', '9px')
                    .attr('font-weight', 'normal')
                    .attr('text-anchor', 'middle')
                    .attr('dominant-baseline', 'middle')
                    .text(labelText);
            });
        }

        // åœ¨æ‹“æ‰‘å›¾ä¸­èšç„¦åˆ°æŒ‡å®šå¯¼çº¿
        function focusWireOnTopology(wire) {
            const color = wire.signalType === 'CAN High' ? '#ff0000' : '#ff00ff';

            clearWireSelection();

            selectedWireId = wire.wireId;

            const wireMidX = (wire.fromX + wire.toX) / 2;
            const wireMidY = (wire.fromY + wire.toY) / 2;
            const wireLength = Math.sqrt(
                Math.pow(wire.toX - wire.fromX, 2) +
                Math.pow(wire.toY - wire.fromY, 2)
            );

            const svgWidth = parseInt(d3Svg.attr('width')) || 1000;
            const svgHeight = parseInt(d3Svg.attr('height')) || 1000;

            const targetScale = Math.min(
                (svgWidth * 0.6) / (wireLength + 200),
                2
            );

            const translateX = (svgWidth / 2) - wireMidX * targetScale;
            const translateY = (svgHeight / 2) - wireMidY * targetScale;

            const newTransform = d3.zoomIdentity
                .translate(translateX, translateY)
                .scale(targetScale);

            d3G.transition()
                .duration(750)
                .attr('transform', newTransform);

            d3Zoom.transform(d3Svg, newTransform);

            setTimeout(() => {
                selectedWireElement = d3G.append('line')
                    .attr('x1', wire.fromX)
                    .attr('y1', wire.fromY)
                    .attr('x2', wire.toX)
                    .attr('y2', wire.toY)
                    .attr('stroke', color)
                    .attr('stroke-width', 4)
                    .attr('opacity', 1)
                    .attr('data-original-color', color);
            }, 100);
        }

        // æ¸…é™¤å¯¼çº¿é€‰ä¸­çŠ¶æ€
        let selectedWireId = null;
        let selectedWireElement = null;

        function clearWireSelection() {
            if (selectedWireElement) {
                selectedWireElement.remove();
                selectedWireElement = null;
            }

            selectedWireId = null;
        }

        function clearHighlights() {
            clearWireSelection();
            currentFocusedWireId = null;
        }

        // è¯·æ±‚æ‹“æ‰‘å›¾æ¸²æŸ“
        function requestTopologyRender() {
            const stack = new Error().stack.split('\n').slice(2, 6).map(s => s.trim()).join(' | ');
            console.log('[requestTopologyRender] è¢«è°ƒç”¨ from:', stack);
            if (!renderRequested) {
                renderRequested = true;
                requestAnimationFrame(renderD3Topology);
            }
        }

        // è®¡ç®—æ€»çº¿å¸ƒå±€
        function calculateBusLayout(canTypeGroup) {
            // æ¯æ¬¡éƒ½é‡æ–°è®¡ç®—ï¼Œä¸ä½¿ç”¨ç¼“å­˜
            cachedLayout = null;

            const nodePositions = new Map();
            const inlinePositions = new Map();
            const solderPositions = new Map();
            const connectorPositions = new Map();
            const connectorPinPositions = new Map();

            const marginX = 100;
            const horizontalSpacing = 140;
            const verticalSpacing = 120;
            const pluginDistanceFromSolder = 500; // æ’ä»¶ç¦»ç„Šç‚¹çš„è·ç¦»

            let svgWidth = 1000;
            let svgHeight = 1000;
            if (typeof d3Svg !== 'undefined' && d3Svg) {
                svgWidth = parseInt(d3Svg.attr('width')) || 1000;
                svgHeight = parseInt(d3Svg.attr('height')) || 1000;
            }

            const busY = svgHeight / 2;  // æ€»çº¿åœ¨ä¸­é—´ä½ç½®

            // æ”¶é›†æ‰€æœ‰ç„Šç‚¹å’ŒInlineèŠ‚ç‚¹
            const solderSet = new Set();
            const inlineSet = new Set();
            const solderSignals = new Map(); // è®°å½•æ¯ä¸ªç„Šç‚¹è¿æ¥çš„ä¿¡å·ç±»å‹

            canTypeGroup.circuits.forEach(circuit => {
                if (circuit.isFromSolder && circuit.fromCode) {
                    solderSet.add(circuit.fromCode);
                    if (!solderSignals.has(circuit.fromCode)) solderSignals.set(circuit.fromCode, new Set());
                    solderSignals.get(circuit.fromCode).add(circuit.signalType);
                }
                if (circuit.isToSolder && circuit.toCode) {
                    solderSet.add(circuit.toCode);
                    if (!solderSignals.has(circuit.toCode)) solderSignals.set(circuit.toCode, new Set());
                    solderSignals.get(circuit.toCode).add(circuit.signalType);
                }
                if (circuit.isFromInline && circuit.fromCode) inlineSet.add(circuit.fromCode);
                if (circuit.isToInline && circuit.toCode) inlineSet.add(circuit.toCode);
            });

            // æ„å»ºç„Šç‚¹è¿æ¥å…³ç³»å›¾ï¼ˆæŒ‰ä¿¡å·ç±»å‹åˆ†å¼€ï¼‰
            const solderConnectionsHigh = new Map(); // CHè¿æ¥å…³ç³»
            const solderConnectionsLow = new Map();  // CLè¿æ¥å…³ç³»

            canTypeGroup.circuits.forEach(circuit => {
                if (circuit.isFromSolder && circuit.isToSolder && circuit.fromCode && circuit.toCode && circuit.fromCode !== circuit.toCode) {
                    const connMap = circuit.signalType === 'CAN High' ? solderConnectionsHigh : solderConnectionsLow;
                    if (!connMap.has(circuit.fromCode)) connMap.set(circuit.fromCode, new Set());
                    connMap.get(circuit.fromCode).add(circuit.toCode);
                    if (!connMap.has(circuit.toCode)) connMap.set(circuit.toCode, new Set());
                    connMap.get(circuit.toCode).add(circuit.fromCode);
                }
            });

            // ç»Ÿä¸€å¤„ç†ï¼šå°†ç„Šç‚¹å¯¹å’Œinlineå¯¹ä¸€èµ·æ’åº
            function buildAndSortNodePairs() {
                // ============ ç¬¬ä¸€æ­¥ï¼šæ‰¾å‡ºæ‰€æœ‰ç„Šç‚¹å¯¹ï¼ˆCH-CLé…å¯¹ï¼‰============
                const solderArray = Array.from(solderSet);

                // æ„å»ºç„Šç‚¹ -> Wire ID é›†åˆçš„æ˜ å°„
                const solderWires = new Map();
                canTypeGroup.circuits.forEach(circuit => {
                    if (circuit.isFromSolder && circuit.fromCode) {
                        if (!solderWires.has(circuit.fromCode)) solderWires.set(circuit.fromCode, new Set());
                        solderWires.get(circuit.fromCode).add(circuit.wireId);
                    }
                    if (circuit.isToSolder && circuit.toCode) {
                        if (!solderWires.has(circuit.toCode)) solderWires.set(circuit.toCode, new Set());
                        solderWires.get(circuit.toCode).add(circuit.wireId);
                    }
                });

                // è·å–ç„Šç‚¹çš„ Wire ID åŸºç¡€éƒ¨åˆ†ï¼ˆç¬¬4ä½çš„ H æˆ– Lï¼‰
                function getWireBaseIds(code) {
                    const wires = solderWires.get(code);
                    if (!wires) return new Set();
                    const baseIds = new Set();
                    for (const wireId of wires) {
                        if (wireId.length >= 4) {
                            const baseId = wireId.slice(0, 3) + wireId.slice(4);
                            baseIds.add(baseId);
                        } else {
                            baseIds.add(wireId);
                        }
                    }
                    return baseIds;
                }

                const solderPairs = [];
                const solderPairedSet = new Set();

                for (const code of solderArray) {
                    if (solderPairedSet.has(code)) continue;

                    const codeWires = getWireBaseIds(code);
                    const codeSignals = solderSignals.get(code);
                    const isHigh = codeSignals && codeSignals.has('CAN High');
                    const isLow = codeSignals && codeSignals.has('CAN Low');

                    // æ‰¾é…å¯¹ç„Šç‚¹
                    let pairedCode = null;
                    for (const other of solderArray) {
                        if (other === code || solderPairedSet.has(other)) continue;

                        const otherSignals = solderSignals.get(other);
                        const otherIsHigh = otherSignals && otherSignals.has('CAN High');
                        const otherIsLow = otherSignals && otherSignals.has('CAN Low');

                        if (isHigh && otherIsLow) {
                            const otherWires = getWireBaseIds(other);
                            if (otherWires.size === codeWires.size &&
                                [...codeWires].every(id => otherWires.has(id))) {
                                pairedCode = other;
                                break;
                            }
                        } else if (isLow && otherIsHigh) {
                            const otherWires = getWireBaseIds(other);
                            if (otherWires.size === codeWires.size &&
                                [...codeWires].every(id => otherWires.has(id))) {
                                pairedCode = other;
                                break;
                            }
                        }
                    }

                    if (pairedCode) {
                        solderPairs.push({
                            type: 'solder',
                            ch: isHigh ? code : pairedCode,
                            cl: isHigh ? pairedCode : code
                        });
                        solderPairedSet.add(code);
                        solderPairedSet.add(pairedCode);
                    } else {
                        solderPairs.push({
                            type: 'solder',
                            ch: isHigh ? code : null,
                            cl: isHigh ? null : code
                        });
                        solderPairedSet.add(code);
                    }
                }

                // ============ ç¬¬äºŒæ­¥ï¼šæ‰¾å‡ºæ‰€æœ‰inlineå¯¹ï¼ˆCH-CLé…å¯¹ï¼‰============
                const inlineArray = Array.from(inlineSet);

                // æ„å»ºinlineèŠ‚ç‚¹çš„ä¿¡å·ç±»å‹æ˜ å°„
                const inlineSignals = new Map();
                canTypeGroup.circuits.forEach(circuit => {
                    if (circuit.isFromInline && circuit.fromCode) {
                        if (!inlineSignals.has(circuit.fromCode)) inlineSignals.set(circuit.fromCode, new Set());
                        inlineSignals.get(circuit.fromCode).add(circuit.signalType);
                    }
                    if (circuit.isToInline && circuit.toCode) {
                        if (!inlineSignals.has(circuit.toCode)) inlineSignals.set(circuit.toCode, new Set());
                        inlineSignals.get(circuit.toCode).add(circuit.signalType);
                    }
                });

                // æ„å»ºinline -> Wire ID é›†åˆçš„æ˜ å°„
                const inlineWires = new Map();
                canTypeGroup.circuits.forEach(circuit => {
                    if (circuit.isFromInline && circuit.fromCode) {
                        if (!inlineWires.has(circuit.fromCode)) inlineWires.set(circuit.fromCode, new Set());
                        inlineWires.get(circuit.fromCode).add(circuit.wireId);
                    }
                    if (circuit.isToInline && circuit.toCode) {
                        if (!inlineWires.has(circuit.toCode)) inlineWires.set(circuit.toCode, new Set());
                        inlineWires.get(circuit.toCode).add(circuit.wireId);
                    }
                });

                const inlinePairs = [];
                const inlinePairedSet = new Set();

                for (const code of inlineArray) {
                    if (inlinePairedSet.has(code)) continue;

                    const codeWires = inlineWires.get(code) || new Set();
                    const codeSignals = inlineSignals.get(code);
                    const isHigh = codeSignals && codeSignals.has('CAN High');
                    const isLow = codeSignals && codeSignals.has('CAN Low');

                    // æ‰¾é…å¯¹inlineèŠ‚ç‚¹
                    let pairedCode = null;
                    for (const other of inlineArray) {
                        if (other === code || inlinePairedSet.has(other)) continue;

                        const otherSignals = inlineSignals.get(other);
                        const otherIsHigh = otherSignals && otherSignals.has('CAN High');
                        const otherIsLow = otherSignals && otherSignals.has('CAN Low');

                        if (isHigh && otherIsLow) {
                            const otherWires = inlineWires.get(other) || new Set();
                            // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒçš„wire IDé›†åˆ
                            if (otherWires.size === codeWires.size &&
                                [...codeWires].every(id => otherWires.has(id))) {
                                pairedCode = other;
                                break;
                            }
                        } else if (isLow && otherIsHigh) {
                            const otherWires = inlineWires.get(other) || new Set();
                            if (otherWires.size === codeWires.size &&
                                [...codeWires].every(id => otherWires.has(id))) {
                                pairedCode = other;
                                break;
                            }
                        }
                    }

                    if (pairedCode) {
                        inlinePairs.push({
                            type: 'inline',
                            ch: isHigh ? code : pairedCode,
                            cl: isHigh ? pairedCode : code
                        });
                        inlinePairedSet.add(code);
                        inlinePairedSet.add(pairedCode);
                    } else {
                        inlinePairs.push({
                            type: 'inline',
                            ch: isHigh ? code : null,
                            cl: isHigh ? null : code
                        });
                        inlinePairedSet.add(code);
                    }
                }

                // ============ ç¬¬ä¸‰æ­¥ï¼šåˆå¹¶æ‰€æœ‰èŠ‚ç‚¹å¯¹å¹¶ä¼˜åŒ–æ’åº ============
                const allNodePairs = [...solderPairs, ...inlinePairs];

                if (allNodePairs.length === 0) return { solderPairs, inlinePairs, allNodePairs };

                // æ„å»ºèŠ‚ç‚¹å¯¹ä¹‹é—´çš„è¿æ¥æƒé‡å›¾
                const weights = new Map(); // (i,j) -> connection weight

                for (let i = 0; i < allNodePairs.length; i++) {
                    for (let j = i + 1; j < allNodePairs.length; j++) {
                        const pairA = allNodePairs[i];
                        const pairB = allNodePairs[j];

                        let weight = 0;

                        // æ£€æŸ¥å„ç§è¿æ¥æƒ…å†µ
                        for (const circuit of canTypeGroup.circuits) {
                            const fromIsSolder = circuit.isFromSolder;
                            const toIsSolder = circuit.isToSolder;
                            const fromIsInline = circuit.isFromInline;
                            const toIsInline = circuit.isToInline;

                            // ç„Šç‚¹åˆ°ç„Šç‚¹çš„è¿æ¥
                            if (fromIsSolder && toIsSolder && circuit.fromCode && circuit.toCode) {
                                const fromInA = (pairA.type === 'solder') && (pairA.ch === circuit.fromCode || pairA.cl === circuit.fromCode);
                                const toInB = (pairB.type === 'solder') && (pairB.ch === circuit.toCode || pairB.cl === circuit.toCode);
                                const fromInB = (pairB.type === 'solder') && (pairB.ch === circuit.fromCode || pairB.cl === circuit.fromCode);
                                const toInA = (pairA.type === 'solder') && (pairA.ch === circuit.toCode || pairA.cl === circuit.toCode);

                                if (fromInA && toInB) weight += 2;
                                if (fromInB && toInA) weight += 2;
                            }

                            // Inlineåˆ°Inlineçš„è¿æ¥
                            if (fromIsInline && toIsInline && circuit.fromCode && circuit.toCode) {
                                const fromInA = (pairA.type === 'inline') && (pairA.ch === circuit.fromCode || pairA.cl === circuit.fromCode);
                                const toInB = (pairB.type === 'inline') && (pairB.ch === circuit.toCode || pairB.cl === circuit.toCode);
                                const fromInB = (pairB.type === 'inline') && (pairB.ch === circuit.fromCode || pairB.cl === circuit.fromCode);
                                const toInA = (pairA.type === 'inline') && (pairA.ch === circuit.toCode || pairA.cl === circuit.toCode);

                                if (fromInA && toInB) weight += 2;
                                if (fromInB && toInA) weight += 2;
                            }

                            // ç„Šç‚¹åˆ°Inlineçš„è¿æ¥
                            if (fromIsSolder && toIsInline && circuit.fromCode && circuit.toCode) {
                                const fromInA = (pairA.type === 'solder') && (pairA.ch === circuit.fromCode || pairA.cl === circuit.fromCode);
                                const toInB = (pairB.type === 'inline') && (pairB.ch === circuit.toCode || pairB.cl === circuit.toCode);
                                const fromInB = (pairB.type === 'solder') && (pairB.ch === circuit.fromCode || pairB.cl === circuit.fromCode);
                                const toInA = (pairA.type === 'inline') && (pairA.ch === circuit.toCode || pairA.cl === circuit.toCode);

                                if (fromInA && toInB) weight += 2;
                                if (fromInB && toInA) weight += 2;
                            }

                            // Inlineåˆ°ç„Šç‚¹çš„è¿æ¥
                            if (fromIsInline && toIsSolder && circuit.fromCode && circuit.toCode) {
                                const fromInA = (pairA.type === 'inline') && (pairA.ch === circuit.fromCode || pairA.cl === circuit.fromCode);
                                const toInB = (pairB.type === 'solder') && (pairB.ch === circuit.toCode || pairB.cl === circuit.toCode);
                                const fromInB = (pairB.type === 'inline') && (pairB.ch === circuit.fromCode || pairB.cl === circuit.fromCode);
                                const toInA = (pairA.type === 'solder') && (pairA.ch === circuit.toCode || pairA.cl === circuit.toCode);

                                if (fromInA && toInB) weight += 2;
                                if (fromInB && toInA) weight += 2;
                            }
                        }

                        if (weight > 0) {
                            weights.set(`${i},${j}`, weight);
                            weights.set(`${j},${i}`, weight);
                        }
                    }
                }

                // ä½¿ç”¨è´ªå¿ƒç®—æ³•æ’åº
                const sortedNodePairs = [];
                const used = new Set();

                // æ‰¾åˆ°è¿æ¥æœ€å¼ºçš„èµ·å§‹èŠ‚ç‚¹
                let startIdx = 0;
                let maxTotalWeight = -1;
                for (let i = 0; i < allNodePairs.length; i++) {
                    let totalWeight = 0;
                    for (let j = 0; j < allNodePairs.length; j++) {
                        if (i !== j) {
                            totalWeight += weights.get(`${i},${j}`) || 0;
                        }
                    }
                    if (totalWeight > maxTotalWeight) {
                        maxTotalWeight = totalWeight;
                        startIdx = i;
                    }
                }

                sortedNodePairs.push(allNodePairs[startIdx]);
                used.add(startIdx);

                // è´ªå¿ƒåœ°æ·»åŠ èŠ‚ç‚¹
                while (sortedNodePairs.length < allNodePairs.length) {
                    let bestIdx = -1;
                    let maxWeight = -1;

                    for (let i = 0; i < allNodePairs.length; i++) {
                        if (used.has(i)) continue;

                        let totalWeight = 0;
                        for (const usedIdx of used) {
                            totalWeight += weights.get(`${i},${usedIdx}`) || 0;
                        }

                        if (totalWeight > maxWeight) {
                            maxWeight = totalWeight;
                            bestIdx = i;
                        }
                    }

                    if (bestIdx === -1) {
                        for (let i = 0; i < allNodePairs.length; i++) {
                            if (!used.has(i)) {
                                bestIdx = i;
                                break;
                            }
                        }
                    }

                    if (bestIdx !== -1) {
                        sortedNodePairs.push(allNodePairs[bestIdx]);
                        used.add(bestIdx);
                    }
                }

                return { solderPairs, inlinePairs, allNodePairs: sortedNodePairs };
            }

            const { solderPairs, inlinePairs, allNodePairs } = buildAndSortNodePairs();

            // ========== æŒ‰è¿æ¥é¡ºåºè¿›è¡Œæ¨ªå‘å¹¶è¡Œå¸ƒå±€ ==========
            // æ„å»ºå®Œæ•´çš„èŠ‚ç‚¹è¿æ¥å›¾ï¼ˆç„Šç‚¹ + inlineï¼‰
            const nodeGraph = new Map(); // node -> connected nodes
            const nodeTypes = new Map(); // node -> 'solder' or 'inline'
            const nodeToSignal = new Map(); // node -> 'CH' or 'CL' or 'both'

            // åˆå§‹åŒ–èŠ‚ç‚¹
            solderSet.forEach(code => {
                nodeGraph.set(code, new Set());
                nodeTypes.set(code, 'solder');
            });
            inlineSet.forEach(code => {
                nodeGraph.set(code, new Set());
                nodeTypes.set(code, 'inline');
            });

            // æ„å»ºè¿æ¥å…³ç³»
            canTypeGroup.circuits.forEach(circuit => {
                const from = circuit.isFromSolder ? circuit.fromCode :
                            circuit.isFromInline ? circuit.fromCode : null;
                const to = circuit.isToSolder ? circuit.toCode :
                          circuit.isToInline ? circuit.toCode : null;

                if (from && to && from !== to) {
                    nodeGraph.get(from)?.add(to);
                    nodeGraph.get(to)?.add(from);
                }

                // è®°å½•èŠ‚ç‚¹ä¿¡å·ç±»å‹
                if (circuit.isFromSolder && circuit.fromCode) {
                    const sig = nodeToSignal.get(circuit.fromCode) || new Set();
                    sig.add(circuit.signalType);
                    nodeToSignal.set(circuit.fromCode, sig);
                }
                if (circuit.isToSolder && circuit.toCode) {
                    const sig = nodeToSignal.get(circuit.toCode) || new Set();
                    sig.add(circuit.signalType);
                    nodeToSignal.set(circuit.toCode, sig);
                }
            });

            // ä½¿ç”¨BFSæŒ‰è¿æ¥é¡ºåºéå†èŠ‚ç‚¹
            function getNodeOrder(graph, allNodes) {
                const visited = new Set();
                const order = [];
                const queue = [];

                // æ‰¾åˆ°èµ·å§‹èŠ‚ç‚¹ï¼ˆè¿æ¥æ•°æœ€å°‘æˆ–åŒ…å«è¯Šæ–­å£ï¼‰
                let startNode = null;
                let minConn = Infinity;
                for (const node of allNodes) {
                    const conns = graph.get(node)?.size || 0;
                    // ä¼˜å…ˆé€‰æ‹©è¿æ¥æ•°å°‘çš„ä½œä¸ºèµ·å§‹ç‚¹
                    if (conns < minConn) {
                        minConn = conns;
                        startNode = node;
                    }
                }

                if (startNode) {
                    queue.push(startNode);
                    visited.add(startNode);
                }

                while (queue.length > 0) {
                    const node = queue.shift();
                    order.push(node);

                    const neighbors = graph.get(node) || new Set();
                    for (const neighbor of neighbors) {
                        if (!visited.has(neighbor)) {
                            visited.add(neighbor);
                            queue.push(neighbor);
                        }
                    }
                }

                // æ·»åŠ æœªè®¿é—®çš„èŠ‚ç‚¹
                for (const node of allNodes) {
                    if (!visited.has(node)) {
                        order.push(node);
                    }
                }

                return order;
            }

            const nodeOrder = getNodeOrder(nodeGraph, new Set([...solderSet, ...inlineSet]));

            // æ”¾ç½®èŠ‚ç‚¹ï¼šæŒ‰è¿æ¥é¡ºåºæ¨ªå‘æ’åˆ—ï¼Œå…è®¸ä¸Šä¸‹å¹¶è”
            const nodePositionsMap = new Map(); // node -> {x, y, offset: 0 or 1}
            const parallelOffsetY = 60; // å¹¶è”èŠ‚ç‚¹é—´çš„Yåç§»

            // ç»Ÿä¸€æ”¾ç½®æ‰€æœ‰èŠ‚ç‚¹å¯¹ï¼ˆç„Šç‚¹å¯¹å’Œinlineå¯¹ï¼‰
            allNodePairs.forEach((pair, index) => {
                const baseX = marginX + index * horizontalSpacing;
                const baseY = busY;

                if (pair.type === 'solder') {
                    // æ”¾ç½®ç„Šç‚¹å¯¹
                    if (pair.ch) {
                        const x = baseX;
                        const y = baseY - 50;
                        solderPositions.set(pair.ch, { x, y, code: pair.ch });
                        nodePositions.set(pair.ch, { x, y, type: 'splice', code: pair.ch });
                        nodePositionsMap.set(pair.ch, { x, y, offset: 0 });
                        console.log(`[å¸ƒå±€] ${pair.ch}: x=${x.toFixed(0)}, y=${y.toFixed(0)} [SOLDER-CH-ä¸Š]`);
                    }
                    if (pair.cl) {
                        const x = baseX;
                        const y = baseY + 50;
                        solderPositions.set(pair.cl, { x, y, code: pair.cl });
                        nodePositions.set(pair.cl, { x, y, type: 'splice', code: pair.cl });
                        nodePositionsMap.set(pair.cl, { x, y, offset: 1 });
                        console.log(`[å¸ƒå±€] ${pair.cl}: x=${x.toFixed(0)}, y=${y.toFixed(0)} [SOLDER-CL-ä¸‹]`);
                    }
                } else if (pair.type === 'inline') {
                    // æ”¾ç½®inlineå¯¹ï¼ˆCHå’ŒCLå·¦å³ç´§æŒ¨ç€ï¼‰
                    const centerX = baseX;
                    const centerY = baseY;
                    const inlineSpacing = 40; // inlineå¯¹ä¸­ä¸¤ä¸ªèŠ‚ç‚¹çš„é—´è·

                    // å°†inlineå¯¹ä½œä¸ºä¸€ä¸ªæ•´ä½“å­˜å‚¨ï¼Œä½¿ç”¨leftCodeä½œä¸ºä¸»é”®
                    const leftCode = pair.ch || pair.cl;
                    const rightCode = pair.cl || pair.ch;

                    inlinePositions.set(leftCode, {
                        x: centerX,
                        y: centerY,
                        code: leftCode,
                        leftCode: leftCode,
                        rightCode: rightCode,
                        pair: rightCode
                    });

                    // åˆ†åˆ«å­˜å‚¨CHå’ŒCLçš„ä½ç½®ï¼ˆå·¦å³æ’åˆ—ï¼‰
                    if (pair.ch) {
                        const chX = centerX - inlineSpacing / 2;
                        nodePositions.set(pair.ch, { x: chX, y: centerY, type: 'inline', code: pair.ch });
                        nodePositionsMap.set(pair.ch, { x: chX, y: centerY, offset: 0 });
                        console.log(`[å¸ƒå±€] ${pair.ch}: x=${chX.toFixed(0)}, y=${centerY.toFixed(0)} [INLINE-CH-å·¦]`);
                    }
                    if (pair.cl) {
                        const clX = centerX + inlineSpacing / 2;
                        nodePositions.set(pair.cl, { x: clX, y: centerY, type: 'inline', code: pair.cl });
                        nodePositionsMap.set(pair.cl, { x: clX, y: centerY, offset: 1 });
                        console.log(`[å¸ƒå±€] ${pair.cl}: x=${clX.toFixed(0)}, y=${centerY.toFixed(0)} [INLINE-CL-å³]`);
                    }
                }
            });

            const ecuToBackbone = new Map();

            canTypeGroup.circuits.forEach(circuit => {
                if (circuit.isFromConnector && circuit.isToSolder) {
                    if (!ecuToBackbone.has(circuit.fromCode)) ecuToBackbone.set(circuit.fromCode, new Set());
                    ecuToBackbone.get(circuit.fromCode).add({ backbone: circuit.toCode, signal: circuit.signalType });
                } else if (circuit.isToConnector && circuit.isFromSolder) {
                    if (!ecuToBackbone.has(circuit.toCode)) ecuToBackbone.set(circuit.toCode, new Set());
                    ecuToBackbone.get(circuit.toCode).add({ backbone: circuit.fromCode, signal: circuit.signalType });
                } else if (circuit.isFromConnector && circuit.isToInline) {
                    if (!ecuToBackbone.has(circuit.fromCode)) ecuToBackbone.set(circuit.fromCode, new Set());
                    ecuToBackbone.get(circuit.fromCode).add({ backbone: circuit.toCode, signal: circuit.signalType });
                } else if (circuit.isToConnector && circuit.isFromInline) {
                    if (!ecuToBackbone.has(circuit.toCode)) ecuToBackbone.set(circuit.toCode, new Set());
                    ecuToBackbone.get(circuit.toCode).add({ backbone: circuit.fromCode, signal: circuit.signalType });
                }
            });

            const backboneToECUs = new Map();
            ecuToBackbone.forEach((backbones, ecuCode) => {
                backbones.forEach(b => {
                    if (!backboneToECUs.has(b.backbone)) backboneToECUs.set(b.backbone, []);
                    backboneToECUs.get(b.backbone).push({ ecu: ecuCode, signal: b.signal });
                });
            });

            // ä¸ºæ¯å¯¹ç„Šç‚¹å»ºç«‹è¿æ¥åˆ°ECUçš„æ˜ å°„
            const pairToECUs = new Map();
            solderPairs.forEach((pair, pairIdx) => {
                const pairCenterX = marginX + pairIdx * horizontalSpacing;
                const pairCenterY = busY;  // ç„Šç‚¹å¯¹çš„ä¸­å¿ƒYä½ç½®

                canTypeGroup.circuits.forEach(circuit => {
                    if (circuit.isFromConnector) {
                        // æ’ä»¶è¿æ¥åˆ°ç„Šç‚¹
                        let solderCode = null;
                        if (circuit.isToSolder) solderCode = circuit.toCode;
                        else if (circuit.isToInline) {
                            // é€šè¿‡Inlineæ‰¾åˆ°ç„Šç‚¹
                            const inlineNode = canTypeGroup.inlineNodes.get(circuit.toCode);
                            if (inlineNode) solderCode = inlineNode.pair || circuit.toCode;
                        }

                        if (solderCode) {
                            // æ‰¾åˆ°è¿™å¯¹ç„Šç‚¹
                            let foundPair = null;
                            for (const p of solderPairs) {
                                if (p.ch === solderCode || p.cl === solderCode) {
                                    foundPair = p;
                                    break;
                                }
                            }
                            if (foundPair) {
                                if (!pairToECUs.has(foundPair)) pairToECUs.set(foundPair, []);
                                pairToECUs.get(foundPair).push({
                                    ecu: circuit.fromCode,
                                    signal: circuit.signalType,
                                    pin: circuit.fromPin
                                });
                            }
                        }
                    }
                });
            });

            // ä¸ºæ¯å¯¹ç„Šç‚¹æ”¾ç½®æ’ä»¶ï¼ˆä¿è¯çº¿æ˜¯ç«–ç›´çš„ï¼‰
            solderPairs.forEach((pair, pairIdx) => {
                const pairCenterX = marginX + pairIdx * horizontalSpacing;
                const pairCenterY = busY;  // ç„Šç‚¹å¯¹çš„ä¸­å¿ƒYä½ç½®

                const ecuConnections = pairToECUs.get(pair) || [];

                // CANH æ’ä»¶ä½ç½®ï¼šç›´æ¥åœ¨ CH ç„Šç‚¹ä¸‹æ–¹ 300
                if (pair.ch) {
                    const chPos = solderPositions.get(pair.ch);
                    if (chPos) {
                        const ecuInfo = ecuConnections.find(e => e.signal === 'CAN High');
                        if (ecuInfo) {
                            connectorPositions.set(ecuInfo.ecu, {
                                x: chPos.x,
                                y: chPos.y + pluginDistanceFromSolder,  // æ’ä»¶åœ¨ CH ç„Šç‚¹ä¸‹æ–¹
                                signal: 'CAN High'
                            });
                            nodePositions.set(ecuInfo.ecu, {
                                x: chPos.x,
                                y: chPos.y + pluginDistanceFromSolder,
                                type: 'ecu',
                                code: ecuInfo.ecu,
                                signal: 'CAN High'
                            });
                            console.log(`[å¸ƒå±€] æ’ä»¶ ${ecuInfo.ecu}: x=${chPos.x.toFixed(0)}, y=${(chPos.y + pluginDistanceFromSolder).toFixed(0)} (CHç„Šç‚¹ä¸‹æ–¹${pluginDistanceFromSolder})`);
                        }
                    }
                }

                // CANL æ’ä»¶ä½ç½®ï¼šç›´æ¥åœ¨ CL ç„Šç‚¹ä¸‹æ–¹ 300
                if (pair.cl) {
                    const clPos = solderPositions.get(pair.cl);
                    if (clPos) {
                        const ecuInfo = ecuConnections.find(e => e.signal === 'CAN Low');
                        if (ecuInfo) {
                            connectorPositions.set(ecuInfo.ecu, {
                                x: clPos.x,
                                y: clPos.y + pluginDistanceFromSolder,  // æ’ä»¶åœ¨ CL ç„Šç‚¹ä¸‹æ–¹
                                signal: 'CAN Low'
                            });
                            nodePositions.set(ecuInfo.ecu, {
                                x: clPos.x,
                                y: clPos.y + pluginDistanceFromSolder,
                                type: 'ecu',
                                code: ecuInfo.ecu,
                                signal: 'CAN Low'
                            });
                            console.log(`[å¸ƒå±€] æ’ä»¶ ${ecuInfo.ecu}: x=${clPos.x.toFixed(0)}, y=${(clPos.y + pluginDistanceFromSolder).toFixed(0)} (CLç„Šç‚¹ä¸‹æ–¹${pluginDistanceFromSolder})`);
                        }
                    }
                }
            });

            // å‰©ä½™çš„ECUä½ç½®ï¼ˆæœªé…å¯¹çš„ï¼‰
            backboneToECUs.forEach((ecus, backboneCode) => {
                const backbonePos = nodePositions.get(backboneCode);
                if (!backbonePos) return;

                const topECUs = ecus.filter((e, i) => i % 2 === 0);
                const bottomECUs = ecus.filter((e, i) => i % 2 === 1);

                topECUs.forEach((ecuInfo, idx) => {
                    const y = backbonePos.y - verticalSpacing;
                    const xOffset = idx * 50;
                    const x = backbonePos.x + xOffset;
                    connectorPositions.set(ecuInfo.ecu, { x, y, signal: ecuInfo.signal });
                    nodePositions.set(ecuInfo.ecu, { x, y, type: 'ecu', code: ecuInfo.ecu, signal: ecuInfo.signal });
                });

                bottomECUs.forEach((ecuInfo, idx) => {
                    const y = backbonePos.y + verticalSpacing;
                    const xOffset = idx * 50;
                    const x = backbonePos.x + xOffset;
                    connectorPositions.set(ecuInfo.ecu, { x, y, signal: ecuInfo.signal });
                    nodePositions.set(ecuInfo.ecu, { x, y, type: 'ecu', code: ecuInfo.ecu, signal: ecuInfo.signal });
                });
            });

            // V7: ä¸ºæ²¡æœ‰ç„Šç‚¹çš„CANç±»å‹ï¼ˆå¦‚BF CANï¼‰è®¾ç½®è¿æ¥å™¨ä½ç½®
            if (connectorPositions.size === 0 && canTypeGroup.connectors && canTypeGroup.connectors.size > 0) {
                console.log('[å¸ƒå±€] V7: æ²¡æœ‰ç„Šç‚¹çš„CANç±»å‹ï¼Œä¸ºè¿æ¥å™¨è®¾ç½®é»˜è®¤ä½ç½®');
                const connectorArray = Array.from(canTypeGroup.connectors.keys());
                const connectorCount = connectorArray.length;
                const startX = marginX + 200;
                const spacing = 150;

                connectorArray.forEach((code, idx) => {
                    const x = startX + idx * spacing;
                    const y = busY;
                    connectorPositions.set(code, { x, y, signal: 'both' });
                    nodePositions.set(code, { x, y, type: 'ecu', code, signal: 'both' });
                    console.log(`[å¸ƒå±€] V7 æ’ä»¶ ${code}: x=${x}, y=${y}`);
                });
            }

            return {
                nodePositions,
                inlinePositions,
                solderPositions,
                connectorPositions,
                connectorPinPositions,
                allCircuits: canTypeGroup.circuits,
                busY,
                mainPath: solderPairs.map(p => p.ch || p.cl),
                solderPairs: solderPairs
            };
        }

        // å‡†å¤‡æ‹“æ‰‘æ•°æ®
        function prepareTopologyData(layout, canTypeGroup) {
            const nodes = [];
            const pins = [];
            const wires = [];

            layout.solderPositions.forEach((pos, code) => {
                nodes.push({
                    id: code,
                    type: 'splice',
                    x: pos.x,
                    y: pos.y,
                    label: code
                });
            });

            // ä¸ºinlineå¯¹çš„ä¸¤ä¸ªèŠ‚ç‚¹ï¼ˆCHå’ŒCLï¼‰åˆ†åˆ«åˆ›å»ºèŠ‚ç‚¹
            layout.inlinePositions.forEach((pos, code) => {
                if (code !== pos.leftCode) return;

                // ä¸ºCHèŠ‚ç‚¹ï¼ˆå·¦èŠ‚ç‚¹ï¼‰åˆ›å»ºæ˜¾ç¤ºèŠ‚ç‚¹
                if (pos.leftCode) {
                    const chPos = layout.nodePositions?.get(pos.leftCode);
                    // å®‰å…¨è®¡ç®—CHä½ç½®
                    let chX = isFinite(chPos?.x) ? chPos.x : (isFinite(pos.x) ? pos.x - 25 : 0);
                    let chY = isFinite(chPos?.y) ? chPos.y : (isFinite(pos.y) ? pos.y : busY);
                    nodes.push({
                        id: pos.leftCode,
                        type: 'splice',
                        x: chX,
                        y: chY,
                        label: pos.leftCode,
                        inlineNode: true
                    });
                }

                // ä¸ºCLèŠ‚ç‚¹ï¼ˆå³èŠ‚ç‚¹ï¼‰åˆ›å»ºæ˜¾ç¤ºèŠ‚ç‚¹ï¼ˆä»…å½“rightCodeä¸åŒäºleftCodeæ—¶ï¼‰
                if (pos.rightCode && pos.rightCode !== pos.leftCode) {
                    const clPos = layout.nodePositions?.get(pos.rightCode);
                    // å®‰å…¨è®¡ç®—CLä½ç½®
                    let clX = isFinite(clPos?.x) ? clPos.x : (isFinite(pos.x) ? pos.x + 25 : 50);
                    let clY = isFinite(clPos?.y) ? clPos.y : (isFinite(pos.y) ? pos.y : busY);
                    nodes.push({
                        id: pos.rightCode,
                        type: 'splice',
                        x: clX,
                        y: clY,
                        label: pos.rightCode,
                        inlineNode: true
                    });
                }
            });

            const pinOffsetX = 25;
            const pinOffsetY = 12;

            layout.inlinePositions.forEach((pos, code) => {
                if (code !== pos.leftCode) return;

                const leftInlineData = canTypeGroup.inlineNodes.get(pos.leftCode);
                const rightInlineData = canTypeGroup.inlineNodes.get(pos.rightCode);

                if (leftInlineData && leftInlineData.pins) {
                    const verticalOffset = 15;

                    leftInlineData.pins.forEach((pinList, signalType) => {
                        const isCanHigh = signalType === 'CAN High';
                        const yOffset = isCanHigh ? -verticalOffset : verticalOffset;

                        pinList.forEach((pin, index) => {
                            const pinId = `${pos.leftCode}_${pin}_${signalType}`;
                            const pinX = pos.x - pinOffsetX;
                            const pinY = pos.y + yOffset + (index - (pinList.length - 1) / 2) * pinOffsetY;

                            pins.push({
                                id: pinId,
                                inlineCode: pos.leftCode,
                                pin: pin,
                                signalType: signalType,
                                x: pinX,
                                y: pinY,
                                type: 'inline-pin',
                                side: 'left'
                            });
                        });
                    });
                }

                if (rightInlineData && rightInlineData.pins) {
                    const verticalOffset = 15;

                    rightInlineData.pins.forEach((pinList, signalType) => {
                        const isCanHigh = signalType === 'CAN High';
                        const yOffset = isCanHigh ? -verticalOffset : verticalOffset;

                        pinList.forEach((pin, index) => {
                            const pinId = `${pos.rightCode}_${pin}_${signalType}`;
                            const pinX = pos.x + pinOffsetX;
                            const pinY = pos.y + yOffset + (index - (pinList.length - 1) / 2) * pinOffsetY;

                            pins.push({
                                id: pinId,
                                inlineCode: pos.rightCode,
                                pin: pin,
                                signalType: signalType,
                                x: pinX,
                                y: pinY,
                                type: 'inline-pin',
                                side: 'right'
                            });
                        });
                    });
                }
            });

            layout.connectorPositions.forEach((pos, code) => {
                const connectorData = canTypeGroup.connectors.get(code);
                if (!connectorData) return;

                const connectorParts = code.split('-');
                const connectorName = connectorParts[0] || code;
                const connectorSuffix = connectorParts.length > 1 ? `(${connectorParts[1]})` : '(A)';

                const allPins = [];
                connectorData.pins.forEach((pinList, signalType) => {
                    pinList.forEach(pin => {
                        allPins.push(pin);
                    });
                });

                nodes.push({
                    id: code,
                    type: 'ecu',
                    x: pos.x,
                    y: pos.y,
                    label: connectorName,
                    connector: connectorSuffix,
                    pins: `PIN ${allPins.join(', ')}`,
                    pinList: connectorData.pins
                });

                const pinOffsetX = 50;
                const pinOffsetY = 12;
                const pinDistanceFromSolderHigh = 600;  // CANH PINè·ç„Šç‚¹çš„è·ç¦»ï¼ˆä¸‹æ–¹ï¼‰
                const pinDistanceFromSolderLow = 700;   // CANL PINè·ç„Šç‚¹çš„è·ç¦»ï¼ˆä¸‹æ–¹ï¼‰

                connectorData.pins.forEach((pinList, signalType) => {
                    pinList.forEach((pin, index) => {
                        const isHigh = signalType === 'CAN High';
                        const pinId = `${code}_${pin}_${signalType}`;

                        let pinX, pinY;

                        // V7: å¦‚æœæ²¡æœ‰ç„Šç‚¹ï¼Œä½¿ç”¨è¿æ¥å™¨ä½ç½®ä½œä¸ºå‚è€ƒ
                        const connectorPos = layout.connectorPositions.get(code);
                        const defaultX = connectorPos ? connectorPos.x : (code.charCodeAt(0) * 10);
                        const defaultY = connectorPos ? connectorPos.y : 400;

                        if (isHigh) {
                            // CANH PINï¼šæ”¾åœ¨ CANH ç„Šç‚¹æ­£ä¸‹æ–¹ 300
                            const chSolderPos = layout.solderPositions.get(`${code}_CH`) ||
                                               layout.solderPositions.get(code.replace(/_?CL$/i, '').replace(/_?LOW$/i, ''));
                            if (chSolderPos) {
                                pinX = chSolderPos.x;
                                pinY = chSolderPos.y + pinDistanceFromSolderHigh;
                            } else {
                                // V7: æ²¡æœ‰ç„Šç‚¹æ—¶ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
                                pinX = defaultX - pinOffsetX;
                                pinY = defaultY + (index - (pinList.length - 1) / 2) * pinOffsetY;
                            }
                        } else {
                            // CANL PINï¼šæ”¾åœ¨ CANL ç„Šç‚¹æ­£ä¸‹æ–¹ 400
                            const clSolderPos = layout.solderPositions.get(`${code}_CL`) ||
                                               layout.solderPositions.get(code.replace(/_?CH$/i, '').replace(/_?HIGH$/i, ''));
                            if (clSolderPos) {
                                pinX = clSolderPos.x;
                                pinY = clSolderPos.y + pinDistanceFromSolderLow;
                            } else {
                                // V7: æ²¡æœ‰ç„Šç‚¹æ—¶ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
                                pinX = defaultX + pinOffsetX;
                                pinY = defaultY + (index - (pinList.length - 1) / 2) * pinOffsetY;
                            }
                        }

                        pins.push({
                            id: pinId,
                            connectorCode: code,
                            pin: pin,
                            signalType: signalType,
                            x: pinX,
                            y: pinY,
                            type: 'pin'
                        });
                    });
                });
            });

            canTypeGroup.circuits.forEach(circuit => {
                const wire = {
                    wireId: circuit.wireId,
                    signalType: circuit.signalType,
                    multicoreId: circuit.multicoreId,
                    circuitType: circuit.circuitType,
                    fromCode: circuit.fromCode,
                    toCode: circuit.toCode,
                    fromPin: circuit.fromPin,
                    toPin: circuit.toPin
                };

                if (circuit.isFromConnector) {
                    const pinId = `${circuit.fromCode}_${circuit.fromPin}_${circuit.signalType}`;
                    const pinNode = pins.find(p => p.id === pinId);
                    if (pinNode) {
                        wire.fromX = pinNode.x;
                        wire.fromY = pinNode.y;
                        wire.fromType = 'pin';
                        wire.fromId = pinId;
                    }
                } else if (circuit.isFromSolder) {
                    const solderPos = layout.solderPositions.get(circuit.fromCode) || layout.nodePositions?.get(circuit.fromCode);
                    if (solderPos) {
                        wire.fromX = solderPos.x;
                        wire.fromY = solderPos.y;
                        wire.fromType = 'splice';
                        wire.fromId = circuit.fromCode;
                    }
                } else if (circuit.isFromInline) {
                    const pinId = `${circuit.fromCode}_${circuit.fromPin}_${circuit.signalType}`;
                    const pinNode = pins.find(p => p.id === pinId);
                    if (pinNode) {
                        wire.fromX = pinNode.x;
                        wire.fromY = pinNode.y;
                        wire.fromType = 'inline-pin';
                        wire.fromId = pinId;
                    } else {
                        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°pinï¼Œå°è¯•ç›´æ¥ä½¿ç”¨inlineèŠ‚ç‚¹ä½ç½®
                        const inlinePos = layout.nodePositions?.get(circuit.fromCode);
                        if (inlinePos) {
                            wire.fromX = inlinePos.x;
                            wire.fromY = inlinePos.y;
                            wire.fromType = 'splice';
                            wire.fromId = circuit.fromCode;
                        }
                    }
                }

                if (circuit.isToConnector) {
                    const pinId = `${circuit.toCode}_${circuit.toPin}_${circuit.signalType}`;
                    const pinNode = pins.find(p => p.id === pinId);
                    if (pinNode) {
                        wire.toX = pinNode.x;
                        wire.toY = pinNode.y;
                        wire.toType = 'pin';
                        wire.toId = pinId;
                    }
                } else if (circuit.isToSolder) {
                    const solderPos = layout.solderPositions.get(circuit.toCode) || layout.nodePositions?.get(circuit.toCode);
                    if (solderPos) {
                        wire.toX = solderPos.x;
                        wire.toY = solderPos.y;
                        wire.toType = 'splice';
                        wire.toId = circuit.toCode;
                    }
                } else if (circuit.isToInline) {
                    const pinId = `${circuit.toCode}_${circuit.toPin}_${circuit.signalType}`;
                    const pinNode = pins.find(p => p.id === pinId);
                    if (pinNode) {
                        wire.toX = pinNode.x;
                        wire.toY = pinNode.y;
                        wire.toType = 'inline-pin';
                        wire.toId = pinId;
                    } else {
                        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°pinï¼Œå°è¯•ç›´æ¥ä½¿ç”¨inlineèŠ‚ç‚¹ä½ç½®
                        const inlinePos = layout.nodePositions?.get(circuit.toCode);
                        if (inlinePos) {
                            wire.toX = inlinePos.x;
                            wire.toY = inlinePos.y;
                            wire.toType = 'splice';
                            wire.toId = circuit.toCode;
                        }
                    }
                }

                if (wire.fromX !== undefined && wire.toX !== undefined) {
                    wire.labelX = (wire.fromX + wire.toX) / 2;
                    wire.labelY = (wire.fromY + wire.toY) / 2;
                    wires.push(wire);
                } else {
                    // V7: è°ƒè¯•æœªæ·»åŠ çš„å›è·¯
                    console.log('[prepareTopologyData] å›è·¯æœªæ·»åŠ :', {
                        wireId: circuit.wireId,
                        fromCode: circuit.fromCode,
                        toCode: circuit.toCode,
                        fromPin: circuit.fromPin,
                        toPin: circuit.toPin,
                        isFromConnector: circuit.isFromConnector,
                        isToConnector: circuit.isToConnector,
                        fromX: wire.fromX,
                        toX: wire.toX,
                        connectorPositions: Array.from(layout.connectorPositions.keys())
                    });
                }
            });

            return { nodes, pins, wires, solderPairs: layout.solderPairs || [] };
        }

        // éªŒè¯åº“åŠ è½½
        window.addEventListener('load', function() {
            console.log('[åº“æ£€æŸ¥]', {
                XLSX: typeof XLSX !== 'undefined',
                ExcelJS: typeof ExcelJS !== 'undefined',
                saveAs: typeof saveAs !== 'undefined',
                d3: typeof d3 !== 'undefined'
            });

            if (typeof ExcelJS === 'undefined') {
                showMessage('âš ï¸ ExcelJSåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
            }
            if (typeof saveAs === 'undefined') {
                showMessage('âš ï¸ FileSaveråº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
            }
            if (typeof d3 === 'undefined') {
                showMessage('âš ï¸ D3.jsåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•', 'error');
            }
        });

        // ========== CANæ€»çº¿æ‹“æ‰‘ä¼˜åŒ–åˆ†æ (åŸºäºç”µè·¯æ‹“æ‰‘ç†è®º) ==========

        /**
         * CANæ€»çº¿æ‹“æ‰‘ç±»å‹å®šä¹‰ (å‚è€ƒç”µè·¯æ‹“æ‰‘ç†è®º)
         * - Linear/Bus: çº¿æ€§æ€»çº¿æ‹“æ‰‘ï¼Œæ‰€æœ‰èŠ‚ç‚¹ä¸²è”åœ¨ä¸»å¹²ä¸Š
         * - Star: æ˜Ÿå‹æ‹“æ‰‘ï¼Œæ‰€æœ‰èŠ‚ç‚¹è¿æ¥åˆ°ä¸­å¿ƒç‚¹ï¼ˆä¸æ¨èç”¨äºCANï¼‰
         * - Tree: æ ‘å‹æ‹“æ‰‘ï¼Œæ€»çº¿æ‹“æ‰‘çš„æ‰©å±•ï¼Œæœ‰åˆ†æ”¯
         * - Ring: ç¯å½¢æ‹“æ‰‘ï¼ŒèŠ‚ç‚¹å½¢æˆé—­åˆå›è·¯
         * - Mixed: æ··åˆæ‹“æ‰‘ï¼Œå¤šç§ç±»å‹çš„ç»„åˆ
         */
        const TOPOLOGY_TYPES = {
            LINEAR: { id: 'linear', name: 'çº¿æ€§æ€»çº¿æ‹“æ‰‘', icon: 'â”', recommended: true },
            STAR: { id: 'star', name: 'æ˜Ÿå‹æ‹“æ‰‘', icon: 'âœ¶', recommended: false },
            TREE: { id: 'tree', name: 'æ ‘å‹æ‹“æ‰‘', icon: 'â”œ', recommended: true },
            RING: { id: 'ring', name: 'ç¯å½¢æ‹“æ‰‘', icon: 'â—‹', recommended: false },
            MIXED: { id: 'mixed', name: 'æ··åˆæ‹“æ‰‘', icon: 'âŠ•', recommended: false }
        };

        /**
         * CANæ€»çº¿ä¼˜åŒ–å»ºè®®ç”Ÿæˆå™¨
         * åŸºäºç”µè·¯æ‹“æ‰‘æœ€ä½³å®è·µ:
         * - ç»ˆç«¯ç”µé˜»åº”åœ¨æ€»çº¿ä¸¤ç«¯ (120Î©)
         * - åˆ†æ”¯é•¿åº¦åº”å°½å¯èƒ½çŸ­ (<0.3m é«˜é€ŸCAN)
         * - é¿å…æ˜Ÿå‹è¿æ¥ï¼ˆä¼šå¯¼è‡´ä¿¡å·åå°„ï¼‰
         * - æ€»çº¿é•¿åº¦å’ŒèŠ‚ç‚¹æ•°æœ‰é™åˆ¶
         */
        function generateOptimizationReport(canTypeGroup) {
            const report = {
                topologyType: null,
                score: 0,
                issues: [],
                suggestions: [],
                metrics: {},
                recommendations: []
            };

            // 1. åˆ†ææ‹“æ‰‘ç»“æ„
            report.topologyType = analyzeTopologyType(canTypeGroup);

            // 2. è®¡ç®—æ‹“æ‰‘æŒ‡æ ‡
            report.metrics = calculateTopologyMetrics(canTypeGroup);

            // 3. æ£€æµ‹é—®é¢˜
            report.issues = detectTopologyIssues(canTypeGroup, report.metrics);

            // 4. ç”Ÿæˆä¼˜åŒ–å»ºè®®
            report.suggestions = generateSuggestions(report.issues, report.metrics, canTypeGroup);

            // 5. è®¡ç®—ä¼˜åŒ–è¯„åˆ†
            report.score = calculateOptimizationScore(report.issues, report.metrics);

            return report;
        }

        /**
         * åˆ†ææ‹“æ‰‘ç±»å‹
         */
        function analyzeTopologyType(canTypeGroup) {
            const circuits = canTypeGroup.circuits;
            const connectors = canTypeGroup.connectors;
            const solders = canTypeGroup.solders;
            const inlines = canTypeGroup.inlineNodes;

            const solderCount = solders.size;
            const inlineCount = inlines.size;
            const connectorCount = connectors.size;
            const circuitCount = circuits.length;

            // ç»Ÿè®¡å„ç§è¿æ¥ç±»å‹
            let solderToSolder = 0;
            let connectorToBus = 0;
            let connectorToConnector = 0;
            let busBranchCount = 0;

            circuits.forEach(c => {
                if ((c.isFromSolder && c.isToSolder) ||
                    (c.isFromInline && c.isToInline) ||
                    (c.isFromSolder && c.isToInline) ||
                    (c.isFromInline && c.isToSolder)) {
                    solderToSolder++;
                }
                if ((c.isFromConnector && (c.isToSolder || c.isToInline)) ||
                    (c.isToConnector && (c.isFromSolder || c.isFromInline))) {
                    connectorToBus++;
                    busBranchCount++;
                }
                if (c.isFromConnector && c.isToConnector) {
                    connectorToConnector++;
                }
            });

            // åˆ¤æ–­æ‹“æ‰‘ç±»å‹
            let topologyInfo;

            // çº¿æ€§æ€»çº¿: åªæœ‰ç„Šç‚¹-ç„Šç‚¹è¿æ¥ï¼Œæ‰€æœ‰ECUè¿æ¥åˆ°æ€»çº¿
            if (solderToSolder > 0 && busBranchCount > 0 && connectorToConnector === 0) {
                topologyInfo = {
                    ...TOPOLOGY_TYPES.LINEAR,
                    confidence: 0.9,
                    description: 'å…¸å‹çš„çº¿æ€§æ€»çº¿æ‹“æ‰‘ï¼ŒèŠ‚ç‚¹é€šè¿‡ç„Šç‚¹è¿æ¥åˆ°ä¸»å¹²çº¿'
                };
            }
            // æ ‘å‹: æœ‰å¤šä¸ªç„Šç‚¹å½¢æˆåˆ†æ”¯
            else if (solderCount > 2 && busBranchCount > 0) {
                topologyInfo = {
                    ...TOPOLOGY_TYPES.TREE,
                    confidence: 0.85,
                    description: 'æ ‘å‹æ‹“æ‰‘ï¼Œé€šè¿‡ç„Šç‚¹åˆ†æ”¯è¿æ¥å¤šä¸ªECU'
                };
            }
            // æ··åˆ: æ—¢æœ‰ä¸²è”ä¹Ÿæœ‰åˆ†æ”¯
            else if ((solderToSolder > 0 && connectorToConnector > 0) || inlineCount > 0) {
                topologyInfo = {
                    ...TOPOLOGY_TYPES.MIXED,
                    confidence: 0.8,
                    description: 'æ··åˆæ‹“æ‰‘ç»“æ„ï¼ŒåŒ…å«å¤šç§è¿æ¥æ–¹å¼'
                };
            }
            // æ˜Ÿå‹: æ‰€æœ‰ECUäº’è¿ï¼ˆä¸æ¨èï¼‰
            else if (connectorToConnector > circuitCount * 0.5) {
                topologyInfo = {
                    ...TOPOLOGY_TYPES.STAR,
                    confidence: 0.75,
                    description: 'æ˜Ÿå‹è¿æ¥ï¼ŒECUé—´ç›´æ¥äº’è”ï¼ˆä¸æ¨èç”¨äºCANï¼‰'
                };
            }
            // ç¯å½¢
            else if (connectorToConnector > 0 && busBranchCount === 0) {
                topologyInfo = {
                    ...TOPOLOGY_TYPES.RING,
                    confidence: 0.7,
                    description: 'è¿‘ä¼¼ç¯å½¢æ‹“æ‰‘'
                };
            }
            // é»˜è®¤çº¿æ€§æ€»çº¿
            else {
                topologyInfo = {
                    ...TOPOLOGY_TYPES.LINEAR,
                    confidence: 0.7,
                    description: 'çº¿æ€§æ€»çº¿æ‹“æ‰‘'
                };
            }

            return topologyInfo;
        }

        /**
         * è®¡ç®—æ‹“æ‰‘æŒ‡æ ‡
         */
        function calculateTopologyMetrics(canTypeGroup) {
            const circuits = canTypeGroup.circuits;
            const connectors = canTypeGroup.connectors;
            const solders = canTypeGroup.solders;
            const inlines = canTypeGroup.inlineNodes;

            // è®¡ç®—æ¯ä¸ªç„Šç‚¹çš„åˆ†æ”¯æ•°é‡
            const spliceBranches = new Map();
            circuits.forEach(c => {
                if (c.isFromSolder) {
                    const count = spliceBranches.get(c.fromCode) || 0;
                    spliceBranches.set(c.fromCode, count + 1);
                }
                if (c.isToSolder) {
                    const count = spliceBranches.get(c.toCode) || 0;
                    spliceBranches.set(c.toCode, count + 1);
                }
            });

            // ç»Ÿè®¡Inlineè¿æ¥
            const inlineConnections = new Map();
            circuits.forEach(c => {
                if (c.isFromInline || c.isToInline) {
                    const node = c.isFromInline ? c.fromCode : c.toCode;
                    const count = inlineConnections.get(node) || 0;
                    inlineConnections.set(node, count + 1);
                }
            });

            // è®¡ç®—ECUè¿æ¥å¯†åº¦
            const ecuConnections = new Map();
            circuits.forEach(c => {
                if (c.isFromConnector) {
                    const count = ecuConnections.get(c.fromCode) || 0;
                    ecuConnections.set(c.fromCode, count + 1);
                }
                if (c.isToConnector) {
                    const count = ecuConnections.get(c.toCode) || 0;
                    ecuConnections.set(c.toCode, count + 1);
                }
            });

            // ç»Ÿè®¡ä¿¡å·ç±»å‹åˆ†å¸ƒ
            let highCount = 0, lowCount = 0;
            circuits.forEach(c => {
                if (c.signalType === 'CAN High') highCount++;
                else if (c.signalType === 'CAN Low') lowCount++;
            });

            // è®¡ç®—æ€»çº¿èŠ‚ç‚¹ï¼ˆç„Šç‚¹+Inlineï¼‰
            const busNodes = solders.size + Math.ceil(inlines.size / 2);
            const maxBranches = Math.max(...Array.from(spliceBranches.values()), 0);

            return {
                totalCircuits: circuits.length,
                connectorCount: connectors.size,
                solderCount: solders.size,
                inlineCount: Math.ceil(inlineCount / 2),
                busNodes: busNodes,
                maxSpliceBranches: maxBranches,
                highCount: highCount,
                lowCount: lowCount,
                signalBalance: highCount === 0 ? 0 : Math.abs(highCount - lowCount) / highCount,
                avgEcuConnections: connectors.size > 0 ?
                    Array.from(ecuConnections.values()).reduce((a, b) => a + b, 0) / connectors.size : 0,
                inlineConnections: inlineConnections.size,
                branchDistribution: Array.from(spliceBranches.entries()).sort((a, b) => b[1] - a[1])
            };
        }

        /**
         * æ£€æµ‹æ‹“æ‰‘é—®é¢˜
         */
        function detectTopologyIssues(canTypeGroup, metrics) {
            const issues = [];

            // 1. æ£€æµ‹ç»ˆç«¯ç”µé˜»é—®é¢˜
            const connectors = Array.from(canTypeGroup.connectors.keys());
            const hasTerminalResistor = connectors.some(code => {
                const conn = canTypeGroup.connectors.get(code);
                return conn && conn.pins.has('CAN High') && conn.pins.has('CAN Low');
            });

            if (!hasTerminalResistor && connectors.length > 0) {
                issues.push({
                    type: 'critical',
                    code: 'TERMINATION',
                    title: 'ç¼ºå°‘ç»ˆç«¯ç”µé˜»',
                    description: 'æœªæ£€æµ‹åˆ°æ˜ç¡®çš„ç»ˆç«¯ç”µé˜»è¿æ¥ï¼ŒCANæ€»çº¿éœ€è¦120Î©ç»ˆç«¯ç”µé˜»åœ¨æ€»çº¿ä¸¤ç«¯',
                    recommendation: 'åœ¨æ€»çº¿æœ€è¿œç«¯çš„ä¸¤ä¸ªECUçš„CAN_Hå’ŒCAN_Lä¹‹é—´å„åŠ 120Î©ç”µé˜»'
                });
            }

            // 2. æ£€æµ‹åˆ†æ”¯è¿‡å¤šé—®é¢˜
            if (metrics.maxSpliceBranches > 4) {
                const problematicSplice = metrics.branchDistribution[0];
                issues.push({
                    type: 'warning',
                    code: 'BRANCH_COUNT',
                    title: 'ç„Šç‚¹åˆ†æ”¯è¿‡å¤š',
                    description: `ç„Šç‚¹ ${problematicSplice[0]} æœ‰ ${problematicSplice[1]} ä¸ªè¿æ¥åˆ†æ”¯ï¼Œå¯èƒ½å¯¼è‡´ä¿¡å·åå°„å’Œæ—¶åºé—®é¢˜`,
                    recommendation: 'å»ºè®®é‡æ–°è®¾è®¡æ‹“æ‰‘ï¼Œå°†éƒ¨åˆ†ECUç›´æ¥è¿æ¥åˆ°ä¸»å¹²çº¿ï¼Œå‡å°‘ç„Šç‚¹åˆ†æ”¯'
                });
            }

            // 3. æ£€æµ‹CANä¿¡å·ä¸å¹³è¡¡
            if (metrics.signalBalance > 0.2) {
                issues.push({
                    type: 'warning',
                    code: 'SIGNAL_BALANCE',
                    title: 'CAN High/Low ä¿¡å·ä¸å¹³è¡¡',
                    description: `CAN High: ${metrics.highCount}, CAN Low: ${metrics.lowCount}ï¼Œå·®å¼‚è¶…è¿‡20%`,
                    recommendation: 'æ£€æŸ¥æ‰€æœ‰è¿æ¥æ˜¯å¦æ­£ç¡®ï¼Œç¡®ä¿æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰CHå’ŒCLæˆå¯¹è¿æ¥'
                });
            }

            // 4. æ£€æµ‹InlineèŠ‚ç‚¹è¿‡å¤š
            if (metrics.inlineCount > 5) {
                issues.push({
                    type: 'info',
                    code: 'INLINE_NODES',
                    title: 'InlineèŠ‚ç‚¹è¾ƒå¤š',
                    description: `æ£€æµ‹åˆ° ${metrics.inlineCount} ä¸ªInlineèŠ‚ç‚¹ï¼Œè¿™ä¼šå¢åŠ æ€»çº¿å¤æ‚åº¦å’Œä¿¡å·å»¶è¿Ÿ`,
                    recommendation: 'è€ƒè™‘å‡å°‘InlineèŠ‚ç‚¹æ•°é‡ï¼Œæˆ–ä½¿ç”¨çŸ­åˆ†æ”¯è¿æ¥'
                });
            }

            // 5. æ£€æµ‹ECUè¿æ¥å¯†åº¦ä¸å‡
            if (metrics.avgEcuConnections > 2) {
                issues.push({
                    type: 'info',
                    code: 'ECU_DENSITY',
                    title: 'éƒ¨åˆ†ECUè¿æ¥å¯†åº¦è¾ƒé«˜',
                    description: `å¹³å‡æ¯ä¸ªECUæœ‰ ${metrics.avgEcuConnections.toFixed(1)} ä¸ªè¿æ¥ï¼Œéƒ¨åˆ†ECUè¿æ¥è¿‡å¤šèŠ‚ç‚¹`,
                    recommendation: 'é‡æ–°åˆ†é…è¿æ¥ï¼Œé¿å…å•ä¸ªECUæ‰¿æ‹…è¿‡å¤šåˆ†æ”¯'
                });
            }

            // 6. æ£€æµ‹æ€»çº¿é•¿åº¦æ½œåœ¨é—®é¢˜ï¼ˆåŸºäºèŠ‚ç‚¹æ•°ä¼°ç®—ï¼‰
            if (metrics.busNodes > 10) {
                issues.push({
                    type: 'warning',
                    code: 'BUS_LENGTH',
                    title: 'æ€»çº¿èŠ‚ç‚¹è¿‡å¤š',
                    description: `æ£€æµ‹åˆ° ${metrics.busNodes} ä¸ªæ€»çº¿èŠ‚ç‚¹ï¼Œå¯èƒ½è¶…è¿‡CANæ€»çº¿çš„æ¨èé™åˆ¶`,
                    recommendation: 'è€ƒè™‘å°†ç½‘ç»œåˆ†æ®µï¼Œä½¿ç”¨CANç½‘å…³è¿æ¥å¤šä¸ªæ€»çº¿æ®µ'
                });
            }

            // 7. æ£€æµ‹ECUæ•°é‡è¿‡å¤š
            if (metrics.connectorCount > 16) {
                issues.push({
                    type: 'warning',
                    code: 'NODE_COUNT',
                    title: 'ECUèŠ‚ç‚¹æ•°é‡è¾ƒå¤š',
                    description: `æ£€æµ‹åˆ° ${metrics.connectorCount} ä¸ªECUèŠ‚ç‚¹ï¼Œæ¥è¿‘CANæ€»çº¿æ¨èä¸Šé™`,
                    recommendation: 'ç¡®ä¿ä½¿ç”¨æ”¯æŒè¶³å¤ŸèŠ‚ç‚¹æ•°çš„CANæ”¶å‘å™¨ï¼Œè€ƒè™‘ä½¿ç”¨CAN FDæˆ–ç½‘ç»œåˆ†æ®µ'
                });
            }

            return issues;
        }

        /**
         * ç”Ÿæˆä¼˜åŒ–å»ºè®®
         */
        function generateSuggestions(issues, metrics, canTypeGroup) {
            const suggestions = [];

            // æ ¹æ®é—®é¢˜ç”Ÿæˆå»ºè®®
            issues.forEach(issue => {
                suggestions.push({
                    priority: issue.type === 'critical' ? 1 : (issue.type === 'warning' ? 2 : 3),
                    title: issue.title,
                    description: issue.recommendation,
                    implementation: getImplementationDetails(issue.code, canTypeGroup)
                });
            });

            // æ·»åŠ ä¸€èˆ¬æ€§ä¼˜åŒ–å»ºè®®
            if (metrics.maxSpliceBranches <= 4) {
                suggestions.push({
                    priority: 3,
                    title: 'åˆ†æ”¯é•¿åº¦ä¼˜åŒ–',
                    description: 'ç¡®ä¿æ‰€æœ‰åˆ†æ”¯é•¿åº¦å°äº0.3mï¼ˆé«˜é€ŸCANï¼‰æˆ–1mï¼ˆä½é€ŸCANï¼‰ï¼Œä»¥æœ€å°åŒ–ä¿¡å·åå°„',
                    implementation: {
                        steps: ['é‡æ–°å¸ƒçº¿ï¼Œå°†ECUå°½å¯èƒ½é è¿‘ä¸»å¹²çº¿æ”¾ç½®']
                    }
                });
            }

            if (!suggestions.find(s => s.title.includes('ç»ˆç«¯ç”µé˜»'))) {
                suggestions.push({
                    priority: 2,
                    title: 'éªŒè¯ç»ˆç«¯ç”µé˜»',
                    description: 'ä½¿ç”¨ä¸‡ç”¨è¡¨æµ‹é‡CAN_Hå’ŒCAN_Lä¹‹é—´çš„ç”µé˜»ï¼Œåº”ä¸ºçº¦60Î©ï¼ˆä¸¤ä¸ª120Î©å¹¶è”ï¼‰',
                    implementation: {
                        steps: ['åœ¨æ€»çº¿ä¸¤ç«¯åˆ†åˆ«æµ‹é‡ï¼Œç¡®ä¿ç»ˆç«¯ç”µé˜»æ­£ç¡®']
                    }
                });
            }

            // æŒ‰ä¼˜å…ˆçº§æ’åº
            return suggestions.sort((a, b) => a.priority - b.priority);
        }

        /**
         * è·å–å®ç°ç»†èŠ‚
         */
        function getImplementationDetails(issueCode, canTypeGroup) {
            const details = {
                'TERMINATION': {
                    steps: [
                        'è¯†åˆ«æ€»çº¿æœ€è¿œç«¯çš„ä¸¤ä¸ªECU',
                        'åœ¨è¯¥ECUçš„è¿æ¥å™¨ä¸­æ‰¾åˆ°CAN_Hå’ŒCAN_Lå¼•è„š',
                        'åœ¨CAN_Hå’ŒCAN_Lä¹‹é—´ç„Šæ¥120Î©ç”µé˜»',
                        'ä½¿ç”¨ç¤ºæ³¢å™¨éªŒè¯ä¿¡å·è´¨é‡'
                    ],
                    tools: ['ä¸‡ç”¨è¡¨', 'ç¤ºæ³¢å™¨', '120Î©ç”µé˜»', 'ç„Šæ¥è®¾å¤‡']
                },
                'BRANCH_COUNT': {
                    steps: [
                        'åˆ†æç°æœ‰è¿æ¥ï¼Œç¡®å®šå“ªäº›å¯ä»¥é‡æ–°è·¯ç”±',
                        'å°†éƒ¨åˆ†ECUç›´æ¥è¿æ¥åˆ°ä¸»å¹²çº¿',
                        'é‡æ–°å¸ƒçº¿ï¼Œå‡å°‘ç„Šç‚¹å¤„çš„è¿æ¥æ•°',
                        'éªŒè¯ä¿®æ”¹åçš„ä¿¡å·å®Œæ•´æ€§'
                    ],
                    tools: ['çº¿æŸå›¾', 'ä¸‡ç”¨è¡¨', 'ç¤ºæ³¢å™¨']
                },
                'SIGNAL_BALANCE': {
                    steps: [
                        'æ£€æŸ¥æ¯ä¸ªèŠ‚ç‚¹çš„CHå’ŒCLæ˜¯å¦æˆå¯¹è¿æ¥',
                        'æŸ¥æ‰¾ç¼ºå¤±çš„è¿æ¥æˆ–æ–­å¼€çš„çº¿è·¯',
                        'è¡¥å……ç¼ºå¤±çš„è¿æ¥',
                        'é‡æ–°éªŒè¯ä¿¡å·å¹³è¡¡'
                    ],
                    tools: ['ä¸‡ç”¨è¡¨', 'CANåˆ†æä»ª']
                },
                'INLINE_NODES': {
                    steps: [
                        'è¯„ä¼°æ¯ä¸ªInlineèŠ‚ç‚¹çš„å¿…è¦æ€§',
                        'å°†çŸ­åˆ†æ”¯Inlineæ”¹ä¸ºç›´æ¥è¿æ¥',
                        'ä¼˜åŒ–å¸ƒçº¿ï¼Œå‡å°‘InlineèŠ‚ç‚¹',
                        'éªŒè¯ä¿®æ”¹åçš„ç”µæ°”ç‰¹æ€§'
                    ],
                    tools: ['çº¿æŸå›¾', 'ä¸‡ç”¨è¡¨']
                },
                'ECU_DENSITY': {
                    steps: [
                        'åˆ†æECUè¿æ¥å›¾',
                        'è¯†åˆ«é«˜è¿æ¥å¯†åº¦çš„ECU',
                        'é‡æ–°åˆ†é…è¿æ¥ï¼Œå°†è´Ÿè½½åˆ†æ•£',
                        'éªŒè¯æ‹“æ‰‘ç»“æ„çš„æ­£ç¡®æ€§'
                    ],
                    tools: ['è¿æ¥å›¾', 'æ‹“æ‰‘åˆ†æå·¥å…·']
                },
                'BUS_LENGTH': {
                    steps: [
                        'è¯„ä¼°æ˜¯å¦å¯ä»¥å°†ç½‘ç»œåˆ†æ®µ',
                        'è¯†åˆ«å¯ä»¥åˆ†ç¦»çš„åŠŸèƒ½ç»„',
                        'ä½¿ç”¨CANç½‘å…³è¿æ¥å¤šä¸ªæ€»çº¿æ®µ',
                        'æµ‹è¯•å„æ®µçš„é€šä¿¡è´¨é‡'
                    ],
                    tools: ['CANç½‘å…³', 'ç¤ºæ³¢å™¨', 'CANåˆ†æä»ª']
                },
                'NODE_COUNT': {
                    steps: [
                        'ç¡®è®¤æ‰€æœ‰ECUçš„å¿…è¦æ€§',
                        'è€ƒè™‘ä½¿ç”¨CAN FDæ‰©å±•èŠ‚ç‚¹æ•°',
                        'è¯„ä¼°ä½¿ç”¨ç½‘ç»œåˆ†æ®µ',
                        'éªŒè¯æ”¶å‘å™¨çš„èŠ‚ç‚¹é©±åŠ¨èƒ½åŠ›'
                    ],
                    tools: ['CANæ”¶å‘å™¨æ•°æ®æ‰‹å†Œ', 'ç½‘ç»œåˆ†æä»ª']
                }
            };

            return details[issueCode] || {
                steps: ['åˆ†æé—®é¢˜', 'åˆ¶å®šè§£å†³æ–¹æ¡ˆ', 'å®æ–½ä¿®æ”¹', 'éªŒè¯ç»“æœ'],
                tools: ['åŸºæœ¬å·¥å…·']
            };
        }

        /**
         * è®¡ç®—ä¼˜åŒ–è¯„åˆ† (0-100)
         */
        function calculateOptimizationScore(issues, metrics) {
            let score = 100;

            // å…³é”®é—®é¢˜æ‰£30åˆ†
            issues.filter(i => i.type === 'critical').forEach(() => {
                score -= 30;
            });

            // è­¦å‘Šæ‰£15åˆ†
            issues.filter(i => i.type === 'warning').forEach(() => {
                score -= 15;
            });

            // æç¤ºæ‰£5åˆ†
            issues.filter(i => i.type === 'info').forEach(() => {
                score -= 5;
            });

            // é¢å¤–æ£€æŸ¥
            if (metrics.maxSpliceBranches > 4) score -= 10;
            if (metrics.signalBalance > 0.2) score -= 10;

            return Math.max(0, Math.min(100, score));
        }

        /**
         * æ¸²æŸ“ä¼˜åŒ–æŠ¥å‘Šé¢æ¿
         */
        function renderOptimizationReport() {
            if (!currentCanType) return;

            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup) return;

            const report = generateOptimizationReport(canTypeGroup);

            // æ›´æ–°UI
            const topologyTypeEl = $('topologyType');
            const totalNodesEl = $('totalNodes');
            const ecuCountEl = $('ecuCount');
            const spliceCountEl = $('spliceCount');
            const inlineCountEl = $('inlineCount');
            const wireCountEl = $('wireCount');
            const complexityEl = $('complexity');

            if (topologyTypeEl) {
                topologyTypeEl.innerHTML = `<span class="topology-type-badge topology-type-${report.topologyType.id}">${report.topologyType.name}</span>`;
            }

            if (totalNodesEl) totalNodesEl.textContent = report.metrics.busNodes;
            if (ecuCountEl) ecuCountEl.textContent = report.metrics.connectorCount;
            if (spliceCountEl) spliceCountEl.textContent = report.metrics.solderCount;
            if (inlineCountEl) inlineCountEl.textContent = report.metrics.inlineCount;
            if (wireCountEl) wireCountEl.textContent = report.metrics.totalCircuits;

            if (complexityEl) {
                const score = report.score;
                let level = 'ä½';
                let color = '#28a745';
                if (score < 40) {
                    level = 'é«˜';
                    color = '#dc3545';
                } else if (score < 70) {
                    level = 'ä¸­';
                    color = '#ffc107';
                }
                complexityEl.innerHTML = `<span style="color: ${color}; font-weight: bold;">${level} (${score}åˆ†)</span>`;
            }

            // æ›´æ–°è¯Šæ–­è­¦å‘Š
            const warningsList = $('warningsList');
            if (warningsList) {
                if (report.issues.length === 0) {
                    warningsList.innerHTML = '<div style="color: #28a745; font-size: 11px;">âœ“ æ‹“æ‰‘ç»“æ„ä¼˜åŒ–è‰¯å¥½</div>';
                } else {
                    warningsList.innerHTML = report.issues.map(issue => {
                        const icon = issue.type === 'critical' ? 'ğŸš¨' : (issue.type === 'warning' ? 'âš ï¸' : 'â„¹ï¸');
                        const bgColor = issue.type === 'critical' ? '#ffebee' : (issue.type === 'warning' ? '#fff3e0' : '#e3f2fd');
                        const borderColor = issue.type === 'critical' ? '#dc3545' : (issue.type === 'warning' ? '#ff9800' : '#2196f3');
                        return `
                            <div class="warning-item ${issue.type}" style="background: ${bgColor}; border-left-color: ${borderColor};">
                                <div style="font-weight: bold; margin-bottom: 4px;">${icon} ${issue.title}</div>
                                <div style="font-size: 10px; color: #666;">${issue.description}</div>
                                <div style="font-size: 10px; color: #28a745; margin-top: 4px;">ğŸ’¡ ${issue.recommendation}</div>
                            </div>
                        `;
                    }).join('');
                }
            }

            // æ·»åŠ ä¼˜åŒ–å»ºè®®é¢æ¿
            addOptimizationPanel(report);
        }

        /**
         * æ·»åŠ ä¼˜åŒ–å»ºè®®é¢æ¿åˆ°ä¾§è¾¹æ 
         */
        function addOptimizationPanel(report) {
            let panel = $('optimizationPanel');
            if (panel) panel.remove();

            const sidebar = $('topologySidebar');
            if (!sidebar) return;

            panel = document.createElement('div');
            panel.id = 'optimizationPanel';
            panel.className = 'topology-sidebar-section';
            panel.style.cssText = 'border-top: 1px solid #eee; padding-top: 15px; margin-top: 15px;';

            panel.innerHTML = `
                <h4 style="font-size: 13px; color: #333; margin-bottom: 10px; display: flex; align-items: center; gap: 6px;">
                    <span style="font-size: 16px;">ğŸ“Š</span> ä¼˜åŒ–å»ºè®®
                    <span style="margin-left: auto; font-size: 11px; color: ${report.score >= 70 ? '#28a745' : (report.score >= 40 ? '#ffc107' : '#dc3545')};">
                        è¯„åˆ†: ${report.score}/100
                    </span>
                </h4>
                <div style="max-height: 250px; overflow-y: auto;">
                    ${report.suggestions.length === 0 ?
                        '<div style="color: #28a745; font-size: 11px;">âœ“ æ— éœ€ä¼˜åŒ–ï¼Œæ‹“æ‰‘ç»“æ„è‰¯å¥½</div>' :
                        report.suggestions.map((s, idx) => `
                            <div style="margin-bottom: 12px; padding: 10px; background: #f8f9fa; border-radius: 6px; border-left: 3px solid ${s.priority === 1 ? '#dc3545' : (s.priority === 2 ? '#ff9800' : '#2196f3')};">
                                <div style="font-weight: bold; font-size: 12px; color: #333; margin-bottom: 4px;">
                                    ${idx + 1}. ${s.title}
                                </div>
                                <div style="font-size: 10px; color: #666; margin-bottom: 6px;">
                                    ${s.description}
                                </div>
                                ${s.implementation ? `
                                    <div style="font-size: 10px; color: #28a745;">
                                        <strong>å®æ–½æ­¥éª¤:</strong>
                                        <ul style="margin: 4px 0; padding-left: 16px;">
                                            ${s.implementation.steps.map(step => '<li>' + step + '</li>').join('')}
                                        </ul>
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')
                    }
                </div>
            `;

            sidebar.appendChild(panel);
        }

        /**
         * å¯¼å‡ºä¼˜åŒ–æŠ¥å‘Š
         */
        async function exportOptimizationReport() {
            if (!currentCanType) {
                showMessage('âš ï¸ è¯·å…ˆé€‰æ‹©CANç±»å‹', 'error');
                return;
            }

            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup) return;

            const report = generateOptimizationReport(canTypeGroup);

            try {
                const workbook = new ExcelJS.Workbook();
                const worksheet = workbook.addWorksheet('CANæ‹“æ‰‘ä¼˜åŒ–æŠ¥å‘Š');

                // æ ‡é¢˜
                worksheet.mergeCells('A1:E1');
                worksheet.getCell('A1').value = `${currentCanType} CANæ€»çº¿æ‹“æ‰‘ä¼˜åŒ–æŠ¥å‘Š`;
                worksheet.getCell('A1').font = { bold: true, size: 16 };
                worksheet.getCell('A1').alignment = { horizontal: 'center' };

                // åŸºæœ¬ä¿¡æ¯
                worksheet.getCell('A3').value = 'åŸºæœ¬ä¿¡æ¯';
                worksheet.getCell('A3').font = { bold: true, size: 14 };
                worksheet.getCell('A4').value = 'æ‹“æ‰‘ç±»å‹:';
                worksheet.getCell('B4').value = report.topologyType.name;
                worksheet.getCell('A5').value = 'ECUæ•°é‡:';
                worksheet.getCell('B5').value = report.metrics.connectorCount;
                worksheet.getCell('A6').value = 'ç„Šç‚¹æ•°é‡:';
                worksheet.getCell('B6').value = report.metrics.solderCount;
                worksheet.getCell('A7').value = 'InlineèŠ‚ç‚¹:';
                worksheet.getCell('B7').value = report.metrics.inlineCount;
                worksheet.getCell('A8').value = 'å¯¼çº¿æ•°é‡:';
                worksheet.getCell('B8').value = report.metrics.totalCircuits;
                worksheet.getCell('A9').value = 'ä¼˜åŒ–è¯„åˆ†:';
                worksheet.getCell('B9').value = `${report.score}/100`;

                // é—®é¢˜åˆ—è¡¨
                let row = 11;
                worksheet.getCell(`A${row}`).value = 'æ£€æµ‹åˆ°çš„é—®é¢˜';
                worksheet.getCell(`A${row}`).font = { bold: true, size: 14 };
                row++;

                if (report.issues.length === 0) {
                    worksheet.getCell(`A${row}`).value = 'âœ“ æœªæ£€æµ‹åˆ°é—®é¢˜';
                    worksheet.getCell(`A${row}`).font = { color: { argb: 'FF28A745' } };
                } else {
                    report.issues.forEach(issue => {
                        worksheet.getCell(`A${row}`).value = `[${issue.type.toUpperCase()}] ${issue.title}`;
                        worksheet.getCell(`A${row}`).font = { bold: true };
                        row++;
                        worksheet.getCell(`A${row}`).value = issue.description;
                        row++;
                        worksheet.getCell(`A${row}`).value = `å»ºè®®: ${issue.recommendation}`;
                        worksheet.getCell(`A${row}`).font = { italic: true, color: { argb: 'FF28A745' } };
                        row++;
                    });
                }

                // ä¼˜åŒ–å»ºè®®
                row += 2;
                worksheet.getCell(`A${row}`).value = 'ä¼˜åŒ–å»ºè®®';
                worksheet.getCell(`A${row}`).font = { bold: true, size: 14 };
                row++;

                report.suggestions.forEach((suggestion, idx) => {
                    worksheet.getCell(`A${row}`).value = `${idx + 1}. ${suggestion.title}`;
                    worksheet.getCell(`A${row}`).font = { bold: true };
                    row++;
                    worksheet.getCell(`A${row}`).value = suggestion.description;
                    row++;

                    if (suggestion.implementation) {
                        worksheet.getCell(`A${row}`).value = 'å®æ–½æ­¥éª¤:';
                        worksheet.getCell(`A${row}`).font = { bold: true };
                        row++;
                        suggestion.implementation.steps.forEach(step => {
                            worksheet.getCell(`A${row}`).value = `  â€¢ ${step}`;
                            row++;
                        });
                        worksheet.getCell(`A${row}`).value = `æ‰€éœ€å·¥å…·: ${suggestion.implementation.tools.join(', ')}`;
                        row++;
                    }
                });

                // å¯¼å‡º
                const buffer = await workbook.xlsx.writeBuffer();
                const blob = new Blob([buffer], {
                    type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
                });
                const fileName = `CANæ‹“æ‰‘ä¼˜åŒ–æŠ¥å‘Š_${currentCanType}_${new Date().toISOString().slice(0, 10)}.xlsx`;
                saveAs(blob, fileName);

                showMessage('âœ… ä¼˜åŒ–æŠ¥å‘Šå¯¼å‡ºæˆåŠŸ', 'success');
            } catch (error) {
                console.error('[å¯¼å‡ºä¼˜åŒ–æŠ¥å‘Šå¤±è´¥]', error);
                showMessage('âŒ å¯¼å‡ºå¤±è´¥: ' + error.message, 'error');
            }
        }

        // é‡å†™updateWarningsä»¥ä½¿ç”¨æ–°çš„ä¼˜åŒ–åˆ†æ
        function updateTopologyAnalysis() {
            const canTypeGroup = topologyCanTypes.find(g => g.canType === currentCanType);
            if (!canTypeGroup) return;

            const connectors = Array.from(canTypeGroup.connectors.keys());
            const solders = Array.from(canTypeGroup.solders.keys());
            const inlines = Array.from(canTypeGroup.inlineNodes.keys());
            const circuits = canTypeGroup.circuits;

            const ecuCount = connectors.length;
            const spliceCount = solders.length;
            const inlineCount = inlines.length / 2;
            const wireCount = circuits.length;
            const totalNodes = ecuCount + spliceCount + inlineCount;

            const topologyTypeEl = $('topologyType');
            const totalNodesEl = $('totalNodes');
            const ecuCountEl = $('ecuCount');
            const spliceCountEl = $('spliceCount');
            const inlineCountEl = $('inlineCount');
            const wireCountEl = $('wireCount');
            const complexityEl = $('complexity');

            // ä½¿ç”¨æ–°çš„ä¼˜åŒ–åˆ†æ
            renderOptimizationReport();

            if (topologyTypeEl && !topologyTypeEl.innerHTML.includes('æ‹“æ‰‘ç±»å‹')) {
                const topologyType = analyzeTopologyType(canTypeGroup);
                topologyTypeEl.innerHTML = `<span class="topology-type-badge topology-type-${topologyType.id}">${topologyType.name}</span>`;
            }

            if (totalNodesEl) totalNodesEl.textContent = totalNodes;
            if (ecuCountEl) ecuCountEl.textContent = ecuCount;
            if (spliceCountEl) spliceCountEl.textContent = spliceCount;
            if (inlineCountEl) inlineCountEl.textContent = inlineCount;
            if (wireCountEl) wireCountEl.textContent = wireCount;
        }

    </script>
</body>
</html>
