<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wire Chart ç”Ÿæˆå·¥å…· V8</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Microsoft YaHei', sans-serif; background: #f5f5f5; min-height: 100vh; }
        .btn { padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; font-size: 14px; transition: background 0.2s; }
        .btn-primary { background: #2170b8; color: white; }
        .btn-primary:hover:not(:disabled) { background: #1a5a96; }
        .btn-success { background: #28a745; color: white; }
        .btn-success:hover:not(:disabled) { background: #218838; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .toolbar { background: #e9ecef; padding: 12px 20px; display: flex; gap: 20px; align-items: center; flex-wrap: wrap; }
        .toolbar-group { display: flex; align-items: center; gap: 8px; }
        .file-status { font-size: 12px; color: #666; min-width: 100px; }
        .file-status.loaded { color: #28a745; font-weight: 500; }
        .table-wrapper { position: relative; background: white; margin: 10px 20px; border: 1px solid #d4d4d4; height: calc(100vh - 170px); overflow: auto; contain: strict; }
        table { border-collapse: collapse; min-width: 100%; table-layout: auto; width: max-content; }
        tr { height: 28px; }
        tr:hover { background: #e8f4fc; }
        tr.header { background: #2170b8; color: white; position: sticky; top: 0; z-index: 10; height: 32px; font-weight: 500; }
        tr.header1 { background: #1a5a96; color: white; position: sticky; top: 32px; z-index: 9; height: 28px; font-weight: 500; }
        tr.header2 { background: #16589e; color: white; position: sticky; top: 60px; z-index: 8; height: 28px; }
        tr.header3 { background: #134c85; color: white; position: sticky; top: 88px; z-index: 7; height: 28px; }
        tr.header:hover { background: #2170b8; }
        th, td { border: 1px solid #d4d4d4; padding: 2px 12px; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; height: 28px; min-width: 100px; max-width: 250px; }
        th:first-child, td:first-child { width: 100px; min-width: 100px; max-width: 100px; text-align: center; }
        tr.header th:first-child { width: 100px; min-width: 100px; max-width: 100px; }
        td.updated { background: #d4edda; }
        td.action { background: #fff3cd; }
        td.empty { background: #f5f5f5; }
        .empty-state { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #999; }
        .footer { background: #f8f9fa; padding: 10px 20px; border-top: 1px solid #d4d4d4; display: flex; justify-content: space-between; align-items: center; font-size: 12px; }
        .page-nav { display: flex; gap: 10px; align-items: center; }
        .progress-overlay { position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.5); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .progress-box { background: white; padding: 30px 40px; border-radius: 8px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .progress-bar { width: 300px; height: 20px; background: #e9ecef; border-radius: 4px; overflow: hidden; margin: 15px 0; }
        .progress-fill { height: 100%; background: linear-gradient(135deg, #2170b8 0%, #1a5a96 100%); width: 0%; transition: width 0.1s; }
        .legend { display: flex; gap: 15px; font-size: 12px; }
        .legend-item { display: flex; align-items: center; gap: 5px; }
        .legend-color { width: 16px; height: 16px; border-radius: 3px; }
    </style>
</head>
<body>
    <div class="toolbar">
        <div class="toolbar-group">
            <button class="btn btn-primary" onclick="selectFile('ecr')">ä¸Šä¼ ECRæ–‡ä»¶</button>
            <span class="file-status" id="ecrStatus">æœªé€‰æ‹©</span>
        </div>
        <div class="toolbar-group">
            <button class="btn btn-primary" onclick="selectFile('chart')">ä¸Šä¼ Chartæ–‡ä»¶</button>
            <span class="file-status" id="chartStatus">æœªé€‰æ‹©</span>
        </div>
        <button class="btn btn-primary" id="generateBtn" onclick="generateData()" disabled>ç”ŸæˆWire Chart</button>
        <button class="btn btn-primary" id="copyBtn" onclick="copyHtml()" disabled>å¤åˆ¶çº¯æ–‡æœ¬</button>
        <button class="btn btn-success" id="exportBtn" onclick="exportExcel()" disabled>å¯¼å‡ºExcel</button>
        <button class="btn btn-success" id="exportAllBtn" onclick="exportAllPartNumberCharts()" disabled>å¯¼å‡ºå…¨éƒ¨é›¶ä»¶å·</button>
        <div class="legend">
            <div class="legend-item"><div class="legend-color" style="background:#d4edda"></div><span>å·²æ›´æ–°</span></div>
            <div class="legend-item"><div class="legend-color" style="background:#fff3cd"></div><span>ACTION</span></div>
        </div>
    </div>

    <div class="table-wrapper" id="tableWrapper">
        <div class="empty-state" id="emptyState">
            <div class="icon">ğŸ“Š</div>
            <p>è¯·ä¸Šä¼ ECRæ–‡ä»¶ï¼Œç„¶åç‚¹å‡»ç”Ÿæˆ</p>
        </div>
        <div id="tableContent"></div>
    </div>

    <div class="footer">
        <span id="statsText">å›è·¯: 0 | ç‰¹å¾å€¼: 0 | Xæ‰“ç‚¹: 0</span>
        <div class="page-nav">
            <button class="btn" onclick="prevPage()">ä¸Šä¸€é¡µ</button>
            <span id="pageInfo">0 / 0</span>
            <button class="btn" onclick="nextPage()">ä¸‹ä¸€é¡µ</button>
        </div>
    </div>

    <div class="progress-overlay" id="progressOverlay">
        <div class="progress-box">
            <h3 id="progressTitle">å¤„ç†ä¸­...</h3>
            <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
            <div class="progress-text" id="progressText">è¯·ç¨å€™...</div>
        </div>
    </div>

    <script src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>
    <script>
        // éªŒè¯è„šæœ¬æ­£åœ¨åŠ è½½
        console.log('Wire Chart V8 è„šæœ¬å¼€å§‹åŠ è½½...');

        // å…¨å±€çŠ¶æ€
        let generatedRows = [];
        let partNumbers = [];
        let currentPage = 0;
        const pageSize = 500;
        let totalPages = 0;
        let chartHeader = [];
        let chartHeaderRows = [];  // å­˜å‚¨æ‰€æœ‰è¡¨å¤´è¡Œ
        let chartRows = [];
        let ecrFile = null;
        let chartFile = null;
        let partColStart = 28;

        // V8æ–°å¢ï¼šå­˜å‚¨master listæ•°æ®å’Œç‰¹å¾å€¼æ˜ å°„
        let masterlistData = null;
        let wireData = null;
        let partFeaturesMap = {};

        // ==================== è¡¨å¤´å¤„ç†å·¥å…·å‡½æ•° ====================

        /**
         * è§„èŒƒåŒ–å•å…ƒæ ¼å€¼ï¼šå¤„ç†åµŒå¥—æ•°ç»„å’Œnull/undefined
         * @param {any} value - åŸå§‹å•å…ƒæ ¼å€¼
         * @returns {string} è§„èŒƒåŒ–åçš„å­—ç¬¦ä¸²
         */
        function normalizeCellValue(value) {
            if (value === null || value === undefined) return '';
            // å¤„ç†å¤šå±‚åµŒå¥—æ•°ç»„ï¼ˆExcelåˆå¹¶å•å…ƒæ ¼çš„æƒ…å†µï¼‰
            while (Array.isArray(value)) {
                value = value[0] || '';
            }
            return String(value).trim();
        }

        /**
         * åˆ¤æ–­ä¸€è¡Œæ˜¯å¦ä¸ºæœ‰æ•ˆè¡¨å¤´è¡Œ
         * @param {Array} row - è¡Œæ•°æ®
         * @returns {boolean} æ˜¯å¦ä¸ºæœ‰æ•ˆè¡¨å¤´è¡Œ
         */
        function isValidHeaderRow(row) {
            if (!row || !Array.isArray(row)) return false;
            // æ£€æŸ¥è¡Œæ˜¯å¦æœ‰è¶³å¤Ÿçš„åˆ—ï¼ˆè‡³å°‘5åˆ—ï¼‰
            if (row.length < 5) return false;
            // æ£€æŸ¥æ˜¯å¦è‡³å°‘æœ‰ä¸€ä¸ªéç©ºå•å…ƒæ ¼
            const hasContent = row.some(cell => {
                const val = normalizeCellValue(cell);
                return val !== '';
            });
            return hasContent;
        }

        /**
         * ä»Chartæ–‡ä»¶ä¸­æå–æœ‰æ•ˆè¡¨å¤´è¡Œ
         * @param {Array} allRows - Chartæ–‡ä»¶çš„æ‰€æœ‰è¡Œ
         * @param {number} maxHeaderRows - æœ€å¤šæå–çš„è¡¨å¤´è¡Œæ•°ï¼ˆé»˜è®¤4è¡Œï¼‰
         * @returns {Object} { headerRows: Array, validRowCount: number }
         */
        function extractHeaderRows(allRows, maxHeaderRows = 4) {
            const headerRows = [];
            let validCount = 0;

            for (let i = 0; i < Math.min(maxHeaderRows, allRows.length); i++) {
                const row = allRows[i];
                if (isValidHeaderRow(row)) {
                    // è§„èŒƒåŒ–æ¯ä¸ªå•å…ƒæ ¼çš„å€¼
                    const normalizedRow = row.map(cell => normalizeCellValue(cell));
                    headerRows.push(normalizedRow);
                    validCount++;
                }
            }

            return { headerRows, validRowCount: validCount };
        }

        /**
         * ä»è¡¨å¤´è¡Œä¸­æå–åˆ—åï¼ˆç”¨äºæ•°æ®æ˜ å°„ï¼‰
         * @param {Array} headerRows - è¡¨å¤´è¡Œæ•°ç»„
         * @param {number} rowIndex - ä½¿ç”¨ç¬¬å‡ è¡Œä½œä¸ºåˆ—åï¼ˆé»˜è®¤-1è¡¨ç¤ºæœ€åä¸€è¡Œï¼Œ0è¡¨ç¤ºç¬¬ä¸€è¡Œï¼Œ2è¡¨ç¤ºç¬¬ä¸‰è¡Œï¼‰
         * @returns {Array} åˆ—åæ•°ç»„
         */
        function extractColumnNames(headerRows, rowIndex = -1) {
            if (!headerRows || headerRows.length === 0) return [];

            // æ”¯æŒè´Ÿç´¢å¼•ï¼š-1è¡¨ç¤ºæœ€åä¸€è¡Œï¼Œ-2è¡¨ç¤ºå€’æ•°ç¬¬äºŒè¡Œï¼Œä¾æ­¤ç±»æ¨
            let targetIndex = rowIndex;
            if (rowIndex < 0) {
                targetIndex = headerRows.length + rowIndex;
            }

            // è¾¹ç•Œæ£€æŸ¥
            if (targetIndex < 0 || targetIndex >= headerRows.length) {
                targetIndex = headerRows.length - 1;
            }

            const targetRow = headerRows[targetIndex];
            return targetRow.map(cell => normalizeCellValue(cell));
        }

        // DOMç¼“å­˜
        const domCache = {
            tableContent: null, pageInfo: null, progressFill: null,
            progressOverlay: null, progressTitle: null, progressText: null,
            statsText: null, emptyState: null, exportBtn: null,
            copyBtn: null, generateBtn: null, exportAllBtn: null
        };

        function initDomCache() {
            domCache.tableContent = document.getElementById('tableContent');
            domCache.pageInfo = document.getElementById('pageInfo');
            domCache.progressFill = document.getElementById('progressFill');
            domCache.progressOverlay = document.getElementById('progressOverlay');
            domCache.progressTitle = document.getElementById('progressTitle');
            domCache.progressText = document.getElementById('progressText');
            domCache.statsText = document.getElementById('statsText');
            domCache.emptyState = document.getElementById('emptyState');
            domCache.exportBtn = document.getElementById('exportBtn');
            domCache.copyBtn = document.getElementById('copyBtn');
            domCache.generateBtn = document.getElementById('generateBtn');
            domCache.exportAllBtn = document.getElementById('exportAllBtn');
        }

        async function selectFile(type) {
            console.log('selectFile å‡½æ•°è¢«è°ƒç”¨ï¼Œtype:', type);
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.xlsx';
            input.onchange = async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const status = document.getElementById(type + 'Status');
                status.textContent = file.name;
                status.classList.add('loaded');

                if (type === 'ecr') {
                    ecrFile = file;
                } else if (type === 'chart') {
                    chartFile = file;
                    try {
                        const buffer = await file.arrayBuffer();
                        const workbook = XLSX.read(buffer, { type: 'array' });
                        const wireChartSheetName = Object.keys(workbook.Sheets).find(name => name.includes('Wire Chart'));
                        if (wireChartSheetName) {
                            chartRows = XLSX.utils.sheet_to_json(workbook.Sheets[wireChartSheetName], { header: 1 });
                            console.log('Chartæ€»è¡Œæ•°:', chartRows.length);
                            console.log('ç¬¬1è¡Œé•¿åº¦:', chartRows[0]?.length);
                            console.log('ç¬¬1è¡Œå†…å®¹:', chartRows[0]);
                            console.log('ç¬¬2è¡Œé•¿åº¦:', chartRows[1]?.length);
                            console.log('ç¬¬3è¡Œé•¿åº¦:', chartRows[2]?.length);
                            console.log('ç¬¬4è¡Œé•¿åº¦:', chartRows[3]?.length);
                        }
                    } catch (err) {
                        console.error('è¯»å–Chartæ–‡ä»¶å¤±è´¥:', err);
                    }
                }

                if (ecrFile) {
                    domCache.generateBtn.disabled = false;
                }
            };
            input.click();
        }
        console.log('selectFile å‡½æ•°å·²å®šä¹‰');

        function showProgress(show, title = 'å¤„ç†ä¸­...', text = 'è¯·ç¨å€™...') {
            domCache.progressOverlay.style.display = show ? 'flex' : 'none';
            domCache.progressTitle.textContent = title;
            domCache.progressText.textContent = text;
        }

        function updateProgress(percent) {
            domCache.progressFill.style.width = percent + '%';
        }

        async function readExcel(file) {
            const buffer = await file.arrayBuffer();
            const workbook = XLSX.read(buffer, { type: 'array' });
            const sheets = {};
            for (const name of workbook.SheetNames) {
                sheets[name] = XLSX.utils.sheet_to_json(workbook.Sheets[name], { header: 1, defval: '' });
            }
            return sheets;
        }

        function calculateOption(expression, carConfigs) {
            if (!expression || !String(expression).trim()) return false;
            const expr = String(expression).replace(/\s+/g, '').toUpperCase();
            const tokens = expr.split(/([&\/\-\(\)])/).filter(t => t);

            const evalTokens = (tokens, start, end) => {
                let result = null, currentOp = null, i = start;
                while (i < end) {
                    const token = tokens[i];
                    let value;
                    if (token === '(') {
                        let depth = 1, j = i + 1;
                        while (j < end && depth > 0) {
                            if (tokens[j] === '(') depth++;
                            else if (tokens[j] === ')') depth--;
                            j++;
                        }
                        value = evalTokens(tokens, i + 1, j - 1);
                        i = j;
                    } else if (token === '-') {
                        i++;
                        if (i >= end) break;
                        const next = tokens[i];
                        if (next === '(') {
                            let depth = 1, j = i + 1;
                            while (j < end && depth > 0) {
                                if (tokens[j] === '(') depth++;
                                else if (tokens[j] === ')') depth--;
                                j++;
                            }
                            value = evalTokens(tokens, i + 1, j - 1);
                            value = value.map(x => !x);
                            i = j;
                        } else {
                            value = [carConfigs.includes(next)];
                            i++;
                        }
                    } else if (token === '&' || token === '/' || token === '') {
                        i++;
                        continue;
                    } else {
                        value = [carConfigs.includes(token)];
                        i++;
                    }
                    if (result === null) result = value;
                    else if (currentOp === '&') result = result.map((r, idx) => r && (value[idx] !== undefined ? value[idx] : r));
                    else if (currentOp === '/') result = result.map((r, idx) => r || (value[idx] !== undefined ? value[idx] : false));
                    if (i < end && (tokens[i] === '&' || tokens[i] === '/')) { currentOp = tokens[i]; i++; }
                }
                return result;
            };

            const result = evalTokens(tokens, 0, tokens.length);
            return result && result[0];
        }

        async function generateData() {
            if (!ecrFile) return;

            showProgress(true, 'è¯»å–æ–‡ä»¶...', 'æ­£åœ¨è¯»å–ECRæ–‡ä»¶...');

            try {
                const ecrSheets = await readExcel(ecrFile);
                updateProgress(20);

                // æ‰¾WIRE sheetå’ŒMasterlist sheet
                const wireSheetName = Object.keys(ecrSheets).find(s => s.includes('WIRE'));
                const masterlistSheetName = Object.keys(ecrSheets).find(s => s.includes('Masterlist') && !s.includes('CHG'));

                if (!wireSheetName || !masterlistSheetName) {
                    showProgress(false);
                    alert('æœªæ‰¾åˆ°WIREæˆ–Masterlist sheet');
                    return;
                }

                // V8: ä¿å­˜åˆ°å…¨å±€å˜é‡ä¾›å¯¼å‡ºå…¨éƒ¨é›¶ä»¶å·ä½¿ç”¨
                wireData = ecrSheets[wireSheetName];
                masterlistData = ecrSheets[masterlistSheetName];

                console.log('WIREæ•°æ®è¡Œæ•°:', wireData.length);
                console.log('Masterlist sheet:', masterlistSheetName);
                console.log('Masterlistæ•°æ®è¡Œæ•°:', masterlistData.length);

                // æ‰“å°æ‰€æœ‰sheetåç§°
                console.log('æ‰€æœ‰sheet:', Object.keys(ecrSheets));

                // è¯»å–Masterlistçš„ç‰¹å¾å€¼ï¼ˆç¬¬4è¡Œæ˜¯ç‰¹å¾å€¼åç§°ï¼‰
                const masterlistFeatureRow = masterlistData[3] || [];
                console.log('Masterlistç‰¹å¾å€¼è¡Œé•¿åº¦:', masterlistFeatureRow.length);
                console.log('Masterlistç‰¹å¾å€¼è¡Œï¼ˆå‰30ä¸ªï¼‰:', masterlistFeatureRow.slice(0, 30));

                // æ‰“å°Masterlistå‰å‡ è¡Œæ•°æ®
                console.log('=== Masterlistæ•°æ®è¡Œ ===');
                for (let i = 4; i < Math.min(10, masterlistData.length); i++) {
                    const row = masterlistData[i];
                    console.log(`ç¬¬${i}è¡Œ: é›¶ä»¶å·=${row[0]}, æ•°æ®=${row.slice(0, 30)}`);
                }

                // æŸ¥æ‰¾åŒ…å«"â—"çš„è¡Œ
                console.log('=== æŸ¥æ‰¾æœ‰â—æ ‡è®°çš„è¡Œ ===');
                for (let i = 4; i < Math.min(20, masterlistData.length); i++) {
                    const row = masterlistData[i];
                    const hasMark = row.some(cell => String(cell) === 'â—');
                    if (hasMark) {
                        console.log(`ç¬¬${i}è¡Œæœ‰â—æ ‡è®°:`, row.slice(0, 30));
                        break;
                    }
                }

                // æ„å»ºé›¶ä»¶å·åˆ°ç‰¹å¾å€¼çš„æ˜ å°„ï¼ˆV4é€»è¾‘ï¼‰- ä½¿ç”¨å…¨å±€å˜é‡
                partFeaturesMap = {};
                for (let i = 2; i < masterlistData.length; i++) {
                    const partNum = masterlistData[i][0];
                    if (!partNum) continue;

                    const partKey = String(partNum).trim();
                    const features = new Set();

                    for (let j = 1; j < masterlistData[i].length; j++) {
                        const cellVal = masterlistData[i][j];
                        if (String(cellVal).trim() === 'â—') {
                            const featureName = masterlistFeatureRow[j];
                            if (featureName) {
                                features.add(String(featureName).trim());
                            }
                        }
                    }
                    partFeaturesMap[partKey] = features;
                }

                showProgress(true, 'å¤„ç†æ•°æ®...', 'æ­£åœ¨ç”ŸæˆWire Chart...');
                updateProgress(40);

                generatedRows = [];
                partNumbers = [];
                let xCount = 0;

                // é»˜è®¤è¡¨å¤´
                function getDefaultHeader() {
                    return ['ACTION', 'CHANGE DATE', 'CIRCUIT NBR', 'WIRE SIZE', 'Luxshare CABLE PART NBR',
                        'CUSTOMER CABLE PART NBR', 'COLOR', 'MARKING COLOR', 'CABLE DESG', 'EST WIRE LENGTH',
                        'GROUP NAME', 'POS NBR 1', 'CAV 1', 'TERMINAL CPN1', 'TERMINAL SPN1', 'TERMINAL LPN1',
                        'TERMINAL CPN2', 'TERMINAL SPN2', 'TERMINAL LPN2', 'SEAL CPN2', 'SEAL SPN 2', 'SEAL LPN 2',
                        'option', 'SEAL CPN1', 'SEAL SPN 1', 'SEAL LPN 1', 'POS NBR 2', 'CAV 2'];
                }

                // ä½¿ç”¨ä¼˜åŒ–çš„è¡¨å¤´å¤„ç†é€»è¾‘
                if (chartFile && chartRows.length > 0) {
                    // æå–æ‰€æœ‰æœ‰æ•ˆè¡¨å¤´è¡Œï¼ˆç”¨äºæ¸²æŸ“ï¼‰
                    const { headerRows, validRowCount } = extractHeaderRows(chartRows, 4);
                    chartHeaderRows = headerRows;
                    console.log(`ä»Chartæ–‡ä»¶ä¸­æå–äº† ${validRowCount} è¡Œæœ‰æ•ˆè¡¨å¤´`);

                    // è·å–åˆ—åï¼šä¿æŒä¸åŸV7é€»è¾‘ä¸€è‡´
                    // åŸV7é€»è¾‘ï¼šå¦‚æœchartRows[2]å­˜åœ¨ä¸”æ˜¯æ•°ç»„ï¼Œä½¿ç”¨chartRows[2]ä½œä¸ºåˆ—å
                    // chartRows[2] æ˜¯åŸæ–‡ä»¶çš„ç¬¬3è¡Œ
                    if (chartRows[2] !== undefined && chartRows[2] !== null) {
                        const row2 = chartRows[2];
                        // å¤„ç†å¯èƒ½çš„åµŒå¥—æ•°ç»„æƒ…å†µ
                        let headerRow = row2;
                        if (Array.isArray(row2) && row2.length > 0 && Array.isArray(row2[0])) {
                            headerRow = row2[0];
                        }
                        chartHeader = Array.isArray(headerRow) ? headerRow.map(cell => normalizeCellValue(cell)) : [];
                        console.log('ä½¿ç”¨åŸæ–‡ä»¶ç¬¬3è¡Œä½œä¸ºåˆ—åï¼Œåˆ—æ•°:', chartHeader.length);
                    } else {
                        // å¦‚æœç¬¬3è¡Œä¸å­˜åœ¨ï¼Œå°è¯•ä»æå–çš„è¡¨å¤´è¡Œä¸­è·å–
                        if (headerRows.length > 0) {
                            // ä½¿ç”¨ç¬¬3è¡Œï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ï¼Œå¦åˆ™ä½¿ç”¨æœ€åä¸€è¡Œ
                            const rowIndex = Math.min(2, headerRows.length - 1);
                            chartHeader = extractColumnNames(headerRows, rowIndex);
                            console.log(`ä½¿ç”¨æå–çš„è¡¨å¤´è¡Œç¬¬${rowIndex + 1}è¡Œä½œä¸ºåˆ—å`);
                        } else {
                            console.log('æœªæ‰¾åˆ°æœ‰æ•ˆè¡¨å¤´è¡Œï¼Œä½¿ç”¨é»˜è®¤è¡¨å¤´');
                            chartHeader = getDefaultHeader();
                            chartHeaderRows = [chartHeader];
                        }
                    }
                } else {
                    chartHeader = getDefaultHeader();
                    chartHeaderRows = [chartHeader];
                }

                // åŠ¨æ€æŸ¥æ‰¾å„åˆ—åœ¨Chartä¸­çš„ç´¢å¼•
                const findColIdx = (name) => chartHeader.findIndex(h => String(h).trim() === name);

                const colIdxMap = {
                    CIRCUIT_NBR: findColIdx('CIRCUIT NBR'),
                    WIRE_SIZE: findColIdx('WIRE SIZE'),
                    COLOR: findColIdx('COLOR'),
                    CABLE_DESG: findColIdx('CABLE DESG'),
                    EST_WIRE_LENGTH: findColIdx('EST WIRE LENGTH'),
                    GROUP_NAME: findColIdx('GROUP NAME'),
                    POS_NBR_1: findColIdx('POS NBR 1'),
                    CAV_1: findColIdx('CAV 1'),
                    OPTION: findColIdx('option'),
                    POS_NBR_2: findColIdx('POS NBR 2'),
                    CAV_2: findColIdx('CAV 2')
                };

                // æŸ¥æ‰¾é›¶ä»¶å·åˆ—
                for (let i = partColStart; i < chartHeader.length; i++) {
                    if (chartHeader[i] && String(chartHeader[i]).trim()) {
                        partNumbers.push(String(chartHeader[i]).trim());
                    }
                }
                console.log('é›¶ä»¶å·æ•°é‡:', partNumbers.length);

                const total = wireData.length - 3;
                const headerLen = chartHeader.length;

                // é¢„è·å–åˆ—ç´¢å¼•
                const circuitNbrIdx = colIdxMap.CIRCUIT_NBR;
                const wireSizeIdx = colIdxMap.WIRE_SIZE;
                const colorIdx = colIdxMap.COLOR;
                const cableDesgIdx = colIdxMap.CABLE_DESG;
                const estWireLenIdx = colIdxMap.EST_WIRE_LENGTH;
                const groupNameIdx = colIdxMap.GROUP_NAME;
                const posNbr1Idx = colIdxMap.POS_NBR_1;
                const cav1Idx = colIdxMap.CAV_1;
                const posNbr2Idx = colIdxMap.POS_NBR_2;
                const cav2Idx = colIdxMap.CAV_2;
                const optionIdx = colIdxMap.OPTION;

                // ä»WIREæå–æ‰€æœ‰å›è·¯æ•°æ®
                for (let i = 3; i < wireData.length; i++) {
                    const row = wireData[i];
                    const wireId = row[1];
                    if (!wireId) continue;

                    const newRow = new Array(headerLen).fill('');
                    const updatedCols = [];

                    // æ‰¹é‡å¡«å……æ•°æ®
                    if (circuitNbrIdx >= 0) { newRow[circuitNbrIdx] = wireId; updatedCols.push(circuitNbrIdx); }
                    if (wireSizeIdx >= 0) { newRow[wireSizeIdx] = row[3]; updatedCols.push(wireSizeIdx); }
                    if (colorIdx >= 0) { newRow[colorIdx] = row[2]; updatedCols.push(colorIdx); }
                    if (cableDesgIdx >= 0) { newRow[cableDesgIdx] = row[4]; updatedCols.push(cableDesgIdx); }
                    if (estWireLenIdx >= 0) { newRow[estWireLenIdx] = row[7]; updatedCols.push(estWireLenIdx); }
                    if (groupNameIdx >= 0) { newRow[groupNameIdx] = row[6]; updatedCols.push(groupNameIdx); }
                    if (posNbr1Idx >= 0) { newRow[posNbr1Idx] = row[8]; updatedCols.push(posNbr1Idx); }
                    if (cav1Idx >= 0) { newRow[cav1Idx] = row[9]; updatedCols.push(cav1Idx); }
                    if (posNbr2Idx >= 0) { newRow[posNbr2Idx] = row[10]; updatedCols.push(posNbr2Idx); }
                    if (cav2Idx >= 0) { newRow[cav2Idx] = row[11]; updatedCols.push(cav2Idx); }
                    if (optionIdx >= 0) { newRow[optionIdx] = row[5] || ''; }

                    // è®¡ç®—Xæ‰“ç‚¹ï¼ˆV4é€»è¾‘ï¼‰
                    const optionExpr = row[5];
                    for (let pi = 0; pi < partNumbers.length; pi++) {
                        const pn = partNumbers[pi];
                        const partFeatures = partFeaturesMap[pn] || new Set();
                        if (calculateOption(optionExpr, Array.from(partFeatures))) {
                            const colIdx = partColStart + pi;
                            if (colIdx < headerLen) {
                                newRow[colIdx] = 'X';
                                xCount++;
                            }
                        }
                    }

                    newRow._updatedCols = updatedCols;
                    generatedRows.push(newRow);

                    if (i % 500 === 0) {
                        const percent = 40 + Math.round((i - 3) / total * 50);
                        updateProgress(percent);
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                updateProgress(95);
                showProgress(true, 'æ¸²æŸ“ä¸­...', 'æ­£åœ¨æ¸²æŸ“è¡¨æ ¼...');

                currentPage = 0;
                totalPages = Math.ceil(generatedRows.length / pageSize);

                renderTable();
                domCache.statsText.textContent = `å›è·¯: ${generatedRows.length} | ç‰¹å¾å€¼: ${partNumbers.length} | Xæ‰“ç‚¹: ${xCount}`;
                domCache.exportBtn.disabled = false;
                domCache.copyBtn.disabled = false;
                // V8: å¯ç”¨å¯¼å‡ºå…¨éƒ¨é›¶ä»¶å·æŒ‰é’®
                domCache.exportAllBtn.disabled = false;
                domCache.emptyState.style.display = 'none';

                updateProgress(100);
                showProgress(false);

            } catch (err) {
                showProgress(false);
                console.error(err);
                alert('å¤„ç†å‡ºé”™: ' + err.message);
            }
        }

        function renderTable() {
            const start = currentPage * pageSize;
            const end = Math.min(start + pageSize, generatedRows.length);
            const pageData = generatedRows.slice(start, end);
            const headerLen = chartHeader.length;

            const fragment = document.createDocumentFragment();
            const table = document.createElement('table');

            // ä½¿ç”¨ä¼˜åŒ–çš„è¡¨å¤´æ¸²æŸ“é€»è¾‘
            if (chartHeaderRows.length > 0) {
                // æ¸²æŸ“æ‰€æœ‰å·²æå–çš„è¡¨å¤´è¡Œ
                for (let h = 0; h < chartHeaderRows.length; h++) {
                    const rowData = chartHeaderRows[h];
                    const headerRow = document.createElement('tr');
                    headerRow.className = `header${h > 0 ? h : ''}`;

                    // ç¡®ä¿è¡¨å¤´è¡Œæœ‰è¶³å¤Ÿçš„åˆ—ï¼ˆä¸ç”Ÿæˆçš„æ•°æ®åˆ—æ•°ä¸€è‡´ï¼‰
                    const rowLen = Math.max(rowData.length, headerLen);
                    for (let col = 0; col < rowLen; col++) {
                        const th = document.createElement('th');
                        const text = col < rowData.length ? rowData[col] : '';
                        th.textContent = text;
                        th.title = text;
                        headerRow.appendChild(th);
                    }
                    table.appendChild(headerRow);
                }
            } else {
                // ä½¿ç”¨é»˜è®¤å•è¡Œè¡¨å¤´ï¼ˆé™çº§å¤„ç†ï¼‰
                const headerRow = document.createElement('tr');
                headerRow.className = 'header';
                for (let col = 0; col < headerLen; col++) {
                    const th = document.createElement('th');
                    const text = chartHeader[col] || '';
                    th.textContent = text;
                    th.title = text;
                    headerRow.appendChild(th);
                }
                table.appendChild(headerRow);
            }

            // æ•°æ®è¡Œ
            for (let rowIdx = 0; rowIdx < pageData.length; rowIdx++) {
                const row = pageData[rowIdx];
                const tr = document.createElement('tr');
                const updatedCols = row._updatedCols;

                for (let col = 0; col < headerLen; col++) {
                    const td = document.createElement('td');
                    let val = row[col];
                    if (val === null || val === undefined) val = '';
                    else if (Array.isArray(val)) val = val.join(',');

                    if (col === 0 && val === 'ACTION') td.className = 'action';
                    else if (updatedCols && updatedCols.includes(col)) td.className = 'updated';
                    else if (val === '') td.className = 'empty';

                    td.textContent = val;
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }

            fragment.appendChild(table);
            domCache.tableContent.innerHTML = '';
            domCache.tableContent.appendChild(fragment);
            domCache.pageInfo.textContent = `${currentPage + 1} / ${totalPages}`;
        }

        function prevPage() {
            if (currentPage > 0) { currentPage--; renderTable(); }
        }

        function nextPage() {
            if (currentPage < totalPages - 1) { currentPage++; renderTable(); }
        }

        function exportExcel() {
            if (!generatedRows.length) return;

            showProgress(true, 'å¯¼å‡ºä¸­...', 'æ­£åœ¨ç”ŸæˆExcel...');

            try {
                const dataRows = generatedRows.map(r => {
                    const newRow = [...r];
                    delete newRow._updatedCols;
                    return newRow;
                });

                let ws;
                // ä½¿ç”¨ä¼˜åŒ–çš„è¡¨å¤´å¯¼å‡ºé€»è¾‘
                if (chartHeaderRows.length > 0) {
                    // ä½¿ç”¨å·²æå–çš„è§„èŒƒåŒ–çš„è¡¨å¤´è¡Œ
                    console.log(`å¯¼å‡º${chartHeaderRows.length}è¡Œè¡¨å¤´`);

                    // ç¡®ä¿æ‰€æœ‰è¡Œéƒ½æœ‰ç›¸åŒçš„åˆ—æ•°ï¼ˆå–æœ€é•¿è¡Œçš„é•¿åº¦ï¼‰
                    const allRows = [...chartHeaderRows, ...dataRows];
                    const maxCols = Math.max(...allRows.map(row => row ? row.length : 0), chartHeader.length);
                    console.log('æœ€é•¿åˆ—æ•°:', maxCols);

                    // å¡«å……æ‰€æœ‰è¡Œåˆ°ç›¸åŒé•¿åº¦
                    const paddedRows = allRows.map(row => {
                        if (!row || row.length === 0) return new Array(maxCols).fill('');
                        if (row.length >= maxCols) return row;
                        return [...row, ...new Array(maxCols - row.length).fill('')];
                    });

                    // ä½¿ç”¨ XLSX.utils.aoa_to_sheet ç¡®ä¿æ‰€æœ‰è¡Œéƒ½è¢«åŒ…å«
                    ws = XLSX.utils.aoa_to_sheet(paddedRows, { skipHeader: true });

                    // æ‰‹åŠ¨è®¾ç½®èŒƒå›´ï¼Œç¡®ä¿æ‰€æœ‰è¡¨å¤´è¡Œéƒ½è¢«åŒ…å«
                    const range = XLSX.utils.decode_range(ws['!ref']);
                    range.e.r = Math.max(range.e.r, chartHeaderRows.length - 1);
                    ws['!ref'] = XLSX.utils.encode_range(range);
                } else {
                    // ä½¿ç”¨é»˜è®¤å•è¡Œè¡¨å¤´
                    ws = XLSX.utils.aoa_to_sheet([chartHeader, ...dataRows]);
                }

                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Wire Chart');
                XLSX.writeFile(wb, 'Wire_Chart_æ›´æ–°.xlsx');

                showProgress(false);
            } catch (err) {
                showProgress(false);
                console.error(err);
                alert('å¯¼å‡ºå¤±è´¥: ' + err.message);
            }
        }

        // V8æ–°å¢ï¼šå¯¼å‡ºå…¨éƒ¨é›¶ä»¶å·çš„Wire Chartï¼ˆåŒ…å«master listä¸­æ‰€æœ‰é›¶ä»¶å·åˆ—ï¼‰
        async function exportAllPartNumberCharts() {
            if (!wireData || !masterlistData || !partFeaturesMap) {
                alert('è¯·å…ˆç”ŸæˆWire Chart');
                return;
            }

            showProgress(true, 'å¯¼å‡ºä¸­...', 'æ­£åœ¨ç”ŸæˆåŒ…å«å…¨éƒ¨é›¶ä»¶å·çš„Chart...');

            try {
                // ä»master listä¸­æå–æ‰€æœ‰é›¶ä»¶å·åŠå…¶åç§°ï¼ˆä¸é‡å¤ï¼‰
                const partNumberMap = new Map(); // é›¶ä»¶å· -> é›¶ä»¶åç§°
                for (let i = 2; i < masterlistData.length; i++) {
                    const partNum = masterlistData[i][0];
                    if (partNum) {
                        const partNumKey = String(partNum).trim();
                        // å‡è®¾ç¬¬2åˆ—ï¼ˆç´¢å¼•1ï¼‰æ˜¯é›¶ä»¶åç§°
                        const partName = masterlistData[i][1] || '';
                        if (!partNumberMap.has(partNumKey)) {
                            partNumberMap.set(partNumKey, String(partName).trim());
                        }
                    }
                }

                // æŒ‰é›¶ä»¶å·æ’åº
                const allPartNumArray = Array.from(partNumberMap.keys()).sort();
                console.log(`Master listä¸­å…±æœ‰ ${allPartNumArray.length} ä¸ªé›¶ä»¶å·`);

                updateProgress(20);

                // æ„å»ºå®Œæ•´è¡¨å¤´ï¼šåŸºç¡€åˆ— + æ‰€æœ‰é›¶ä»¶å·åˆ—
                const baseHeaderLength = partColStart; // 28åˆ—åŸºç¡€åˆ—

                updateProgress(40);

                // è·å–åˆ—ç´¢å¼•æ˜ å°„
                const findColIdx = (name) => chartHeader.findIndex(h => String(h).trim() === name);

                const colIdxMap = {
                    CIRCUIT_NBR: findColIdx('CIRCUIT NBR'),
                    WIRE_SIZE: findColIdx('WIRE SIZE'),
                    COLOR: findColIdx('COLOR'),
                    CABLE_DESG: findColIdx('CABLE DESG'),
                    EST_WIRE_LENGTH: findColIdx('EST WIRE LENGTH'),
                    GROUP_NAME: findColIdx('GROUP NAME'),
                    POS_NBR_1: findColIdx('POS NBR 1'),
                    CAV_1: findColIdx('CAV 1'),
                    OPTION: findColIdx('option'),
                    POS_NBR_2: findColIdx('POS NBR 2'),
                    CAV_2: findColIdx('CAV 2')
                };

                // ä¸ºæ¯ä¸ªå›è·¯ç”Ÿæˆå®Œæ•´æ•°æ®è¡Œ
                const fullRows = [];
                let xCount = 0;
                const total = wireData.length - 3;

                for (let i = 3; i < wireData.length; i++) {
                    const row = wireData[i];
                    const wireId = row[1];
                    if (!wireId) continue;

                    // åˆ›å»ºå®Œæ•´è¡Œ
                    const newRow = new Array(baseHeaderLength + allPartNumArray.length).fill('');

                    // å¡«å……åŸºç¡€åˆ—æ•°æ®
                    const circuitNbrIdx = colIdxMap.CIRCUIT_NBR;
                    const wireSizeIdx = colIdxMap.WIRE_SIZE;
                    const colorIdx = colIdxMap.COLOR;
                    const cableDesgIdx = colIdxMap.CABLE_DESG;
                    const estWireLenIdx = colIdxMap.EST_WIRE_LENGTH;
                    const groupNameIdx = colIdxMap.GROUP_NAME;
                    const posNbr1Idx = colIdxMap.POS_NBR_1;
                    const cav1Idx = colIdxMap.CAV_1;
                    const posNbr2Idx = colIdxMap.POS_NBR_2;
                    const cav2Idx = colIdxMap.CAV_2;
                    const optionIdx = colIdxMap.OPTION;

                    if (circuitNbrIdx >= 0) newRow[circuitNbrIdx] = wireId;
                    if (wireSizeIdx >= 0) newRow[wireSizeIdx] = row[3];
                    if (colorIdx >= 0) newRow[colorIdx] = row[2];
                    if (cableDesgIdx >= 0) newRow[cableDesgIdx] = row[4];
                    if (estWireLenIdx >= 0) newRow[estWireLenIdx] = row[7];
                    if (groupNameIdx >= 0) newRow[groupNameIdx] = row[6];
                    if (posNbr1Idx >= 0) newRow[posNbr1Idx] = row[8];
                    if (cav1Idx >= 0) newRow[cav1Idx] = row[9];
                    if (posNbr2Idx >= 0) newRow[posNbr2Idx] = row[10];
                    if (cav2Idx >= 0) newRow[cav2Idx] = row[11];
                    if (optionIdx >= 0) newRow[optionIdx] = row[5] || '';

                    // è®¡ç®—æ¯ä¸ªé›¶ä»¶å·çš„Xæ‰“ç‚¹
                    const optionExpr = row[5];
                    for (let pi = 0; pi < allPartNumArray.length; pi++) {
                        const pn = allPartNumArray[pi];
                        const partFeatures = partFeaturesMap[pn] || new Set();
                        if (calculateOption(optionExpr, Array.from(partFeatures))) {
                            const colIdx = baseHeaderLength + pi;
                            newRow[colIdx] = 'X';
                            xCount++;
                        }
                    }

                    fullRows.push(newRow);

                    // æ›´æ–°è¿›åº¦
                    if (i % 500 === 0) {
                        const percent = 40 + Math.round((i - 3) / total * 50);
                        updateProgress(percent);
                        await new Promise(r => setTimeout(r, 0));
                    }
                }

                updateProgress(95);

                // å®šä¹‰æ ‡å‡†è¡¨å¤´ï¼ˆ28åˆ—ï¼‰- æŒ‰ç…§æ­£ç¡®çš„é¡ºåº
                const standardHeaderRow1 = [
                    'ACTION', 'CHANGE DATE', 'CIRCUIT NBR', 'WIRE SIZE', 'Luxshare CABLE PART NBR',
                    'CUSTOMER CABLE PART NBR', 'COLOR', 'MARKING COLOR', 'CABLE DESG', 'EST WIRE LENGTH',
                    'GROUP NAME', 'POS NBR 1', 'CAV 1', 'TERMINAL CPN1', 'TERMINAL SPN1', 'TERMINAL LPN1',
                    'SEAL CPN1', 'SEAL SPN 1', 'SEAL LPN 1', 'POS NBR 2', 'CAV 2',
                    'TERMINAL CPN2', 'TERMINAL SPN2', 'TERMINAL LPN2', 'SEAL CPN2', 'SEAL SPN 2', 'SEAL LPN 2', 'option'
                ];

                const standardHeaderRow2 = [
                    'åŠ¨ä½œ', 'æ›´æ”¹æ—¥æœŸ', 'å¯¼çº¿å·', 'æˆªé¢ç§¯', 'ç«‹è®¯å¯¼çº¿å·', 'å®¢æˆ·å¯¼çº¿å·', 'é¢œè‰²', 'ä¸­æ–‡é¢œè‰²',
                    'å¯¼çº¿ç±»å‹', 'é•¿åº¦', 'ç»„å', 'From', 'Pin1', 'ç«¯å­å®¢æˆ·å·', 'ç«¯å­ä¾›åº”å•†å·', 'ç«¯å­ç«‹è®¯å·',
                    'å¯†å°ä»¶å®¢æˆ·å·', 'å¯†å°ä»¶ä¾›åº”å•†å·', 'å¯†å°ä»¶ç«‹è®¯å·', 'To', 'Pin2',
                    'ç«¯å­å®¢æˆ·å·', 'ç«¯å­ä¾›åº”å•†å·', 'ç«¯å­ç«‹è®¯å·', 'å¯†å°ä»¶å®¢æˆ·å·', 'å¯†å°ä»¶ä¾›åº”å•†å·', 'å¯†å°ä»¶ç«‹è®¯å·', 'åŠŸèƒ½'
                ];

                // æ„å»ºä¸¤è¡Œè¡¨å¤´
                const headerRow1 = [...standardHeaderRow1]; // ç¬¬ä¸€è¡Œï¼šè‹±æ–‡åˆ—å + é›¶ä»¶å·
                const headerRow2 = [...standardHeaderRow2]; // ç¬¬äºŒè¡Œï¼šä¸­æ–‡åˆ—å + é›¶ä»¶åç§°

                // æ·»åŠ æ‰€æœ‰é›¶ä»¶å·åˆ—ï¼ˆç¬¬ä¸€è¡Œï¼šé›¶ä»¶å·ï¼Œç¬¬äºŒè¡Œï¼šé›¶ä»¶åç§°ï¼‰
                for (const partNum of allPartNumArray) {
                    headerRow1.push(partNum);
                    headerRow2.push(partNumberMap.get(partNum) || '');
                }

                const exportRows = [headerRow1, headerRow2, ...fullRows];

                console.log(`å‡†å¤‡å¯¼å‡º ${exportRows.length} è¡Œæ•°æ®ï¼ŒåŒ…å« ${allPartNumArray.length} ä¸ªé›¶ä»¶å·ï¼Œå…± ${xCount} ä¸ªXæ‰“ç‚¹`);

                // åˆ›å»ºworksheet
                const ws = XLSX.utils.aoa_to_sheet(exportRows, { skipHeader: true });

                const wb = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(wb, ws, 'Wire Chart_å…¨éƒ¨é›¶ä»¶å·');

                updateProgress(100);
                XLSX.writeFile(wb, 'Wire_Chart_å…¨éƒ¨é›¶ä»¶å·.xlsx');

                showProgress(false);
                alert(`æˆåŠŸå¯¼å‡ºï¼\né›¶ä»¶å·æ•°é‡: ${allPartNumArray.length}\nå›è·¯æ•°é‡: ${fullRows.length}\nXæ‰“ç‚¹æ€»æ•°: ${xCount}`);

            } catch (err) {
                showProgress(false);
                console.error(err);
                alert('å¯¼å‡ºå¤±è´¥: ' + err.message);
            }
        }

        function copyHtml() {
            if (!generatedRows.length) {
                alert('æ²¡æœ‰å†…å®¹å¯å¤åˆ¶');
                return;
            }

            const sb = [];
            sb.push(chartHeader.map(h => String(h || '')).join('\t'));
            for (let i = 0; i < generatedRows.length; i++) {
                const row = generatedRows[i];
                sb.push(row.map(val => String(val || '')).join('\t'));
            }
            const text = sb.join('\n');

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text).then(() => {
                    alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                }).catch(() => {
                    fallbackCopy(text);
                });
            } else {
                fallbackCopy(text);
            }
        }

        function fallbackCopy(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.left = '-9999px';
            textarea.style.top = '-9999px';
            document.body.appendChild(textarea);
            textarea.select();
            textarea.setSelectionRange(0, 999999);

            try {
                const successful = document.execCommand('copy');
                document.body.removeChild(textarea);
                if (successful) {
                    alert('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
                } else {
                    alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶');
                }
            } catch (err) {
                document.body.removeChild(textarea);
                alert('å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨é€‰æ‹©å¤åˆ¶');
            }
        }

        // åˆå§‹åŒ–
        initDomCache();

        // è°ƒè¯•ï¼šéªŒè¯å…³é”®å‡½æ•°å·²åŠ è½½
        window.addEventListener('DOMContentLoaded', function() {
            console.log('é¡µé¢å·²åŠ è½½');
            console.log('selectFile å‡½æ•°æ˜¯å¦å­˜åœ¨:', typeof selectFile !== 'undefined');
            console.log('generateData å‡½æ•°æ˜¯å¦å­˜åœ¨:', typeof generateData !== 'undefined');
            console.log('exportExcel å‡½æ•°æ˜¯å¦å­˜åœ¨:', typeof exportExcel !== 'undefined');
            console.log('æ‰€æœ‰å…¨å±€å‡½æ•°:', Object.keys(window).filter(k => typeof window[k] === 'function').slice(-10));
        });
    </script>
</body>
</html>
