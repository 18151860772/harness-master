<!DOCTYPE html>
<html lang="zh-CN">
<!--
    Master List æ¯”å¯¹å·¥å…·
    ç‰ˆæœ¬: v2.5 - 2025-01-10
    æ›´æ–°: å»é™¤ALLç‰¹æ®Šè¯†åˆ«é€»è¾‘ï¼ŒALLä½œä¸ºé…ç½®åˆ—ä½¿ç”¨(é›¶ä»¶å·+ALL)ä½œä¸ºkeyå¯¹æ¯”æ•°æ®
    ç‰ˆæœ¬å†å²:
    - v2.4 - æ·±åº¦ä¿®å¤ALLåˆ—è¯†åˆ«é€»è¾‘ï¼Œé€šè¿‡ç´¢å¼•åŒ¹é…è€ŒékeyåŒ¹é…ï¼Œç¡®ä¿ALLåˆ—æ€»æ˜¯æ­£ç¡®æ˜¾ç¤º
    - v2.3 - ä¿®å¤ALLåˆ—ä¸æ˜¾ç¤ºçš„é—®é¢˜ï¼Œç¡®ä¿ALLåˆ—æ€»æ˜¯è¢«åŒ…å«åœ¨é…ç½®åˆ—ä¸­
    - v2.2 - åˆ é™¤çš„åˆ—ä¿æŒåŸå§‹ä½ç½®ï¼Œè€Œä¸æ˜¯æ”¾åœ¨æœ€å
    - v2.1 - ä¸ºå‰4è¡Œè¡¨å¤´æ·»åŠ å›ºå®šheight:38pxï¼Œé˜²æ­¢æ»šåŠ¨æ—¶è¡Œé«˜å˜åŒ–
    - v2.0 - ä¿®æ­£å‰4è¡Œå†»ç»“çš„topå€¼å’Œz-indexå±‚çº§ï¼Œç¡®ä¿æ»šåŠ¨æ—¶æ­£ç¡®æ˜¾ç¤º
    - v1.9 - å‰4è¡Œå­—ä½“æ”¹ä¸ºé»‘è‰²ï¼Œä¼˜åŒ–å†»ç»“è®¾ç½®ç¡®ä¿æ­£ç¡®ç”Ÿæ•ˆ
    - v1.8 - ä¿®å¤ç¬¬1è¡Œå†»ç»“é—®é¢˜ï¼Œç¡®ä¿å‰4è¡Œå…¨éƒ¨æ­£ç¡®å†»ç»“
    - v1.7 - æ¢å¤å‰4è¡Œè¡¨å¤´å…¨éƒ¨å†»ç»“ï¼Œæ»šåŠ¨æ—¶ä¿æŒä¸åŠ¨
    - v1.6 - æ–°å¢è¡Œå’Œæ–°å¢åˆ—çš„å­—ä½“é¢œè‰²æ”¹ä¸ºé»‘è‰²
    - v1.5 - æ–°å¢åˆ—ç”¨ç»¿è‰²æ ‡è®°ï¼Œä¸åˆ é™¤åˆ—ï¼ˆçº¢è‰²ï¼‰å½¢æˆå¯¹æ¯”
    - v1.4 - æ—§ç‰ˆåˆ é™¤çš„åˆ—å’Œåˆ é™¤çš„è¡Œåœ¨æ–°ç‰ˆä¸­æ˜¾ç¤ºï¼Œç”¨çº¢è‰²æ ‡è®°
    - v1.3 - å˜æ›´å•å…ƒæ ¼åªæ˜¾ç¤ºæ–°å€¼ï¼Œä¸å†æ˜¾ç¤º"æ—§å€¼ â†’ æ–°å€¼"æ ¼å¼
    - v1.2 - æ‰€æœ‰å­—ä½“è®¾ç½®ä¸ºé»‘è‰²ï¼Œæœ‰å˜åŒ–ç‚¹çš„è¡Œçš„é›¶ä»¶å·æ ‡è®°ä¸ºé»„è‰²
    - v1.1 - é¡µé¢å®½åº¦å¢åŠ ä¸€å€ï¼Œåªå†»ç»“ç¬¬4è¡Œä½œä¸ºè¡¨å¤´ï¼Œé¢„è§ˆç•Œé¢å……æ»¡å±å¹•
    - v1.0 - åˆå§‹ç‰ˆæœ¬ï¼Œå‰4è¡Œå†»ç»“
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Master List æ¯”å¯¹å·¥å…· v2.5</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 2800px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 28px;
        }

        .upload-section {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
            justify-content: center;
        }

        .upload-box {
            flex: 1;
            max-width: 400px;
            border: 3px dashed #667eea;
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            transition: all 0.3s;
            background: #f8f9ff;
        }

        .upload-box:hover {
            border-color: #764ba2;
            background: #f0f1ff;
        }

        .upload-box.dragover {
            border-color: #4CAF50;
            background: #e8f5e9;
        }

        .upload-box input[type="file"] {
            display: none;
        }

        .upload-box label {
            display: block;
            cursor: pointer;
            color: #667eea;
            font-weight: bold;
            font-size: 16px;
        }

        .upload-box .file-name {
            margin-top: 10px;
            color: #666;
            font-size: 14px;
            word-break: break-all;
        }

        .upload-box .status {
            margin-top: 10px;
            font-size: 12px;
        }

        .upload-box .status.success {
            color: #4CAF50;
        }

        .upload-box .status.error {
            color: #f44336;
        }

        .button-section {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
        }

        button {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-compare {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-compare:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .btn-compare:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .btn-export {
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
        }

        .btn-export:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(76, 175, 80, 0.4);
        }

        .btn-export:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .loading {
            text-align: center;
            color: #667eea;
            font-size: 18px;
            margin: 20px 0;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .result-section {
            margin-top: 30px;
            display: none;
        }

        .result-section.show {
            display: block;
        }

        .summary {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .summary h3 {
            color: #333;
            margin-bottom: 15px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .summary-item {
            background: white;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .summary-item .number {
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .summary-item.modified .number {
            color: #FFC107;
        }

        .summary-item.added .number {
            color: #4CAF50;
        }

        .summary-item.deleted .number {
            color: #f44336;
        }

        .summary-item .label {
            color: #666;
            font-size: 14px;
        }

        .preview-section {
            margin-top: 20px;
        }

        .preview-section h3 {
            margin-bottom: 15px;
            color: #333;
        }

        .table-container {
            overflow: auto;
            max-height: calc(100vh - 200px);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            position: relative;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        table {
            border-collapse: separate;
            border-spacing: 0;
            font-size: 13px;
        }

        th, td {
            border: 1px solid #e8e8e8;
            padding: 8px 12px;
            text-align: left;
            line-height: 1.5;
            vertical-align: top;
            color: black;
        }

        /* è¡¨å¤´ - å‰4è¡Œå›ºå®š */
        thead th {
            font-weight: 600;
            font-size: 13px;
            background: #667eea;
            color: black;
            position: sticky;
            height: 38px;
            box-sizing: border-box;
            vertical-align: middle;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis;
        }

        /* å‰4è¡Œè¡¨å¤´å…¨éƒ¨å†»ç»“ - å›ºå®šè¡Œé«˜38px */
        thead tr:nth-child(1) th {
            position: sticky !important;
            top: 0;
            z-index: 20;
        }
        thead tr:nth-child(2) th {
            position: sticky !important;
            top: 38px;
            z-index: 21;
        }
        thead tr:nth-child(3) th {
            position: sticky !important;
            top: 76px;
            z-index: 22;
        }
        thead tr:nth-child(4) th {
            position: sticky !important;
            top: 114px;
            z-index: 23;
        }

        /* é¦–åˆ—å›ºå®š - ç¡®ä¿æœ‰èƒŒæ™¯è‰²é¿å…é®æŒ¡ */
        td:first-child {
            position: sticky;
            left: 0;
            z-index: 15;
            background: #fff;
            font-weight: 600;
        }

        /* æ–‘é©¬çº¹è¡Œçš„é¦–åˆ—ä¿æŒèƒŒæ™¯è‰² */
        tbody tr:nth-child(even) td:first-child {
            background: #fafafa;
        }

        /* æ‚¬åœçŠ¶æ€çš„é¦–åˆ— */
        tbody tr:hover td:first-child {
            background: #f0f7ff;
        }

        /* æ–°å¢/åˆ é™¤è¡Œçš„é¦–åˆ— */
        .row-added td:first-child {
            background: #4CAF50 !important;
            color: black;
        }

        .row-deleted td:first-child {
            background: #f44336 !important;
            color: white;
        }

        /* æœ‰å˜åŒ–ç‚¹çš„è¡Œçš„é›¶ä»¶å·æ ‡è®°ä¸ºé»„è‰² */
        .has-changes td:first-child {
            background-color: #FFC107 !important;
            font-weight: bold;
        }

        thead th:first-child {
            z-index: 50;
            background: #5568d3;
        }

        .cell-modified {
            background-color: #FFC107 !important;
        }

        .cell-added {
            background-color: #4CAF50 !important;
            color: black;
        }

        .cell-deleted {
            background-color: #f44336 !important;
            color: white;
        }

        .row-added {
            background-color: #4CAF50 !important;
            color: black;
        }

        .row-deleted {
            background-color: #f44336 !important;
            color: white;
            text-decoration: line-through;
        }

        .col-header-added {
            background-color: #4CAF50 !important;
        }

        .col-header-deleted {
            background-color: #f44336 !important;
        }

        /* æ–‘é©¬çº¹è¡Œ */
        tbody tr:nth-child(even) {
            background-color: #fafafa;
        }

        tbody tr:hover {
            background-color: #f0f7ff;
        }

        .legend {
            display: flex;
            gap: 20px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .legend-color {
            width: 30px;
            height: 20px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .legend-color.modified {
            background-color: #FFC107;
        }

        .legend-color.added {
            background-color: #4CAF50;
        }

        .legend-color.deleted {
            background-color: #f44336;
        }

        .filter-section {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .filter-section span {
            font-weight: bold;
            color: #333;
        }

        .filter-btn {
            padding: 8px 20px;
            font-size: 14px;
            border: 2px solid #ddd;
            border-radius: 6px;
            background: white;
            color: #666;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .filter-btn:hover {
            border-color: #667eea;
            color: #667eea;
        }

        .filter-btn.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .filter-btn.count {
            min-width: 80px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Master List æ¯”å¯¹å·¥å…· v2.5</h1>

        <div class="upload-section">
            <div class="upload-box" id="uploadBox1">
                <input type="file" id="file1" accept=".xlsx,.xls">
                <label for="file1">
                    <div>ğŸ“ ç‚¹å‡»ä¸Šä¼ æ—§ç‰ˆæœ¬æ–‡ä»¶</div>
                    <div class="file-name" id="fileName1">æœªé€‰æ‹©æ–‡ä»¶</div>
                </label>
                <div class="status" id="status1"></div>
            </div>

            <div class="upload-box" id="uploadBox2">
                <input type="file" id="file2" accept=".xlsx,.xls">
                <label for="file2">
                    <div>ğŸ“ ç‚¹å‡»ä¸Šä¼ æ–°ç‰ˆæœ¬æ–‡ä»¶</div>
                    <div class="file-name" id="fileName2">æœªé€‰æ‹©æ–‡ä»¶</div>
                </label>
                <div class="status" id="status2"></div>
            </div>
        </div>

        <div class="button-section">
            <button class="btn-compare" id="compareBtn" disabled>å¼€å§‹æ¯”å¯¹</button>
            <button class="btn-export" id="exportBtn" disabled>å¯¼å‡ºç»“æœ</button>
        </div>

        <div class="loading" id="loading">æ­£åœ¨å¤„ç†æ•°æ®ï¼Œè¯·ç¨å€™...</div>

        <div class="result-section" id="resultSection">
            <div class="summary">
                <h3>æ¯”å¯¹ç»“æœæ‘˜è¦</h3>
                <div class="summary-grid">
                    <div class="summary-item modified">
                        <div class="number" id="modifiedCount">0</div>
                        <div class="label">å•å…ƒæ ¼å˜æ›´</div>
                    </div>
                    <div class="summary-item added">
                        <div class="number" id="addedRowsCount">0</div>
                        <div class="label">æ–°å¢è¡Œ</div>
                    </div>
                    <div class="summary-item deleted">
                        <div class="number" id="deletedRowsCount">0</div>
                        <div class="label">åˆ é™¤è¡Œ</div>
                    </div>
                    <div class="summary-item added">
                        <div class="number" id="addedColsCount">0</div>
                        <div class="label">æ–°å¢åˆ—</div>
                    </div>
                    <div class="summary-item deleted">
                        <div class="number" id="deletedColsCount">0</div>
                        <div class="label">åˆ é™¤åˆ—</div>
                    </div>
                </div>
            </div>

            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color modified"></div>
                    <span>å•å…ƒæ ¼å˜æ›´ï¼ˆé»„è‰²ï¼‰</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color added"></div>
                    <span>æ–°å¢ï¼ˆç»¿è‰²ï¼‰</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color deleted"></div>
                    <span>åˆ é™¤ï¼ˆçº¢è‰²ï¼‰</span>
                </div>
            </div>

            <div class="preview-section">
                <h3>é¢„è§ˆï¼ˆå…¨éƒ¨ï¼‰</h3>
                <div class="filter-section">
                    <span>ç­›é€‰ï¼š</span>
                    <button class="filter-btn count active" data-filter="all">å…¨éƒ¨ (0)</button>
                    <button class="filter-btn count" data-filter="added">æ–°å¢ (0)</button>
                    <button class="filter-btn count" data-filter="deleted">åˆ é™¤ (0)</button>
                    <button class="filter-btn count" data-filter="modified">å˜æ›´ (0)</button>
                </div>
                <div class="table-container" id="tableContainer"></div>
            </div>
        </div>
    </div>

    <script>
        let workbook1 = null;
        let workbook2 = null;
        let comparisonResult = null;
        let currentFilter = 'all';

        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        function setupFileUpload(fileInputId, fileNameId, statusId, uploadBoxId) {
            const fileInput = document.getElementById(fileInputId);
            const fileNameEl = document.getElementById(fileNameId);
            const statusEl = document.getElementById(statusId);
            const uploadBox = document.getElementById(uploadBoxId);

            fileInput.addEventListener('change', async (e) => {
                const file = e.target.files[0];
                if (!file) return;

                fileNameEl.textContent = file.name;
                statusEl.textContent = 'æ­£åœ¨åŠ è½½...';
                statusEl.className = 'status';

                try {
                    const data = await file.arrayBuffer();
                    const workbook = XLSX.read(data, { type: 'array', cellStyles: true });

                    if (fileInputId === 'file1') {
                        workbook1 = workbook;
                    } else {
                        workbook2 = workbook;
                    }

                    statusEl.textContent = 'âœ“ åŠ è½½æˆåŠŸ';
                    statusEl.className = 'status success';
                    checkBothFilesLoaded();
                } catch (error) {
                    statusEl.textContent = 'âœ— åŠ è½½å¤±è´¥: ' + error.message;
                    statusEl.className = 'status error';
                }
            });

            // æ‹–æ‹½ä¸Šä¼ 
            uploadBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadBox.classList.add('dragover');
            });

            uploadBox.addEventListener('dragleave', () => {
                uploadBox.classList.remove('dragover');
            });

            uploadBox.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadBox.classList.remove('dragover');

                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    fileInput.dispatchEvent(new Event('change'));
                }
            });
        }

        setupFileUpload('file1', 'fileName1', 'status1', 'uploadBox1');
        setupFileUpload('file2', 'fileName2', 'status2', 'uploadBox2');

        function checkBothFilesLoaded() {
            const compareBtn = document.getElementById('compareBtn');
            if (workbook1 && workbook2) {
                compareBtn.disabled = false;
            }
        }

        // è¯»å–ç¬¬8ä¸ªsheetï¼ˆç´¢å¼•7ï¼‰åŠåˆ—å®½ä¿¡æ¯
        function readSheetData(workbook) {
            const sheetName = workbook.SheetNames[7];
            const worksheet = workbook.Sheets[sheetName];
            const data = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });

            // è·å–åˆ—å®½ä¿¡æ¯
            const colWidths = [];
            if (worksheet['!cols']) {
                worksheet['!cols'].forEach(col => {
                    // Excelåˆ—å®½å•ä½è½¬æ¢ï¼š1å•ä½ â‰ˆ 7åƒç´ 
                    const width = col.wch ? Math.round(col.wch * 7) : 100;
                    colWidths.push(width);
                });
            }

            return { data, colWidths };
        }

        // è·å–å•å…ƒæ ¼å€¼
        function getCellValue(row, col) {
            if (!row || col >= row.length) return '';
            return row[col] || '';
        }

        // è§£æåˆ—ç»“æ„
        function parseColumnStructure(data) {
            if (data.length < 4) return { fixed: [], model: [], config: [] };

            const headerRow3 = data[3] || []; // ç¬¬4è¡Œï¼ˆç´¢å¼•3ï¼‰
            const totalCols = headerRow3.length;

            const result = {
                fixed: [],
                model: [],
                config: []
            };

            // å‰8åˆ—ä¸ºå›ºå®šåˆ—
            for (let i = 0; i < Math.min(8, totalCols); i++) {
                result.fixed.push(i);
            }

            // ä»ç¬¬8åˆ—å¼€å§‹ï¼ŒåŒºåˆ†æ•°å­—ï¼ˆè½¦å‹ï¼‰å’Œå­—æ¯ï¼ˆé…ç½®ï¼ŒåŒ…æ‹¬ALLï¼‰
            for (let i = 8; i < totalCols; i++) {
                const cellValue = String(getCellValue(headerRow3, i)).trim();
                if (/^\d+$/.test(cellValue)) {
                    // æ•°å­—åˆ—ä¸ºè½¦å‹åˆ—
                    result.model.push({ index: i, key: cellValue });
                } else {
                    // å­—æ¯åˆ—ä¸ºé…ç½®åˆ—ï¼ˆåŒ…æ‹¬ALLï¼‰
                    result.config.push({ index: i, key: cellValue || `Config_${i}` });
                }
            }

            return result;
        }

        // æ¯”å¯¹ä¸¤ä¸ªExcel
        function compareExcel(data1, data2, colWidths) {
            const structure1 = parseColumnStructure(data1);
            const structure2 = parseColumnStructure(data2);

            // æ”¶é›†æ‰€æœ‰åˆ—ä¿¡æ¯ - æŒ‰åˆ—ååˆ¤æ–­æ˜¯å¦çœŸæ­£çš„æ–°å¢/åˆ é™¤
            const allColumns = new Map(); // key: æ–°ç‰ˆæœ¬ç´¢å¼•, value: { index, key, existsInV1, existsInV2, type }
            const deletedColumnsInfo = []; // è®°å½•çœŸæ­£åˆ é™¤çš„åˆ—

            // æ·»åŠ æ–°ç‰ˆæœ¬çš„åˆ—
            structure2.model.forEach(m => {
                const existsInV1 = structure1.model.some(m1 => m1.key === m.key);
                allColumns.set(m.index, {
                    index: m.index,
                    key: m.key,
                    existsInV1,
                    existsInV2: true,
                    type: 'model',
                    isAdded: !existsInV1  // æ ‡è®°æ–°å¢åˆ—
                });
            });

            structure2.config.forEach(c => {
                const existsInV1 = structure1.config.some(c1 => c1.key === c.key);
                allColumns.set(c.index, {
                    index: c.index,
                    key: c.key,
                    existsInV1,
                    existsInV2: true,
                    type: 'config',
                    isAdded: !existsInV1  // æ ‡è®°æ–°å¢åˆ—
                });
            });

            // æ‰¾å‡ºçœŸæ­£åˆ é™¤çš„åˆ—ï¼ˆåªå­˜åœ¨äºæ—§ç‰ˆæœ¬ï¼Œä¸å­˜åœ¨äºæ–°ç‰ˆæœ¬ï¼‰
            structure1.model.forEach(m => {
                const existsInV2 = structure2.model.some(m2 => m2.key === m.key);
                if (!existsInV2) {
                    deletedColumnsInfo.push({ ...m, type: 'model' });
                }
            });

            structure1.config.forEach(c => {
                const existsInV2 = structure2.config.some(c2 => c2.key === c.key);
                if (!existsInV2) {
                    deletedColumnsInfo.push({ ...c, type: 'config' });
                }
            });

            // å°†åˆ é™¤çš„åˆ—ä¹Ÿæ·»åŠ åˆ°æ˜¾ç¤ºä¸­ï¼Œä¿æŒåŸå§‹ä½ç½®
            deletedColumnsInfo.forEach((col) => {
                allColumns.set(col.index, {
                    index: col.index, // ä½¿ç”¨åŸå§‹ç´¢å¼•
                    key: col.key,
                    existsInV1: true,
                    existsInV2: false, // æ ‡è®°ä¸ºåˆ é™¤
                    type: col.type,
                    isDeleted: true
                });
            });

            // æ·»åŠ å›ºå®šåˆ—
            for (let i = 0; i < 8; i++) {
                if (!allColumns.has(i)) {
                    allColumns.set(i, {
                        index: i,
                        key: '',
                        existsInV1: true,
                        existsInV2: true,
                        type: 'fixed'
                    });
                }
            }

            const sortedColumns = Array.from(allColumns.keys()).sort((a, b) => a - b);

            // æ„å»ºè½¦å‹å’Œé…ç½®çš„æ˜ å°„ï¼šé›¶ä»¶å·+è½¦å‹/é…ç½® -> è¡Œç´¢å¼•+åˆ—ç´¢å¼•
            const modelData1 = new Map(); // key: "é›¶ä»¶å·_è½¦å‹", value: { rowIdx, colIdx, value }
            const modelData2 = new Map();
            const configData1 = new Map(); // key: "é›¶ä»¶å·_é…ç½®", value: { rowIdx, colIdx, value }
            const configData2 = new Map();
            const fixedData1 = new Map(); // key: é›¶ä»¶å·, value: rowIdx
            const fixedData2 = new Map();

            // ä»ç¬¬5è¡Œå¼€å§‹ï¼ˆç´¢å¼•4ï¼‰ä¸ºæ•°æ®è¡Œ
            for (let i = 4; i < data1.length; i++) {
                const partNo = String(getCellValue(data1[i], 0)).trim();
                if (!partNo) continue;

                fixedData1.set(partNo, i);

                // æ”¶é›†è½¦å‹æ•°æ®
                structure1.model.forEach(m => {
                    const key = `${partNo}_${m.key}`;
                    const value = getCellValue(data1[i], m.index);
                    modelData1.set(key, { rowIdx: i, colIdx: m.index, value, modelKey: m.key, partNo });
                });

                // æ”¶é›†é…ç½®æ•°æ®
                structure1.config.forEach(c => {
                    const key = `${partNo}_${c.key}`;
                    const value = getCellValue(data1[i], c.index);
                    configData1.set(key, { rowIdx: i, colIdx: c.index, value, configKey: c.key, partNo });
                });
            }

            for (let i = 4; i < data2.length; i++) {
                const partNo = String(getCellValue(data2[i], 0)).trim();
                if (!partNo) continue;

                fixedData2.set(partNo, i);

                // æ”¶é›†è½¦å‹æ•°æ®
                structure2.model.forEach(m => {
                    const key = `${partNo}_${m.key}`;
                    const value = getCellValue(data2[i], m.index);
                    modelData2.set(key, { rowIdx: i, colIdx: m.index, value, modelKey: m.key, partNo });
                });

                // æ”¶é›†é…ç½®æ•°æ®
                structure2.config.forEach(c => {
                    const key = `${partNo}_${c.key}`;
                    const value = getCellValue(data2[i], c.index);
                    configData2.set(key, { rowIdx: i, colIdx: c.index, value, configKey: c.key, partNo });
                });
            }

            // è¯†åˆ«æ–°å¢å’Œåˆ é™¤çš„åˆ—
            const addedColumns = [];
            const deletedColumns = [];

            const modelKeys1 = new Set(structure1.model.map(m => m.key));
            const modelKeys2 = new Set(structure2.model.map(m => m.key));
            const configKeys1 = new Set(structure1.config.map(c => c.key));
            const configKeys2 = new Set(structure2.config.map(c => c.key));

            // åˆ›å»ºåˆ—ååˆ°æ–°ç‰ˆæœ¬çš„ç´¢å¼•æ˜ å°„ï¼ˆç”¨äºæ˜¾ç¤ºï¼‰
            const modelKeyToIndex2 = new Map();
            structure2.model.forEach(m => modelKeyToIndex2.set(m.key, m.index));
            const configKeyToIndex2 = new Map();
            structure2.config.forEach(c => configKeyToIndex2.set(c.key, c.index));

            structure2.model.forEach(m => {
                if (!modelKeys1.has(m.key)) {
                    addedColumns.push({ index: m.index, key: m.key, type: 'model' });
                }
            });

            structure1.model.forEach(m => {
                if (!modelKeys2.has(m.key)) {
                    deletedColumns.push({ index: m.index, key: m.key, type: 'model' });
                }
            });

            structure2.config.forEach(c => {
                if (!configKeys1.has(c.key)) {
                    addedColumns.push({ index: c.index, key: c.key, type: 'config' });
                }
            });

            structure1.config.forEach(c => {
                if (!configKeys2.has(c.key)) {
                    deletedColumns.push({ index: c.index, key: c.key, type: 'config' });
                }
            });

            // æ„å»ºç»“æœ
            const result = {
                rows: [],
                summary: {
                    modifiedCells: 0,
                    addedRows: 0,
                    deletedRows: 0,
                    addedColumns: addedColumns.length,
                    deletedColumns: deletedColumns.length
                },
                columnInfo: {
                    added: addedColumns,
                    deleted: deletedColumns
                }
            };

            // æ”¶é›†æ‰€æœ‰å·®å¼‚
            const differences = new Map(); // key: é›¶ä»¶å·, value: { status, cells:[] }

            // å¯¹æ¯”å›ºå®šåˆ—ï¼ˆå‰8åˆ—ï¼‰
            const allPartNumbers = new Set([...fixedData1.keys(), ...fixedData2.keys()]);

            allPartNumbers.forEach(partNo => {
                const row1Idx = fixedData1.get(partNo);
                const row2Idx = fixedData2.get(partNo);

                if (row1Idx === undefined) {
                    // æ–°å¢é›¶ä»¶å·
                    differences.set(partNo, { status: 'added', partNo, row2Idx, changes: [] });
                } else if (row2Idx === undefined) {
                    // åˆ é™¤é›¶ä»¶å·
                    differences.set(partNo, { status: 'deleted', partNo, row1Idx, changes: [] });
                } else {
                    // ä¸¤è¡Œéƒ½å­˜åœ¨ï¼Œæ£€æŸ¥å›ºå®šåˆ—æ˜¯å¦æœ‰å˜åŒ–
                    const changes = [];
                    for (let colIdx = 0; colIdx < 8; colIdx++) {
                        const val1 = getCellValue(data1[row1Idx], colIdx);
                        const val2 = getCellValue(data2[row2Idx], colIdx);
                        if (String(val1).trim() !== String(val2).trim()) {
                            changes.push({
                                type: 'fixed',
                                colIndex: colIdx,
                                changeType: 'modified',
                                oldValue: val1,
                                newValue: val2
                            });
                        }
                    }

                    differences.set(partNo, {
                        status: changes.length > 0 ? 'modified' : 'unchanged',
                        partNo,
                        row1Idx,
                        row2Idx,
                        changes
                    });
                }
            });

            // å¯¹æ¯”è½¦å‹åˆ—
            const allModelKeys = new Set([...modelData1.keys(), ...modelData2.keys()]);

            allModelKeys.forEach(key => {
                const data1Item = modelData1.get(key);
                const data2Item = modelData2.get(key);
                const { partNo } = data2Item || data1Item;

                const diff = differences.get(partNo);

                // åªå¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬éƒ½å­˜åœ¨çš„é›¶ä»¶å·
                if (!diff || diff.status === 'added' || diff.status === 'deleted') {
                    return;
                }

                if (data1Item && !data2Item) {
                    // åˆ é™¤çš„è½¦å‹
                    if (diff.status === 'unchanged') diff.status = 'modified';
                    diff.changes.push({
                        type: 'model',
                        modelKey: data1Item.modelKey,
                        colIndex: data1Item.colIdx,
                        changeType: 'deleted',
                        value: data1Item.value
                    });
                } else if (!data1Item && data2Item) {
                    // æ–°å¢çš„è½¦å‹
                    if (diff.status === 'unchanged') diff.status = 'modified';
                    diff.changes.push({
                        type: 'model',
                        modelKey: data2Item.modelKey,
                        colIndex: data2Item.colIdx,
                        changeType: 'added',
                        value: data2Item.value
                    });
                } else if (data1Item && data2Item) {
                    // å¯¹æ¯”å€¼
                    if (String(data1Item.value).trim() !== String(data2Item.value).trim()) {
                        if (diff.status === 'unchanged') diff.status = 'modified';
                        diff.changes.push({
                            type: 'model',
                            modelKey: data1Item.modelKey,
                            colIndex: data1Item.colIdx,
                            changeType: 'modified',
                            oldValue: data1Item.value,
                            newValue: data2Item.value
                        });
                    }
                }
            });

            // å¯¹æ¯”é…ç½®åˆ—
            const allConfigKeys = new Set([...configData1.keys(), ...configData2.keys()]);

            allConfigKeys.forEach(key => {
                const data1Item = configData1.get(key);
                const data2Item = configData2.get(key);
                const { partNo } = data2Item || data1Item;

                const diff = differences.get(partNo);

                // åªå¯¹æ¯”ä¸¤ä¸ªç‰ˆæœ¬éƒ½å­˜åœ¨çš„é›¶ä»¶å·
                if (!diff || diff.status === 'added' || diff.status === 'deleted') {
                    return;
                }

                if (data1Item && !data2Item) {
                    // åˆ é™¤çš„é…ç½®
                    if (diff.status === 'unchanged') diff.status = 'modified';
                    diff.changes.push({
                        type: 'config',
                        configKey: data1Item.configKey,
                        colIndex: data1Item.colIdx,
                        changeType: 'deleted',
                        value: data1Item.value
                    });
                } else if (!data1Item && data2Item) {
                    // æ–°å¢çš„é…ç½®
                    if (diff.status === 'unchanged') diff.status = 'modified';
                    diff.changes.push({
                        type: 'config',
                        configKey: data2Item.configKey,
                        colIndex: data2Item.colIdx,
                        changeType: 'added',
                        value: data2Item.value
                    });
                } else if (data1Item && data2Item) {
                    // å¯¹æ¯”å€¼
                    if (String(data1Item.value).trim() !== String(data2Item.value).trim()) {
                        if (diff.status === 'unchanged') diff.status = 'modified';
                        diff.changes.push({
                            type: 'config',
                            configKey: data1Item.configKey,
                            colIndex: data1Item.colIdx,
                            changeType: 'modified',
                            oldValue: data1Item.value,
                            newValue: data2Item.value
                        });
                    }
                }
            });

            // è½¬æ¢ä¸ºç»“æœè¡Œ
            differences.forEach((diff, partNo) => {
                if (diff.status === 'added') {
                    result.summary.addedRows++;
                    const row = {
                        partNo,
                        status: 'added',
                        cells: []
                    };
                    sortedColumns.forEach(colIdx => {
                        row.cells.push({
                            colIndex: colIdx,
                            value: getCellValue(data2[diff.row2Idx], colIdx),
                            changed: false
                        });
                    });
                    result.rows.push(row);
                } else if (diff.status === 'deleted') {
                    result.summary.deletedRows++;
                    const row = {
                        partNo,
                        status: 'deleted',
                        cells: []
                    };
                    sortedColumns.forEach(colIdx => {
                        row.cells.push({
                            colIndex: colIdx,
                            value: getCellValue(data1[diff.row1Idx], colIdx),
                            changed: false
                        });
                    });
                    result.rows.push(row);
                } else if (diff.status === 'modified' && diff.changes && diff.changes.length > 0) {
                    const row = {
                        partNo,
                        status: 'modified',
                        cells: [],
                        row1Idx: diff.row1Idx,
                        row2Idx: diff.row2Idx
                    };

                    sortedColumns.forEach(colIdx => {
                        const change = diff.changes.find(c => c.colIndex === colIdx);
                        if (change) {
                            result.summary.modifiedCells++;
                            row.cells.push({
                                colIndex: colIdx,
                                changed: true,
                                oldValue: change.oldValue || '',
                                newValue: change.newValue || change.value || '',
                                changeType: change.changeType
                            });
                        } else {
                            const val1 = diff.row1Idx !== undefined ? getCellValue(data1[diff.row1Idx], colIdx) : '';
                            const val2 = diff.row2Idx !== undefined ? getCellValue(data2[diff.row2Idx], colIdx) : '';
                            row.cells.push({
                                colIndex: colIdx,
                                changed: false,
                                value: val2 || val1
                            });
                        }
                    });

                    result.rows.push(row);
                }
            });

            return {
                result,
                data1,
                data2,
                structure1,
                structure2,
                sortedColumns,
                allColumns,
                modelKeyToIndex2,
                configKeyToIndex2,
                colWidths
            };
        }

        // å¼€å§‹æ¯”å¯¹
        document.getElementById('compareBtn').addEventListener('click', () => {
            const loading = document.getElementById('loading');
            loading.classList.add('show');

            setTimeout(() => {
                try {
                    const sheet1 = readSheetData(workbook1);
                    const sheet2 = readSheetData(workbook2);

                    comparisonResult = compareExcel(sheet1.data, sheet2.data, sheet2.colWidths);

                    displayResult(comparisonResult);

                    document.getElementById('exportBtn').disabled = false;
                } catch (error) {
                    alert('æ¯”å¯¹å¤±è´¥: ' + error.message);
                } finally {
                    loading.classList.remove('show');
                }
            }, 100);
        });

        // æ˜¾ç¤ºç»“æœ
        function displayResult(comparisonData, filter = 'all') {
            const { result, data1, data2, structure1, structure2, sortedColumns, allColumns, modelKeyToIndex2, configKeyToIndex2, colWidths } = comparisonData;
            currentFilter = filter;

            // æ›´æ–°æ‘˜è¦
            document.getElementById('modifiedCount').textContent = result.summary.modifiedCells;
            document.getElementById('addedRowsCount').textContent = result.summary.addedRows;
            document.getElementById('deletedRowsCount').textContent = result.summary.deletedRows;
            document.getElementById('addedColsCount').textContent = result.summary.addedColumns;
            document.getElementById('deletedColsCount').textContent = result.summary.deletedColumns;

            // æ›´æ–°ç­›é€‰æŒ‰é’®è®¡æ•°
            let addedCount = 0;
            let deletedCount = 0;
            let modifiedCount = 0;

            result.rows.forEach(row => {
                if (row.status === 'added') addedCount++;
                else if (row.status === 'deleted') deletedCount++;
                else if (row.status === 'modified') modifiedCount++;
            });

            const filterBtns = document.querySelectorAll('.filter-btn');
            filterBtns.forEach(btn => {
                const btnFilter = btn.dataset.filter;
                btn.classList.remove('active');

                if (btnFilter === 'all') {
                    btn.textContent = `å…¨éƒ¨ (${result.rows.length})`;
                } else if (btnFilter === 'added') {
                    btn.textContent = `æ–°å¢ (${addedCount})`;
                } else if (btnFilter === 'deleted') {
                    btn.textContent = `åˆ é™¤ (${deletedCount})`;
                } else if (btnFilter === 'modified') {
                    btn.textContent = `å˜æ›´ (${modifiedCount})`;
                }

                if (btnFilter === filter) {
                    btn.classList.add('active');
                }
            });

            // ç”Ÿæˆè¡¨æ ¼é¢„è§ˆ
            const tableContainer = document.getElementById('tableContainer');
            let html = '<table><colgroup>';

            // åº”ç”¨Excelå®é™…åˆ—å®½
            sortedColumns.forEach((colIdx, index) => {
                const colInfo = allColumns.get(colIdx);
                let width = 120;

                if (colInfo) {
                    if (colInfo.isDeleted) {
                        // åˆ é™¤çš„åˆ—ï¼Œä»æ—§ç‰ˆæœ¬åˆ—å®½ä¸­è·å–
                        width = colWidths && colWidths[colInfo.index] ? colWidths[colInfo.index] : 120;
                    } else if (colInfo.isAdded) {
                        // æ–°å¢çš„åˆ—ï¼Œä»æ–°ç‰ˆæœ¬åˆ—å®½ä¸­è·å–
                        width = colWidths && colWidths[colInfo.index] ? colWidths[colInfo.index] : 120;
                    } else {
                        // æ­£å¸¸åˆ—
                        width = colWidths && colWidths[colIdx] ? colWidths[colIdx] : 120;
                    }
                }

                html += `<col style="width: ${width}px;">`;
            });

            html += '</colgroup><thead>';

            // å‰4è¡Œæ ‡é¢˜è¡Œä½œä¸ºå›ºå®šè¡¨å¤´
            for (let i = 0; i < 4; i++) {
                html += '<tr>';
                sortedColumns.forEach(colIdx => {
                    const colInfo = allColumns.get(colIdx);
                    let cellValue;
                    let thClass = '';

                    // å¦‚æœæ˜¯åˆ é™¤çš„åˆ—ï¼Œä»æ—§ç‰ˆæœ¬è¯»å–æ•°æ®
                    if (colInfo && colInfo.isDeleted) {
                        cellValue = getCellValue(data1[i] || [], colInfo.index);
                        // ç¬¬4è¡Œï¼ˆç´¢å¼•3ï¼‰ç”¨çº¢è‰²æ ‡è®°åˆ é™¤çš„åˆ—æ ‡é¢˜
                        if (i === 3) {
                            thClass = 'col-header-deleted';
                        }
                    } else if (colInfo && colInfo.isAdded) {
                        // æ–°å¢çš„åˆ—ï¼Œä»æ–°ç‰ˆæœ¬è¯»å–æ•°æ®ï¼Œä½¿ç”¨colInfo.index
                        cellValue = getCellValue(data2[i] || [], colInfo.index);
                        // ç¬¬4è¡Œï¼ˆç´¢å¼•3ï¼‰ç”¨ç»¿è‰²æ ‡è®°æ–°å¢çš„åˆ—æ ‡é¢˜
                        if (i === 3) {
                            thClass = 'col-header-added';
                        }
                    } else {
                        // æ™®é€šåˆ—ï¼Œä»æ–°ç‰ˆæœ¬è¯»å–ï¼Œä½¿ç”¨colIdxï¼ˆæ˜¾ç¤ºç´¢å¼•ï¼Œç­‰äºæ–°ç‰ˆç´¢å¼•ï¼‰
                        cellValue = getCellValue(data2[i] || [], colIdx);
                    }

                    html += `<th class="${thClass}">${cellValue}</th>`;
                });
                html += '</tr>';
            }

            html += '</thead><tbody>';

            // æ·»åŠ åˆ†éš”çº¿
            html += '<tr><td colspan="' + sortedColumns.length + '" style="background: #e8e8e8; color: #666; text-align: center; padding: 8px; font-size: 12px; font-weight: bold;">â–¼ å·®å¼‚æ•°æ® â–¼</td></tr>';

            // æ•°æ®è¡Œï¼ˆæ ¹æ®ç­›é€‰æ¡ä»¶è¿‡æ»¤ï¼‰
            for (let i = 0; i < result.rows.length; i++) {
                const row = result.rows[i];

                // æ ¹æ®ç­›é€‰æ¡ä»¶è¿‡æ»¤
                if (filter === 'added' && row.status !== 'added') continue;
                if (filter === 'deleted' && row.status !== 'deleted') continue;
                if (filter === 'modified' && row.status !== 'modified') continue;

                let rowClass = '';
                if (row.status === 'added') rowClass = 'row-added';
                if (row.status === 'deleted') rowClass = 'row-deleted';

                // æ£€æŸ¥modifiedè¡Œæ˜¯å¦æœ‰å˜åŒ–çš„å•å…ƒæ ¼
                if (row.status === 'modified') {
                    const hasChangedCells = row.cells.some(cell => cell.changed);
                    if (hasChangedCells) {
                        rowClass += ' has-changes';
                    }
                }

                html += `<tr class="${rowClass}">`;

                row.cells.forEach(cell => {
                    let cellClass = '';
                    let cellValue = '';

                    if (row.status === 'added' || row.status === 'deleted') {
                        cellValue = cell.value || '';
                    } else if (cell.changed) {
                        // å˜æ›´åªæ˜¾ç¤ºæ–°å€¼ï¼Œç”¨é¢œè‰²æ ‡è®°
                        cellClass = 'cell-modified';
                        cellValue = cell.newValue || cell.value || '';
                    } else {
                        cellValue = cell.value || '';
                    }

                    html += `<td class="${cellClass}">${cellValue}</td>`;
                });

                html += '</tr>';
            }

            html += '</tbody></table>';

            tableContainer.innerHTML = html;

            document.getElementById('resultSection').classList.add('show');
        }

        // ç­›é€‰æŒ‰é’®äº‹ä»¶ç›‘å¬
        document.querySelectorAll('.filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                if (!comparisonResult) return;
                const filter = btn.dataset.filter;
                displayResult(comparisonResult, filter);
            });
        });

        // å¯¼å‡ºç»“æœ
        document.getElementById('exportBtn').addEventListener('click', () => {
            if (!comparisonResult) return;

            const { result, data1, data2, sortedColumns } = comparisonResult;

            // åˆ›å»ºå¯¼å‡ºæ•°æ®
            const exportData = [];

            // å‰4è¡Œï¼ˆæ ‡é¢˜è¡Œï¼‰
            for (let i = 0; i < 4; i++) {
                const row = [];
                sortedColumns.forEach(colIdx => {
                    row.push(getCellValue(data2[i] || [], colIdx));
                });
                exportData.push(row);
            }

            // æ·»åŠ ç©ºè¡Œ
            exportData.push(new Array(sortedColumns.length).fill(''));

            // æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
            exportData.push(['æ¯”å¯¹ç»“æœæ‘˜è¦', '', '', '', '', '', '', '']);
            exportData.push(['å•å…ƒæ ¼å˜æ›´', result.summary.modifiedCells, '', '', '', '', '', '']);
            exportData.push(['æ–°å¢è¡Œ', result.summary.addedRows, '', '', '', '', '', '']);
            exportData.push(['åˆ é™¤è¡Œ', result.summary.deletedRows, '', '', '', '', '', '']);
            exportData.push(['æ–°å¢åˆ—', result.summary.addedColumns, '', '', '', '', '', '']);
            exportData.push(['åˆ é™¤åˆ—', result.summary.deletedColumns, '', '', '', '', '', '']);

            // æ·»åŠ ç©ºè¡Œ
            exportData.push(new Array(sortedColumns.length).fill(''));

            // æ•°æ®è¡Œ
            result.rows.forEach(row => {
                const dataRow = [];
                row.cells.forEach(cell => {
                    if (row.status === 'added') {
                        dataRow.push(cell.value || '');
                    } else if (row.status === 'deleted') {
                        dataRow.push(cell.value || '');
                    } else if (cell.changed) {
                        dataRow.push(cell.newValue || cell.value || '');
                    } else {
                        dataRow.push(cell.value || '');
                    }
                });
                exportData.push(dataRow);
            });

            // ç”ŸæˆExcel
            const ws = XLSX.utils.aoa_to_sheet(exportData);

            // è®¾ç½®åˆ—å®½
            const colWidths = sortedColumns.map(() => ({ wch: 15 }));
            ws['!cols'] = colWidths;

            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'æ¯”å¯¹ç»“æœ');

            // å¯¼å‡ºæ–‡ä»¶
            const now = new Date();
            const timestamp = now.toISOString().slice(0, 10).replace(/-/g, '');
            XLSX.writeFile(wb, `MasterListæ¯”å¯¹ç»“æœ_${timestamp}.xlsx`);
        });
    </script>
</body>
</html>
